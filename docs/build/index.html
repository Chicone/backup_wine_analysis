<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Welcome to Wine Analysis Library’s documentation! &#8212; Wine Analysis Library 0.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=4f649999" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=cb25574f" />
    <script src="_static/documentation_options.js?v=01f34227"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="welcome-to-wine-analysis-library-s-documentation">
<h1>Welcome to Wine Analysis Library’s documentation!<a class="headerlink" href="#welcome-to-wine-analysis-library-s-documentation" title="Link to this heading">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
</section>
<section id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Link to this heading">¶</a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
<section id="wine-analysis-library-documentation">
<h2>Wine Analysis Library Documentation<a class="headerlink" href="#wine-analysis-library-documentation" title="Link to this heading">¶</a></h2>
<p>Welcome to the <strong>Wine Analysis Library</strong> documentation!</p>
<section id="overview">
<h3>Overview<a class="headerlink" href="#overview" title="Link to this heading">¶</a></h3>
<p>The Wine Analysis Library is a comprehensive toolkit designed for analyzing and processing wine-related data.
The library provides various modules to facilitate data loading, preprocessing, dimensionality reduction,
classification, and visualization of wine chromatograms and related datasets.</p>
<section id="key-features">
<h4>Key Features<a class="headerlink" href="#key-features" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p><strong>Data Loading &amp; Preprocessing</strong>: Load and preprocess wine datasets efficiently using custom utilities.</p></li>
<li><p><strong>Dimensionality Reduction</strong>: Apply various dimensionality reduction techniques like PCA (Principal Component Analysis) to simplify complex datasets.</p></li>
<li><p><strong>Classification</strong>: Use machine learning classifiers to categorize wine samples based on their chemical compositions or other features.</p></li>
<li><p><strong>Visualization</strong>: Generate informative visualizations, including chromatograms and scatter plots, to explore and present the data effectively.</p></li>
<li><p><strong>Analysis</strong>: Perform detailed analysis on wine data, including peak detection and alignment across samples.</p></li>
</ul>
</section>
</section>
<section id="installation">
<h3>Installation<a class="headerlink" href="#installation" title="Link to this heading">¶</a></h3>
<p>This repository contains multiple development branches for different use cases and experimental pipelines.
The wine-analysis-package branch is the simplest and most stable version, specifically intended for basic GC-MS data analysis workflows. It includes the core functionalities for chromatogram preprocessing, alignment, classification, and visualization, and is ideal for most users working with wine or chemical analysis datasets.</p>
<p>To use this version, make sure to clone and switch to this branch:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># Clone the repository and switch to the correct branch</span>
git<span class="w"> </span>clone<span class="w"> </span>https://github.com/pougetlab/wine_analysis.git
<span class="nb">cd</span><span class="w"> </span>wine_analysis
git<span class="w"> </span>checkout<span class="w"> </span>wine-analysis-package

<span class="c1"># (Optional) Create and activate a virtual environment</span>
python<span class="w"> </span>-m<span class="w"> </span>venv<span class="w"> </span>.venv
<span class="nb">source</span><span class="w"> </span>.venv/bin/activate<span class="w">  </span><span class="c1"># On Windows: .venv\Scripts\activate</span>

<span class="c1"># Install the package in editable mode</span>
pip<span class="w"> </span>install<span class="w"> </span>-e<span class="w"> </span>.

<span class="c1"># Install dependencies</span>
pip<span class="w"> </span>install<span class="w"> </span>-r<span class="w"> </span>requirements.txt
</pre></div>
</div>
<p>Some modules in this library may require extra dependencies that are not automatically listed in requirements.txt.
If you encounter import errors when running scripts, make sure to install the following commonly used packages:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pip<span class="w"> </span>install<span class="w"> </span>torch<span class="w"> </span>torchvision<span class="w"> </span>pynndescent<span class="w"> </span>netCDF4<span class="w"> </span>seaborn<span class="w"> </span>umap-learn<span class="w"> </span>tqdm<span class="w"> </span>scikit-optimize
</pre></div>
</div>
</section>
<section id="overview-of-the-cross-dataset-classification-pipeline">
<h3>Overview of the cross-dataset classification pipeline<a class="headerlink" href="#overview-of-the-cross-dataset-classification-pipeline" title="Link to this heading">¶</a></h3>
<p>The script in <code class="docutils literal notranslate"><span class="pre">main.py</span></code> contains instructions to calculate, among other things, the cross-dataset classification accuracy.
This consists on training a classification model on one dataset (2018 oak) and testing it on another dataset (2022 oak).
To ensure accurate comparison and classification, the chromatograms from both datasets are aligned or synchronised to a
common reference using two main algorithms, which are applied sequentially. The reference chromatogram is set to be the
mean chromatogram of the 2018 dataset.
_</p>
<section id="step-1-initial-alignment-with-lag-profile-from-peaks">
<h4>Step 1: Initial Alignment with <code class="docutils literal notranslate"><span class="pre">lag_profile_from_peaks()</span></code><a class="headerlink" href="#step-1-initial-alignment-with-lag-profile-from-peaks" title="Link to this heading">¶</a></h4>
<p>The first algorithm, <code class="docutils literal notranslate"><span class="pre">lag_profile_from_peaks()</span></code>, is responsible for calculating an initial alignment between target
chromatograms and the reference. It does so by identifying peaks in both and trying to match them based on their
distance, scaling sections accordingly. A peak is defined as any datapoint whose value is larger than the immediate
datapoints to its left and right.</p>
<section id="global-alignment">
<h5>Global Alignment:<a class="headerlink" href="#global-alignment" title="Link to this heading">¶</a></h5>
<p>There is an initial step where the target chromatograms are shifted globally in order maximize the cross-correlation
with the reference chromatogram, providing a first rough alignment.  However, only the first third of the chromatograms
is used in the computation of the cross-correlation. There seems to be non-linear relationships between peaks locations
when comparing target and  reference chromatograms, and therefore  we focus on the first third to make sure
that at least this part is correctly aligned. This is important because it provides a starting point for the
next alignment steps. A Gaussian filter is applied to smooth both chromatograms before the global alignment.</p>
</section>
<section id="between-peak-section-alignment">
<h5>Between-peak Section Alignment:<a class="headerlink" href="#between-peak-section-alignment" title="Link to this heading">¶</a></h5>
<p>It can be summarized in the following points:</p>
<ul class="simple">
<li><p>After the global shift, both reference and target chromatograms are divided into segments and the location of the
largest peak from each segment selected. Alignment then proceeds by matching selected peaks in the target chromatogram
with those in the reference. The matching is based on finding the closest peak in the reference to the current peak
in the target. If the closest peak is farther than an alignment tolerance of 40 retention time units, then we skip this
alignment  and move into the next peak in the target and so on.</p></li>
<li><p>Looking at each pair of matched peaks, the difference between their locations is used to calculate a scaling factor
that is locally applied to the target chromatogram. The locality means that we only scale the interval between
the current target peak and the (corrected) target peak from the previous segment, which was adjusted
to the same location as the previous reference peak.</p></li>
<li><p>The output from this algorithm is a set of lag values that describe how much each segment of the target chromatogram
should be shifted to align with the reference.</p></li>
<li><p>Using this lag profile, we can fit a spline and adjust the retention times of the original target chromatogram to
the reference in a very smooth fashion. The spline is allowed some flexibility to fit the points so that the
adjustment of peak locations is somehow soft.</p></li>
<li><p>This algorithm has the disadvantage that all the data between the peaks used for alignment are also scaled.
The problem with this is that if some peaks have location somehow incorrect or if they are incorrectly aligned, the
errors will also be transmitted to other peaks, potentially distorting the data too much. This is also the reason why
this algorithm is only used as a preprocessing step to locally and roughly align the chromatograms based on the major peaks.</p></li>
<li><p>As a stand-alone algorithm after the global alignment, it produces a cross-dataset classification accuracy of 65.3%.</p></li>
</ul>
</section>
</section>
<section id="step-2-fine-tuning-with-lag-profile-moving-peaks-individually">
<h4>Step 2: Fine-Tuning with <code class="docutils literal notranslate"><span class="pre">lag_profile_moving_peaks_individually()</span></code><a class="headerlink" href="#step-2-fine-tuning-with-lag-profile-moving-peaks-individually" title="Link to this heading">¶</a></h4>
<p>After applying the initial global and between-peak alignment, the synchronization is refined using the algorithm in
<code class="docutils literal notranslate"><span class="pre">lag_profile_moving_peaks_individually()</span></code>.</p>
<ul class="simple">
<li><p>The function is designed to refine the alignment between the reference chromatogram and the target chromatogram by
adjusting the positions of individual peaks in the target chromatogram without affecting other peaks.</p></li>
<li><p>Contrary to the previous algorithm, only the regions between the peaks and their closest neighbour peaks (as
opposed to the region between the peak in the peak in the previous segment) are scaled.</p></li>
<li><p>The scaling is carried out on both sides of the peak. The left part is used to bring the peak to the location of the
reference whereas the right region is scaled in the opposite direction to compensate for the left shift, so that the
rest of the chromatogram stays largely unaffected.</p></li>
<li><p>The matching of target peaks to reference peaks is based on checking not only the closest reference peak, but
also its surrounding peaks.</p></li>
<li><p>For each surrounding peak, the scaling is performed as if it was the actual matched peak, and the resulting segment
is compared with the reference segment to see how well they match. The surrounding peak that matches the best is
selected for the scaling.</p></li>
<li><p>The comparison is based on checking, after the scaling, the average separation between target and reference peaks
not only within the segment, but also within a significant portion of signal after it (e.g. 3000 retention time units).
This makes the comparison more robust.</p></li>
<li><p>A disadvantage of this algorithm is that it is very sensitive to changes in hyperparameters and the latter must be
tuned very carefully.</p></li>
<li><p>Applied after the global and between-peak alignments, this algorithm produces a cross-dataset classification accuracy
of 84.0%.</p></li>
</ul>
</section>
<section id="final-step-classification-and-evaluation">
<h4>Final Step: Classification and Evaluation<a class="headerlink" href="#final-step-classification-and-evaluation" title="Link to this heading">¶</a></h4>
<p>With the chromatograms from both datasets now synchronized to a common reference, the script proceeds to train a
classification model using the synchronized chromatograms from the 2018 oak dataset. This model is then tested on the
synchronized chromatograms from the 2022 oak dataset to evaluate cross-dataset accuracy.</p>
<ul class="simple">
<li><p><strong>Model Training</strong>:</p>
<ul>
<li><p>The classifier (LDA) is trained on the synchronized chromatograms from the 2018 oak dataset. The features used for
classification are the intensities at specific retention times.</p></li>
</ul>
</li>
<li><p><strong>Model Testing</strong>:</p>
<ul>
<li><p>The trained classifier is then applied to the synchronized chromatograms from the 2022 oak dataset to predict the
labels.</p></li>
</ul>
</li>
<li><p><strong>Evaluation</strong>:</p>
<ul>
<li><p>The script calculates the accuracy of the model by comparing the predicted labels to the actual labels in the 2022
oak dataset. This accuracy indicates how well the model generalizes from one dataset to another, reflecting the
robustness of the synchronization and classification process.</p></li>
</ul>
</li>
</ul>
<p>This workflow ensures that the features used for classification are consistent across datasets, leading to more reliable
and generalizable models when analyzing chromatograms from different sources.</p>
</section>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="#">Wine Analysis Library</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2025, Luis Gomez Camara.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>