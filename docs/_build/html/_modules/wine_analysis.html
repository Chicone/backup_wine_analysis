<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>wine_analysis &#8212; Wine Analysis 0.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=12dfc556" />
    <script src="../_static/documentation_options.js?v=01f34227"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for wine_analysis</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Wine Analysis Overview</span>
<span class="sd">====================</span>

<span class="sd">This module provides tools and methods for analyzing wine-related data, particularly focusing on chromatogram analysis and dimensionality reduction techniques.</span>

<span class="sd">Key Features:</span>
<span class="sd">-------------</span>
<span class="sd">- **WineAnalysis Class**: Facilitates the analysis of wine datasets, including the ability to run dimensionality reduction techniques such as t-SNE and UMAP, as well as train classifiers.</span>
<span class="sd">- **ChromatogramAnalysis Class**: Handles the loading, normalization, and merging of chromatogram data, as well as synchronization and scaling of chromatograms.</span>
<span class="sd">- **SyncChromatograms Class**: Provides advanced techniques for aligning chromatograms, including methods for adjusting retention times and synchronizing chromatograms based on peak alignment.</span>

<span class="sd">Usage:</span>
<span class="sd">------</span>
<span class="sd">This module is intended for wine researchers and data scientists who need to analyze complex chromatographic data. The classes and methods provided can be used to preprocess, analyze, and visualize data, making it easier to identify patterns and trends in wine samples.</span>

<span class="sd">Dependencies:</span>
<span class="sd">-------------</span>
<span class="sd">The module relies on several third-party libraries, including:</span>
<span class="sd">- `numpy` for numerical operations</span>
<span class="sd">- `pandas` for data manipulation</span>
<span class="sd">- `scikit-learn` for machine learning and dimensionality reduction</span>
<span class="sd">- `matplotlib` for plotting and visualization</span>
<span class="sd">- `scipy` for signal processing and interpolation</span>

<span class="sd">Example:</span>
<span class="sd">--------</span>
<span class="sd">An example of using the `WineAnalysis` class to run a t-SNE analysis:</span>

<span class="sd">```</span>
<span class="sd">python from wine_analysis import WineAnalysis</span>

<span class="sd"># Initialize the WineAnalysis class with a data file</span>
<span class="sd">analysis = WineAnalysis(file_path=&#39;wine_data.npy&#39;, normalize=True)</span>

<span class="sd"># Run t-SNE on the dataset and plot the results</span>
<span class="sd">analysis.run_tsne(perplexity=30, random_state=42, plot=True)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">dcor</span> <span class="kn">import</span> <span class="n">distance_correlation</span>

<span class="kn">import</span> <span class="nn">utils</span>
<span class="kn">from</span> <span class="nn">data_loader</span> <span class="kn">import</span> <span class="n">DataLoader</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span>
<span class="kn">from</span> <span class="nn">classification</span> <span class="kn">import</span> <span class="n">Classifier</span>
<span class="kn">from</span> <span class="nn">dimensionality_reduction</span> <span class="kn">import</span> <span class="n">DimensionalityReducer</span>
<span class="kn">from</span> <span class="nn">visualizer</span> <span class="kn">import</span> <span class="n">Visualizer</span>
<span class="kn">from</span> <span class="nn">dimensionality_reduction</span> <span class="kn">import</span> <span class="n">run_umap_and_evaluate</span><span class="p">,</span> <span class="n">run_tsne_and_evaluate</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">UnivariateSpline</span>
<span class="kn">import</span> <span class="nn">tkinter</span> <span class="k">as</span> <span class="nn">tk</span>
<span class="kn">from</span> <span class="nn">tkinter</span> <span class="kn">import</span> <span class="n">filedialog</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">correlate</span><span class="p">,</span> <span class="n">find_peaks</span><span class="p">,</span> <span class="n">peak_prominences</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">pearsonr</span>
<span class="kn">from</span> <span class="nn">fastdtw</span> <span class="kn">import</span> <span class="n">fastdtw</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">euclidean</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">gaussian_filter1d</span>
<span class="kn">from</span> <span class="nn">utils</span> <span class="kn">import</span> <span class="n">normalize_dict</span><span class="p">,</span> <span class="n">remove_peak</span><span class="p">,</span> <span class="n">min_max_normalize</span><span class="p">,</span> <span class="n">normalize_data</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">gaussian_filter</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">mutual_info_score</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">spearmanr</span><span class="p">,</span> <span class="n">kendalltau</span>
<span class="kn">import</span> <span class="nn">utils</span>

<div class="viewcode-block" id="WineAnalysis">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.WineAnalysis">[docs]</a>
<span class="k">class</span> <span class="nc">WineAnalysis</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        WineAnalysis Class</span>
<span class="sd">        ==================</span>

<span class="sd">        The `WineAnalysis` class is designed to facilitate the analysis of wine-related chromatographic data.</span>
<span class="sd">        It provides methods for loading data from various sources, performing dimensionality reduction, and running</span>
<span class="sd">        classification algorithms to extract meaningful insights from the data.</span>

<span class="sd">        Key Features:</span>
<span class="sd">        -------------</span>
<span class="sd">        - **Data Loading**: Load wine chromatographic data from .npy or .xlsx files, or directly from a dictionary.</span>
<span class="sd">        - **Dimensionality Reduction**: Apply techniques like PCA, t-SNE, and UMAP to reduce the dimensionality of the data.</span>
<span class="sd">        - **Classification**: Train classifiers such as LDA on the data to evaluate and compare different wine samples.</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">file_path</span><span class="p">:</span>
            <span class="n">script_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">script_dir</span><span class="p">,</span> <span class="n">file_path</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The file </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="si">}</span><span class="s2"> does not exist.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_loader</span> <span class="o">=</span> <span class="n">DataLoader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_loader</span><span class="o">.</span><span class="n">df</span><span class="p">)</span>
            <span class="c1"># self.data = self.data_loader.get_standardized_data()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_loader</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chem_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">data_dict</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_loader</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data_dict</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data_dict</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">data_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chem_name</span> <span class="o">=</span> <span class="s2">&quot;Not available&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Either file_path or data_dict must be provided.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="WineAnalysis.train_classifier">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.WineAnalysis.train_classifier">[docs]</a>
    <span class="k">def</span> <span class="nf">train_classifier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">classifier_type</span><span class="o">=</span><span class="s1">&#39;LDA&#39;</span><span class="p">,</span> <span class="n">vintage</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_splits</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="n">clf</span> <span class="o">=</span> <span class="n">Classifier</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span> <span class="n">classifier_type</span><span class="o">=</span><span class="n">classifier_type</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">clf</span><span class="o">.</span><span class="n">train_and_evaluate</span><span class="p">(</span><span class="n">n_splits</span><span class="p">,</span> <span class="n">vintage</span><span class="o">=</span><span class="n">vintage</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">)</span></div>


<div class="viewcode-block" id="WineAnalysis.run_tsne">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.WineAnalysis.run_tsne">[docs]</a>
    <span class="k">def</span> <span class="nf">run_tsne</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perplexity</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">best_score</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Runs t-Distributed Stochastic Neighbor Embedding (t-SNE) on the data and plots the results.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reducer</span> <span class="o">=</span> <span class="n">DimensionalityReducer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">tsne_result</span> <span class="o">=</span> <span class="n">reducer</span><span class="o">.</span><span class="n">tsne</span><span class="p">(</span><span class="n">components</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">perplexity</span><span class="o">=</span><span class="n">perplexity</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>
        <span class="c1"># tsne_result = reducer.tsne(components=2, perplexity=15, random_state=10)</span>
        <span class="n">tsne_result</span> <span class="o">=</span> <span class="o">-</span><span class="n">tsne_result</span>  <span class="c1"># change the sign of the axes to show data like in the paper</span>
        <span class="n">tsne_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">tsne_result</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;t-SNE Component 1&#39;</span><span class="p">,</span> <span class="s1">&#39;t-SNE Component 2&#39;</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
        <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;tSNE on </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">chem_name</span><span class="si">}</span><span class="s1">; </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s1"> wines</span><span class="se">\n</span><span class="s1">Silhouette score: </span><span class="si">{</span><span class="n">best_score</span><span class="si">}</span><span class="s1"> &#39;</span>
        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">Visualizer</span><span class="o">.</span><span class="n">plot_2d_results</span><span class="p">(</span><span class="n">tsne_df</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="s1">&#39;t-SNE Component 1&#39;</span><span class="p">,</span> <span class="s1">&#39;t-SNE Component 2&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WineAnalysis.run_umap">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.WineAnalysis.run_umap">[docs]</a>
    <span class="k">def</span> <span class="nf">run_umap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">best_score</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Runs Uniform Manifold Approximation and Projection (UMAP) on the data and plots the results.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">reducer</span> <span class="o">=</span> <span class="n">DimensionalityReducer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">umap_result</span> <span class="o">=</span> <span class="n">reducer</span><span class="o">.</span><span class="n">umap</span><span class="p">(</span><span class="n">components</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>  <span class="c1"># for concat</span>
        <span class="c1"># umap_result = reducer.umap(components=2, n_neighbors=60, random_state=20)  # for oak</span>
        <span class="c1"># umap_result = reducer.umap(components=2, n_neighbors=50, random_state=0)  # for 7 estates 2018+2022</span>
        <span class="c1"># umap_result = reducer.umap(components=2, n_neighbors=75, random_state=70)  # from searchgrid</span>
        <span class="n">umap_result</span> <span class="o">=</span> <span class="o">-</span><span class="n">umap_result</span>  <span class="c1"># change the sign of the axes to show data like in the paper</span>
        <span class="n">umap_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">umap_result</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;UMAP Component 1&#39;</span><span class="p">,</span> <span class="s1">&#39;UMAP Component 2&#39;</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
        <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">title</span><span class="si">}</span><span class="s1">; </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s1"> wines</span><span class="se">\n</span><span class="s1"> Score: </span><span class="si">{</span><span class="n">best_score</span><span class="si">}</span><span class="s1"> &#39;</span>
        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">Visualizer</span><span class="o">.</span><span class="n">plot_2d_results</span><span class="p">(</span><span class="n">umap_df</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="s1">&#39;UMAP Component 1&#39;</span><span class="p">,</span> <span class="s1">&#39;UMAP Component 2&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">umap_df</span></div>
</div>



<div class="viewcode-block" id="ChromatogramAnalysis">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.ChromatogramAnalysis">[docs]</a>
<span class="k">class</span> <span class="nc">ChromatogramAnalysis</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ChromatogramAnalysis Class</span>
<span class="sd">        ==========================</span>

<span class="sd">        The `ChromatogramAnalysis` class is responsible for managing chromatogram data in wine analysis. It provides methods to load, resample, synchronize, and merge chromatograms from different datasets, making it a vital tool for comparative analysis of wine samples.</span>

<span class="sd">        Key Features:</span>
<span class="sd">        -------------</span>
<span class="sd">        - **Data Loading**: Load chromatograms from various file formats.</span>
<span class="sd">        - **Resampling and Merging**: Resample chromatograms to a common time axis and merge data from different sources.</span>
<span class="sd">        - **Synchronization**: Synchronize chromatograms by aligning peaks and adjusting retention times.</span>

<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path1</span><span class="p">,</span> <span class="n">file_path2</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file_path1</span> <span class="o">=</span> <span class="n">file_path1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file_path2</span> <span class="o">=</span> <span class="n">file_path2</span>

<div class="viewcode-block" id="ChromatogramAnalysis.load_chromatogram">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.ChromatogramAnalysis.load_chromatogram">[docs]</a>
    <span class="k">def</span> <span class="nf">load_chromatogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span></div>


<div class="viewcode-block" id="ChromatogramAnalysis.load_chromatograms">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.ChromatogramAnalysis.load_chromatograms">[docs]</a>
    <span class="k">def</span> <span class="nf">load_chromatograms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">chromatograms</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">file_path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_paths</span><span class="p">:</span>
            <span class="n">chrom_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_chromatogram</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
            <span class="n">chromatograms</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">chrom_data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">chromatograms</span></div>



<div class="viewcode-block" id="ChromatogramAnalysis.normalize_chromatogram">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.ChromatogramAnalysis.normalize_chromatogram">[docs]</a>
    <span class="k">def</span> <span class="nf">normalize_chromatogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chromatogram</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normalizes the chromatogram data using StandardScaler.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        chromatogram (np.ndarray): The input chromatogram data.</span>

<span class="sd">        Returns:</span>
<span class="sd">        np.ndarray: The normalized chromatogram.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
        <span class="n">chromatogram</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">chromatogram</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Reshape for StandardScaler</span>
        <span class="n">normalized_chromatogram</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">chromatogram</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>  <span class="c1"># Fit and transform, then flatten back</span>
        <span class="k">return</span> <span class="n">normalized_chromatogram</span></div>



<div class="viewcode-block" id="ChromatogramAnalysis.calculate_mean_chromatogram">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.ChromatogramAnalysis.calculate_mean_chromatogram">[docs]</a>
    <span class="k">def</span> <span class="nf">calculate_mean_chromatogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chromatograms</span><span class="p">):</span>
        <span class="n">all_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">chromatograms</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="n">mean_chromatogram</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">all_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mean_chromatogram</span></div>



<div class="viewcode-block" id="ChromatogramAnalysis.merge_chromatograms">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.ChromatogramAnalysis.merge_chromatograms">[docs]</a>
    <span class="k">def</span> <span class="nf">merge_chromatograms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chrom1</span><span class="p">,</span> <span class="n">chrom2</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merges two chromatogram dictionaries, normalizes them, and handles duplicate sample names.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        chrom1 (dict): The first chromatogram dictionary.</span>
<span class="sd">        chrom2 (dict): The second chromatogram dictionary.</span>

<span class="sd">        Returns:</span>
<span class="sd">        dict: The merged and normalized chromatogram data.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">merged_chromatograms</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">chrom1</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># # remove extra peak from standard</span>
            <span class="c1"># value = sc_inst.remove_peak(self, value, peak_idx=8910, window_size=30)</span>
            <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
                <span class="n">merged_chromatograms</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize_chromatogram</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">merged_chromatograms</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">chrom2</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">merged_chromatograms</span> <span class="ow">or</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="ow">in</span> <span class="n">merged_chromatograms</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">b&quot;</span>
            <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
                <span class="n">merged_chromatograms</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize_chromatogram</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">merged_chromatograms</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">return</span> <span class="n">merged_chromatograms</span></div>


<div class="viewcode-block" id="ChromatogramAnalysis.resample_chromatogram">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.ChromatogramAnalysis.resample_chromatogram">[docs]</a>
    <span class="k">def</span> <span class="nf">resample_chromatogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">new_length</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resamples a chromatogram to a new length using interpolation.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        chrom (np.ndarray): The chromatogram to be resampled.</span>
<span class="sd">        new_length (int): The new length for the chromatogram.</span>

<span class="sd">        Returns:</span>
<span class="sd">        np.ndarray: The resampled chromatogram.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x_old</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">chrom</span><span class="p">))</span>
        <span class="n">x_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">new_length</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">x_old</span><span class="p">,</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">x_new</span><span class="p">)</span></div>


<div class="viewcode-block" id="ChromatogramAnalysis.tsne_analysis">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.ChromatogramAnalysis.tsne_analysis">[docs]</a>
    <span class="k">def</span> <span class="nf">tsne_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dict</span><span class="p">,</span> <span class="n">vintage</span><span class="p">,</span> <span class="n">chem_name</span><span class="p">):</span>
        <span class="n">analysis</span> <span class="o">=</span> <span class="n">WineAnalysis</span><span class="p">(</span><span class="n">data_dict</span><span class="o">=</span><span class="n">data_dict</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="n">Classifier</span><span class="p">(</span><span class="n">analysis</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">analysis</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
        <span class="n">perplexity</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">best_score</span> <span class="o">=</span> <span class="n">run_tsne_and_evaluate</span><span class="p">(</span>
            <span class="n">analysis</span><span class="p">,</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_process_labels</span><span class="p">(</span><span class="n">vintage</span><span class="p">),</span>
            <span class="n">chem_name</span><span class="p">,</span>
            <span class="n">perplexities</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
            <span class="n">random_states</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">96</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">analysis</span><span class="o">.</span><span class="n">run_tsne</span><span class="p">(</span><span class="n">perplexity</span><span class="o">=</span><span class="n">perplexity</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="n">best_score</span><span class="o">=</span><span class="n">best_score</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

        <span class="c1"># analysis.run_umap(n_neighbors=10, random_state=10, best_score=10)</span>
<span class="c1">#</span>
<div class="viewcode-block" id="ChromatogramAnalysis.umap_analysis">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.ChromatogramAnalysis.umap_analysis">[docs]</a>
    <span class="k">def</span> <span class="nf">umap_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dict</span><span class="p">,</span> <span class="n">vintage</span><span class="p">,</span> <span class="n">chem_name</span><span class="p">,</span> <span class="n">neigh_range</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">random_states</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">96</span><span class="p">,</span> <span class="mi">16</span><span class="p">)):</span>
        <span class="n">analysis</span> <span class="o">=</span> <span class="n">WineAnalysis</span><span class="p">(</span><span class="n">data_dict</span><span class="o">=</span><span class="n">data_dict</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="n">Classifier</span><span class="p">(</span><span class="n">analysis</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">analysis</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
        <span class="n">n_neighbors</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">best_score</span> <span class="o">=</span> <span class="n">run_umap_and_evaluate</span><span class="p">(</span>
            <span class="n">analysis</span><span class="p">,</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_process_labels</span><span class="p">(</span><span class="n">vintage</span><span class="p">),</span>
            <span class="n">chem_name</span><span class="p">,</span>
            <span class="n">neigh_range</span><span class="o">=</span><span class="n">neigh_range</span><span class="p">,</span>
            <span class="n">random_states</span><span class="o">=</span><span class="n">random_states</span>
        <span class="p">)</span>
        <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;UMAP on </span><span class="si">{</span><span class="n">chem_name</span><span class="si">}</span><span class="s1">; neigh=</span><span class="si">{</span><span class="n">n_neighbors</span><span class="si">}</span><span class="s1">, random state=</span><span class="si">{</span><span class="n">random_state</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">analysis</span><span class="o">.</span><span class="n">run_umap</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="n">best_score</span><span class="o">=</span><span class="n">best_score</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">)</span></div>

        <span class="c1"># analysis.run_umap(n_neighbors=10, random_state=10, best_score=10)</span>
<span class="c1">#</span>

<div class="viewcode-block" id="ChromatogramAnalysis.sync_individual_chromatograms">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.ChromatogramAnalysis.sync_individual_chromatograms">[docs]</a>
    <span class="k">def</span> <span class="nf">sync_individual_chromatograms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference_chromatogram</span><span class="p">,</span> <span class="n">input_chromatograms</span><span class="p">,</span> <span class="n">scales</span><span class="p">,</span> <span class="n">initial_lag</span><span class="o">=</span><span class="mi">300</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Synchronize individual chromatograms with a reference chromatogram.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reference_chromatogram : array-like</span>
<span class="sd">            The reference chromatogram to which the individual chromatograms will be synchronized.</span>
<span class="sd">        input_chromatograms : dict</span>
<span class="sd">            A dictionary where keys are labels for each chromatogram, and values are the chromatograms to be synchronized.</span>
<span class="sd">        scales : array-like</span>
<span class="sd">            Scaling factors to be applied during synchronization.</span>
<span class="sd">        initial_lag : int, optional</span>
<span class="sd">            The initial lag to be considered for synchronization, by default 300.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            A dictionary with the same keys as `input_chromatograms`, where each value is the synchronized chromatogram.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function uses the `SyncChromatograms` class from the `wine_analysis` module to perform the synchronization.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; synced_chromatograms = obj.sync_individual_chromatograms(reference_chromatogram, input_chromatograms, scales)</span>
<span class="sd">        &gt;&gt;&gt; print(synced_chromatograms[&#39;label1&#39;])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">wine_analysis</span> <span class="kn">import</span> <span class="n">SyncChromatograms</span>

        <span class="n">synced_chromatograms</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">input_chromatograms</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="n">chrom</span> <span class="o">=</span> <span class="n">input_chromatograms</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">sync_chrom</span> <span class="o">=</span> <span class="n">SyncChromatograms</span><span class="p">(</span>
                <span class="n">reference_chromatogram</span><span class="p">,</span> <span class="n">chrom</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">scales</span><span class="p">,</span> <span class="mf">1E6</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.00</span><span class="p">,</span> <span class="n">max_sep_threshold</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                <span class="n">peak_prominence</span><span class="o">=</span><span class="mf">0.00</span>
            <span class="p">)</span>
            <span class="n">optimized_chrom</span> <span class="o">=</span> <span class="n">sync_chrom</span><span class="o">.</span><span class="n">adjust_chromatogram</span><span class="p">()</span>
            <span class="n">synced_chromatograms</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">optimized_chrom</span>

        <span class="k">return</span> <span class="n">synced_chromatograms</span></div>


<div class="viewcode-block" id="ChromatogramAnalysis.stacked_2D_plots_3D">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.ChromatogramAnalysis.stacked_2D_plots_3D">[docs]</a>
    <span class="k">def</span> <span class="nf">stacked_2D_plots_3D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates stacked 2D plots in a 3D space for the given dictionary of data.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        data_dict (dict): A dictionary with labels as keys and lists of values as values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>

        <span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="n">num_plots</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c1"># Offset between plots in the z direction</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">values</span><span class="p">)):</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="n">offset</span><span class="p">)</span>  <span class="c1"># Set the z value to stack plots</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">zs</span><span class="o">=</span><span class="n">z</span><span class="p">,</span> <span class="n">zdir</span><span class="o">=</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>

            <span class="c1"># Show legend for the first and last plots</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="n">num_plots</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;X-axis&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Y-axis&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;Plot index&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Stacked 2D Plots in 3D&#39;</span><span class="p">)</span>

        <span class="c1"># Set the initial view to make y-axis vertical</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="n">elev</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">azim</span><span class="o">=-</span><span class="mi">90</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">15000</span><span class="p">])</span>
        <span class="c1"># ax.set_ylim([0, 0.2])</span>

        <span class="k">def</span> <span class="nf">on_key</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;r&#39;</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="n">elev</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">azim</span><span class="o">=-</span><span class="mi">90</span><span class="p">)</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>

        <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span><span class="s1">&#39;key_press_event&#39;</span><span class="p">,</span> <span class="n">on_key</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="ChromatogramAnalysis.stacked_plot">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.ChromatogramAnalysis.stacked_plot">[docs]</a>
    <span class="k">def</span> <span class="nf">stacked_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a stacked plot for the given dictionary of data.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        data_dict (dict): A dictionary with labels as keys and lists of values as values.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="c1"># Ensure all lists have the same length</span>
        <span class="n">max_length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="k">for</span> <span class="n">lst</span> <span class="ow">in</span> <span class="n">values</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_length</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">lst</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>

        <span class="c1"># Create the stack plot</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>

        <span class="c1"># ax.stackplot(range(max_length), *values, labels=labels)</span>

        <span class="c1"># Customize the plot</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Stacked Plot&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;X-axis&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Values&#39;</span><span class="p">)</span>

        <span class="c1"># Show the plot</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="ChromatogramAnalysis.resample_chromatograms">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.ChromatogramAnalysis.resample_chromatograms">[docs]</a>
    <span class="k">def</span> <span class="nf">resample_chromatograms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chrom1</span><span class="p">,</span> <span class="n">chrom2</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resamples two chromatograms to the same length using interpolation.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        chrom1 (dict or np.ndarray): The first chromatogram dictionary or array to be resampled.</span>
<span class="sd">        chrom2 (dict or np.ndarray): The second chromatogram dictionary or array to be resampled.</span>

<span class="sd">        Returns:</span>
<span class="sd">        tuple: The resampled chromatograms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chrom1</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chrom2</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="c1"># Use the minimum number of chromatogram values in any sample</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">length</span><span class="p">:</span>
                <span class="n">length</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">chrom1</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">chrom2</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
            <span class="n">resampled_chrom1</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">resample_chromatogram</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="n">start</span><span class="p">:],</span> <span class="n">length</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">chrom1</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="n">resampled_chrom2</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">resample_chromatogram</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="n">start</span><span class="p">:],</span> <span class="n">length</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">chrom2</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chrom1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">chrom2</span><span class="p">))</span>  <span class="c1"># Use the minimum length if chrom1 and chrom2 are arrays</span>
            <span class="n">resampled_chrom1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resample_chromatogram</span><span class="p">(</span><span class="n">chrom1</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>
            <span class="n">resampled_chrom2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resample_chromatogram</span><span class="p">(</span><span class="n">chrom2</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">resampled_chrom1</span><span class="p">,</span> <span class="n">resampled_chrom2</span></div>
</div>


<div class="viewcode-block" id="SyncChromatograms">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.SyncChromatograms">[docs]</a>
<span class="k">class</span> <span class="nc">SyncChromatograms</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SyncChromatograms Class</span>
<span class="sd">        =======================</span>

<span class="sd">        The `SyncChromatograms` class provides methods for synchronizing chromatographic data, focusing on aligning peaks and adjusting retention times across different chromatograms. This is essential for comparing chromatographic profiles from different wine samples.</span>

<span class="sd">        Key Features:</span>
<span class="sd">        -------------</span>
<span class="sd">        - **Peak Alignment**: Automatically detects and aligns peaks across chromatograms.</span>
<span class="sd">        - **Retention Time Adjustment**: Corrects differences in retention times to synchronize chromatograms.</span>
<span class="sd">        - **Segmented Analysis**: Allows for synchronization across multiple segments for greater accuracy.</span>

<span class="sd">        Usage:</span>
<span class="sd">        ------</span>
<span class="sd">        This class is ideal for researchers who need to compare chromatographic data across multiple wine samples, ensuring that peaks and retention times are aligned for accurate analysis.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">n_segments</span><span class="p">,</span> <span class="n">scales</span><span class="p">,</span> <span class="n">min_peaks</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">max_iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">max_sep_threshold</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">peak_prominence</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c1</span> <span class="o">=</span> <span class="n">c1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c2</span> <span class="o">=</span> <span class="n">c2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_segments</span> <span class="o">=</span> <span class="n">n_segments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scales</span> <span class="o">=</span> <span class="n">scales</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_peaks</span> <span class="o">=</span> <span class="n">min_peaks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span> <span class="o">=</span> <span class="n">max_iterations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_sep_threshold</span> <span class="o">=</span> <span class="n">max_sep_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peak_prominence</span> <span class="o">=</span> <span class="n">peak_prominence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lag_res</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="SyncChromatograms.scale_chromatogram">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.SyncChromatograms.scale_chromatogram">[docs]</a>
    <span class="k">def</span> <span class="nf">scale_chromatogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chrom</span><span class="p">))</span>
        <span class="n">scaled_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chrom</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale</span><span class="p">)</span>
        <span class="n">scaled_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">chrom</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">scaled_length</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s2">&quot;extrapolate&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">scaled_x</span><span class="p">)</span></div>


<div class="viewcode-block" id="SyncChromatograms.correct_segment">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.SyncChromatograms.correct_segment">[docs]</a>
    <span class="k">def</span> <span class="nf">correct_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segment</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">lag</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">lag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">segment</span>

        <span class="n">scaled_segment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_chromatogram</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lag</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">corrected_segment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">scaled_segment</span><span class="p">,</span> <span class="n">lag</span><span class="p">)</span>
            <span class="n">corrected_segment</span><span class="p">[:</span><span class="n">lag</span><span class="p">]</span> <span class="o">=</span> <span class="n">scaled_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">lag</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">corrected_segment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">scaled_segment</span><span class="p">,</span> <span class="n">lag</span><span class="p">)</span>
            <span class="n">corrected_segment</span><span class="p">[</span><span class="n">lag</span><span class="p">:]</span> <span class="o">=</span> <span class="n">scaled_segment</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">corrected_segment</span> <span class="o">=</span> <span class="n">scaled_segment</span>

        <span class="k">return</span> <span class="n">corrected_segment</span></div>


<div class="viewcode-block" id="SyncChromatograms.find_best_scale_and_lag_corr">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.SyncChromatograms.find_best_scale_and_lag_corr">[docs]</a>
    <span class="k">def</span> <span class="nf">find_best_scale_and_lag_corr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chrom1</span><span class="p">,</span> <span class="n">chrom2</span><span class="p">,</span> <span class="n">scales</span><span class="p">,</span> <span class="n">max_lag</span><span class="o">=</span><span class="mi">300</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the best scale and lag for cross-correlation between two chromatograms.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        chrom1 (np.array): The first chromatogram.</span>
<span class="sd">        chrom2 (np.array): The second chromatogram.</span>
<span class="sd">        scales (list of float): The list of scaling factors to try.</span>
<span class="sd">        max_lag (int): The maximum lag to consider for cross-correlation.</span>

<span class="sd">        Returns:</span>
<span class="sd">        float: The best scaling factor.</span>
<span class="sd">        int: The best lag.</span>
<span class="sd">        float: The highest cross-correlation value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">best_scale</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">best_lag</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">best_corr</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>

        <span class="k">for</span> <span class="n">scale</span> <span class="ow">in</span> <span class="n">scales</span><span class="p">:</span>

            <span class="c1"># Scale the first chromatogram</span>
            <span class="n">scaled_chrom2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_chromatogram</span><span class="p">(</span><span class="n">chrom2</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>

            <span class="c1"># Compute the cross-correlation</span>
            <span class="n">corr</span> <span class="o">=</span> <span class="n">correlate</span><span class="p">(</span><span class="n">chrom1</span><span class="p">,</span> <span class="n">scaled_chrom2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
            <span class="n">center</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">corr</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">corr</span> <span class="o">=</span> <span class="n">corr</span><span class="p">[</span><span class="n">center</span> <span class="o">-</span> <span class="n">max_lag</span><span class="p">:</span><span class="n">center</span> <span class="o">+</span> <span class="n">max_lag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="c1"># lags = np.arange(-len(chrom1) + 1, len(scaled_chrom2))</span>
            <span class="n">lags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">max_lag</span><span class="p">,</span> <span class="n">max_lag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Find the lag with the highest correlation within the specified range</span>
            <span class="n">max_lag_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">corr</span><span class="p">)</span>
            <span class="n">lag</span> <span class="o">=</span> <span class="n">lags</span><span class="p">[</span><span class="n">max_lag_idx</span><span class="p">]</span>
            <span class="n">corr_value</span> <span class="o">=</span> <span class="n">corr</span><span class="p">[</span><span class="n">max_lag_idx</span><span class="p">]</span>

            <span class="c1"># Update the best scale and lag if the correlation is higher</span>
            <span class="k">if</span> <span class="n">corr_value</span> <span class="o">&gt;</span> <span class="n">best_corr</span><span class="p">:</span>
                <span class="n">best_corr</span> <span class="o">=</span> <span class="n">corr_value</span>
                <span class="n">best_scale</span> <span class="o">=</span> <span class="n">scale</span>
                <span class="n">best_lag</span> <span class="o">=</span> <span class="n">lag</span>

        <span class="k">return</span> <span class="n">best_scale</span><span class="p">,</span> <span class="n">best_lag</span><span class="p">,</span> <span class="n">best_corr</span></div>


<div class="viewcode-block" id="SyncChromatograms.calculate_lag_profile">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.SyncChromatograms.calculate_lag_profile">[docs]</a>
    <span class="k">def</span> <span class="nf">calculate_lag_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">segment_length</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">lag_range</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">distance_metric</span><span class="o">=</span><span class="s1">&#39;l2&#39;</span><span class="p">,</span>
                              <span class="n">init_min_dist</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the lag of a segment ahead for each datapoint in c2 against c1 using L1 or L2 distance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c1 : numpy.ndarray</span>
<span class="sd">            Reference signal.</span>
<span class="sd">        c2 : numpy.ndarray</span>
<span class="sd">            Signal to be compared.</span>
<span class="sd">        segment_length : int</span>
<span class="sd">            Length of the segment ahead.</span>
<span class="sd">        hop : int, optional</span>
<span class="sd">            Step size for sliding the window. Default is 1.</span>
<span class="sd">        sigma : float, optional</span>
<span class="sd">            Standard deviation for Gaussian filter. Default is 20.</span>
<span class="sd">        lag_range : int, optional</span>
<span class="sd">            The range of lags to test on both sides. Default is 10.</span>
<span class="sd">        distance_metric : str, optional</span>
<span class="sd">            The distance metric to use for lag calculation (&#39;L1&#39; or &#39;L2&#39;). Default is &#39;L2&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Lags for each datapoint in c2.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">initial_global_alignment</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Compute initial global alignment using cross-correlation.&quot;&quot;&quot;</span>
            <span class="n">corr</span> <span class="o">=</span> <span class="n">correlate</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span>
            <span class="n">lag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">corr</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">lag</span>

        <span class="c1"># Initial global alignment</span>
        <span class="n">initial_lag</span> <span class="o">=</span> <span class="n">initial_global_alignment</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">c2</span><span class="p">,</span> <span class="n">initial_lag</span><span class="p">)</span>  <span class="c1"># Apply the global shift</span>

        <span class="n">lags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lags_loc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span> <span class="o">-</span> <span class="n">segment_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">hop</span><span class="p">):</span>
            <span class="n">segment_c2</span> <span class="o">=</span> <span class="n">c2</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">segment_length</span><span class="p">]</span>
            <span class="n">start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c1</span><span class="p">),</span> <span class="n">i</span> <span class="o">+</span> <span class="n">segment_length</span><span class="p">)</span>
            <span class="n">segment_c1</span> <span class="o">=</span> <span class="n">c1</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>

            <span class="c1"># Normalize and apply Gaussian filter</span>
            <span class="n">segment_c1_filtered</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">normalize_amplitude_zscore</span><span class="p">(</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">segment_c1</span><span class="p">,</span> <span class="n">sigma</span><span class="p">))</span>
            <span class="n">segment_c2_filtered</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">normalize_amplitude_zscore</span><span class="p">(</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">segment_c2</span><span class="p">,</span> <span class="n">sigma</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">distance_metric</span> <span class="o">==</span> <span class="s1">&#39;corr&#39;</span><span class="p">:</span>
                <span class="c1"># Calculate cross-correlation between the segments</span>
                <span class="n">corr</span> <span class="o">=</span> <span class="n">correlate</span><span class="p">(</span><span class="n">segment_c1_filtered</span><span class="p">,</span> <span class="n">segment_c2_filtered</span><span class="p">)</span>
                <span class="n">best_lag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">corr</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">segment_c2_filtered</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">best_lag</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">lag_range</span><span class="p">:</span>
                    <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Initialize the minimum distance and best lag</span>
                <span class="n">min_distance</span> <span class="o">=</span> <span class="n">init_min_dist</span>
                <span class="n">best_lag</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># Calculate distance for each possible lag within the specified range</span>
                <span class="k">for</span> <span class="n">lag</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">lag_range</span><span class="p">,</span> <span class="n">lag_range</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">shifted_segment_c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">segment_c2_filtered</span><span class="p">,</span> <span class="n">lag</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">distance_metric</span> <span class="o">==</span> <span class="s1">&#39;l2&#39;</span><span class="p">:</span>
                        <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">segment_c1_filtered</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">shifted_segment_c2</span><span class="p">)]</span> <span class="o">-</span> <span class="n">shifted_segment_c2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">distance_metric</span> <span class="o">==</span> <span class="s1">&#39;l1&#39;</span><span class="p">:</span>
                        <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">segment_c1_filtered</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">shifted_segment_c2</span><span class="p">)]</span> <span class="o">-</span> <span class="n">shifted_segment_c2</span><span class="p">))</span>
                    <span class="k">elif</span> <span class="n">distance_metric</span> <span class="o">==</span> <span class="s1">&#39;mse&#39;</span><span class="p">:</span>
                        <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">segment_c1_filtered</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">shifted_segment_c2</span><span class="p">)]</span> <span class="o">-</span> <span class="n">shifted_segment_c2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid distance metric. Use &#39;l1&#39; or &#39;l2&#39; or &#39;mse&#39;.&quot;</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">min_distance</span><span class="p">:</span>
                        <span class="n">best_shifted</span> <span class="o">=</span> <span class="n">shifted_segment_c2</span>
                        <span class="n">min_distance</span> <span class="o">=</span> <span class="n">distance</span>
                        <span class="n">best_lag</span> <span class="o">=</span> <span class="n">lag</span>

            <span class="n">lags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">best_lag</span> <span class="o">+</span> <span class="n">initial_lag</span><span class="p">)</span>
            <span class="n">lags_loc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="c1"># print(min_distance)</span>

        <span class="c1"># # Add one last point equal to the last one at 30000</span>
        <span class="n">lags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lags</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">lags_loc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">30000</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lags_loc</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lags</span><span class="p">)</span></div>



<div class="viewcode-block" id="SyncChromatograms.lag_profile_from_peaks">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.SyncChromatograms.lag_profile_from_peaks">[docs]</a>
    <span class="k">def</span> <span class="nf">lag_profile_from_peaks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference_chromatogram</span><span class="p">,</span> <span class="n">target_chromatogram</span><span class="p">,</span> <span class="n">alignment_tolerance</span><span class="p">,</span> <span class="n">num_segments</span><span class="p">,</span>
                               <span class="n">apply_global_alignment</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a lag profile from peaks in two chromatograms by aligning segments.</span>

<span class="sd">        This function aligns peaks in `target_chromatogram` to peaks in `reference_chromatogram` and adjusts the chromatogram</span>
<span class="sd">        `target_chromatogram` accordingly. It then computes the lag profile based on the difference in peak positions between</span>
<span class="sd">        the two chromatograms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reference_chromatogram : array-like</span>
<span class="sd">            The reference chromatogram (e.g. the mean chromatogram of a given dataset).</span>
<span class="sd">        target_chromatogram : array-like</span>
<span class="sd">            The chromatogram to be aligned with `reference_chromatogram`.</span>
<span class="sd">        alignment_tolerance : float</span>
<span class="sd">            The maximum allowed distance between aligned peaks in `reference_chromatogram` and `target_chromatogram`. Peaks in</span>
<span class="sd">            `target_chromatogram` that are too far from the corresponding peak in `reference_chromatogram` will be skipped.</span>
<span class="sd">        num_segments : int</span>
<span class="sd">            The number of segments to divide the chromatograms into for peak alignment. The highest peak from each segment</span>
<span class="sd">            is typically selected.</span>
<span class="sd">        apply_global_alignment : bool, optional</span>
<span class="sd">            If True, apply a global time shift to align the chromatograms before local adjustments. Default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lags_loc : numpy.ndarray</span>
<span class="sd">            The locations of the lags in `target_chromatogram` after alignment.</span>
<span class="sd">        lags : numpy.ndarray</span>
<span class="sd">            The lag values corresponding to each peak after alignment.</span>
<span class="sd">        target_chromatogram_aligned : numpy.ndarray</span>
<span class="sd">            The aligned chromatogram `target_chromatogram` after applying the per-section adjustments.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If some segments in `target_chromatogram` do not have peaks.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method uses a combination of global and local alignment to synchronize the chromatograms. The global alignment</span>
<span class="sd">        is applied first (if `apply_global_alignment` is True), followed by local adjustments in each segment.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; lags_loc, lags, target_chromatogram_aligned = obj.lag_profile_from_peaks(reference_chromatogram, target_chromatogram, alignment_tolerance=50, num_segments=50)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">apply_global_alignment</span><span class="p">:</span>
            <span class="c1"># Apply global alignment by finding the best scale (currently turned off) and lag</span>
            <span class="n">best_scale</span><span class="p">,</span> <span class="n">best_lag</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_best_scale_and_lag_corr</span><span class="p">(</span>
                <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">reference_chromatogram</span><span class="p">[:</span><span class="mi">10000</span><span class="p">],</span> <span class="mi">50</span><span class="p">),</span>
                <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">target_chromatogram</span><span class="p">[:</span><span class="mi">10000</span><span class="p">],</span> <span class="mi">50</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">target_chromatogram_aligned</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">correct_segment</span><span class="p">(</span><span class="n">target_chromatogram</span><span class="p">,</span> <span class="n">best_scale</span><span class="p">,</span> <span class="n">best_lag</span><span class="p">),</span> <span class="mi">5</span>
            <span class="p">)</span>
            <span class="n">accum_lag</span> <span class="o">=</span> <span class="n">best_lag</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">target_chromatogram_aligned</span> <span class="o">=</span> <span class="n">target_chromatogram</span>
            <span class="n">accum_lag</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Find peaks in the reference chromatogram</span>
        <span class="n">reference_peaks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">reference_chromatogram</span><span class="p">)</span>

        <span class="c1"># Remove peak at a known standard position in the reference chromatogram</span>
        <span class="n">reference_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">reference_peaks</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">reference_peaks</span> <span class="o">==</span> <span class="mi">8918</span><span class="p">))</span>

        <span class="c1"># Find peaks in the aligned target chromatogram</span>
        <span class="n">target_peaks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">target_chromatogram_aligned</span><span class="p">)</span>

        <span class="c1"># Ensure there is a maximum of one peak per segment (the highest) in both chromatograms</span>
        <span class="n">reference_peaks</span><span class="p">,</span> <span class="n">valid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensure_peaks_in_segments</span><span class="p">(</span>
            <span class="n">reference_chromatogram</span><span class="p">,</span> <span class="n">reference_peaks</span><span class="p">,</span> <span class="n">num_segments</span><span class="o">=</span><span class="n">num_segments</span>
        <span class="p">)</span>
        <span class="n">target_peaks</span><span class="p">,</span> <span class="n">valid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensure_peaks_in_segments</span><span class="p">(</span>
            <span class="n">target_chromatogram_aligned</span><span class="p">,</span> <span class="n">target_peaks</span><span class="p">,</span> <span class="n">num_segments</span><span class="o">=</span><span class="n">num_segments</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please change parameters, some segments in chromatograms do not have peaks.&quot;</span><span class="p">)</span>

        <span class="c1"># Add zero to scale the first part of the chromatogram up to the first peak</span>
        <span class="n">reference_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="n">reference_peaks</span><span class="p">])</span>
        <span class="n">target_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="n">target_peaks</span><span class="p">])</span>
        <span class="n">num_initial_peaks</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">target_peaks</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">reference_peaks</span><span class="p">))</span>

        <span class="n">lags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lags_loc</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_initial_peaks</span><span class="p">):</span>
            <span class="c1"># Select the previous and current peaks from the target chromatogram</span>
            <span class="n">target_peak_prev</span> <span class="o">=</span> <span class="n">target_peaks</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">target_peak</span> <span class="o">=</span> <span class="n">target_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># Initialize the corresponding previous peak in the reference chromatogram</span>
            <span class="n">reference_peak_prev</span> <span class="o">=</span> <span class="n">target_peak_prev</span>

            <span class="c1"># Find the closest peak in the reference chromatogram to the current target peak</span>
            <span class="n">reference_peak</span> <span class="o">=</span> <span class="n">reference_peaks</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">reference_peaks</span> <span class="o">-</span> <span class="n">target_peak</span><span class="p">))]</span>

            <span class="c1"># Skip if the current peak in target is too far from the reference or in the wrong order</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">reference_peak</span> <span class="o">-</span> <span class="n">target_peak</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">alignment_tolerance</span> <span class="ow">or</span> <span class="n">reference_peak</span> <span class="o">&lt;=</span> <span class="n">reference_peak_prev</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_peaks</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">continue</span>

            <span class="c1"># Accumulate the lag</span>
            <span class="n">accum_lag</span> <span class="o">+=</span> <span class="n">reference_peak</span> <span class="o">-</span> <span class="n">target_peak</span>

            <span class="c1"># Calculate the scaling factor and adjust the target segment</span>
            <span class="n">interval_target</span> <span class="o">=</span> <span class="n">target_peak</span> <span class="o">-</span> <span class="n">target_peak_prev</span>
            <span class="n">interval_reference</span> <span class="o">=</span> <span class="n">reference_peak</span> <span class="o">-</span> <span class="n">reference_peak_prev</span>
            <span class="k">if</span> <span class="n">interval_target</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">interval_reference</span> <span class="o">/</span> <span class="n">interval_target</span>
            <span class="n">start</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">target_peak_prev</span><span class="p">,</span> <span class="n">target_peak</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">target_peak_prev</span><span class="p">,</span> <span class="n">target_peak</span><span class="p">)</span>
            <span class="n">target_segment</span> <span class="o">=</span> <span class="n">target_chromatogram_aligned</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
            <span class="n">scaled_segment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_chromatogram</span><span class="p">(</span><span class="n">target_segment</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>

            <span class="c1"># Update the aligned target chromatogram with the scaled segment</span>
            <span class="n">target_chromatogram_aligned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span>
                <span class="n">target_chromatogram_aligned</span><span class="p">[:</span><span class="n">start</span><span class="p">],</span> <span class="n">scaled_segment</span><span class="p">,</span> <span class="n">target_chromatogram_aligned</span><span class="p">[</span><span class="n">end</span><span class="p">:]</span>
            <span class="p">])</span>

            <span class="c1"># Recalculate peaks in the updated target chromatogram</span>
            <span class="n">target_peaks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">target_chromatogram_aligned</span><span class="p">)</span>
            <span class="n">target_peaks</span><span class="p">,</span> <span class="n">valid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensure_peaks_in_segments</span><span class="p">(</span>
                <span class="n">target_chromatogram_aligned</span><span class="p">,</span> <span class="n">target_peaks</span><span class="p">,</span> <span class="n">num_segments</span><span class="o">=</span><span class="n">num_segments</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please change parameters, some segments do not have peaks.&quot;</span><span class="p">)</span>
            <span class="n">target_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="n">target_peaks</span><span class="p">])</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_peaks</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_initial_peaks</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_peaks</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="c1"># Skip peaks that would move backwards in retention time</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lags_loc</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">target_peak</span> <span class="o">+</span> <span class="n">accum_lag</span> <span class="o">&lt;=</span> <span class="n">loc</span> <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">lags_loc</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># Append the accumulated lag and its location</span>
            <span class="n">lags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">accum_lag</span><span class="p">)</span>
            <span class="n">lags_loc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target_peak</span> <span class="o">+</span> <span class="n">accum_lag</span><span class="p">)</span>

        <span class="c1"># Ensure the first lag is consistent with the rest</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lags</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lags</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">lags</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">lags_loc</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lags_loc</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lags</span><span class="p">),</span> <span class="n">target_chromatogram_aligned</span></div>


<div class="viewcode-block" id="SyncChromatograms.lag_profile_moving_peaks_individually">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.SyncChromatograms.lag_profile_moving_peaks_individually">[docs]</a>
    <span class="k">def</span> <span class="nf">lag_profile_moving_peaks_individually</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">reference_chromatogram</span><span class="p">,</span> <span class="n">target_chromatogram</span><span class="p">,</span> <span class="n">alignment_tolerance</span><span class="p">,</span> <span class="n">num_segments</span><span class="p">,</span> <span class="n">apply_global_alignment</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">scan_range</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">peak_order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scaling_distance</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">interval_after</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">min_avg_peak_distance</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Align peaks between a reference signal and a target signal by moving target peaks independently,</span>
<span class="sd">        and calculate the lag profile. The peaks are moved by rescaling the intervals to le left and right of each peak</span>
<span class="sd">        with their adjacent peaks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reference_chromatogram : array-like</span>
<span class="sd">            The reference chromatogram used for peak alignment.</span>
<span class="sd">        target_chromatogram : array-like</span>
<span class="sd">            The target chromatogram to be aligned with the reference signal.</span>
<span class="sd">        alignment_tolerance : float</span>
<span class="sd">            The maximum allowed distance between aligned peaks.</span>
<span class="sd">        num_segments : int</span>
<span class="sd">            Number of segments to divide the signal into.</span>
<span class="sd">        apply_global_alignment : bool, optional</span>
<span class="sd">            If True, apply a global time shift before peak alignment. Default is True.</span>
<span class="sd">        scan_range : int, optional</span>
<span class="sd">            The range within which to scan for matching peaks. Default is 1.</span>
<span class="sd">        peak_order : int, optional</span>
<span class="sd">            The rank of the peak to select within each segment. Default is 0 (highest peak).</span>
<span class="sd">        scaling_distance : int, optional</span>
<span class="sd">            Distance used to calculate the scaling factor. Default is 100.</span>
<span class="sd">        interval_after : int, optional</span>
<span class="sd">            Interval length after the peak for stretching/compression. Default is 500.</span>
<span class="sd">        min_avg_peak_distance : float, optional</span>
<span class="sd">            Minimum average peak distance required for accepting the scaling. Default is 50.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Locations of the lags in the target signal after alignment.</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The lag values corresponding to each peak after alignment.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#### Local functions ####</span>
        <span class="k">def</span> <span class="nf">calculate_average_peak_distance</span><span class="p">(</span><span class="n">signal1</span><span class="p">,</span> <span class="n">signal2</span><span class="p">,</span> <span class="n">prominence</span><span class="o">=</span><span class="mf">1E-6</span><span class="p">,</span> <span class="n">distance_type</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Calculate the average distance between peaks in two signals.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            signal1, signal2 : array-like</span>
<span class="sd">                The signals for which peak distances are calculated.</span>
<span class="sd">            prominence : float, optional</span>
<span class="sd">                The prominence of peaks to consider. Default is 1E-6.</span>
<span class="sd">            distance_type : str, optional</span>
<span class="sd">                Type of distance to calculate (&#39;mean&#39; or &#39;mean_square&#39;). Default is &#39;mean&#39;.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            float</span>
<span class="sd">                The average distance between peaks.</span>
<span class="sd">            list</span>
<span class="sd">                List of distances between matched peaks.</span>
<span class="sd">            numpy.ndarray</span>
<span class="sd">                Peaks in the first signal.</span>
<span class="sd">            numpy.ndarray</span>
<span class="sd">                Peaks in the second signal.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">peaks1</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">signal1</span><span class="p">,</span> <span class="n">prominence</span><span class="o">=</span><span class="n">prominence</span><span class="p">)</span>
            <span class="n">peaks2</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">signal2</span><span class="p">,</span> <span class="n">prominence</span><span class="o">=</span><span class="n">prominence</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No peaks found in one of the signals&quot;</span><span class="p">)</span>

            <span class="n">distances</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">peak1</span> <span class="ow">in</span> <span class="n">peaks1</span><span class="p">:</span>
                <span class="n">closest_peak2</span> <span class="o">=</span> <span class="n">peaks2</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">peaks2</span> <span class="o">-</span> <span class="n">peak1</span><span class="p">))]</span>
                <span class="n">distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">peak1</span> <span class="o">-</span> <span class="n">closest_peak2</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">distance_type</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
                <span class="n">average_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">distance_type</span> <span class="o">==</span> <span class="s1">&#39;mean_square&#39;</span><span class="p">:</span>
                <span class="n">average_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">distances</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid distance_type. Choose &#39;mean&#39; or &#39;mean_square&#39;.&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">average_distance</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">peaks1</span><span class="p">,</span> <span class="n">peaks2</span>

        <span class="c1">#### End local functions ####</span>

        <span class="c1"># TODO: Adjust the sharp chromatogram too and do classification on it</span>
        <span class="k">if</span> <span class="n">apply_global_alignment</span><span class="p">:</span>
            <span class="c1"># Apply a global time shift using the best scale and lag</span>
            <span class="n">best_scale</span><span class="p">,</span> <span class="n">best_lag</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_best_scale_and_lag_corr</span><span class="p">(</span>
                <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">reference_chromatogram</span><span class="p">[:</span><span class="mi">10000</span><span class="p">],</span> <span class="mi">50</span><span class="p">),</span>
                <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">target_chromatogram</span><span class="p">[:</span><span class="mi">10000</span><span class="p">],</span> <span class="mi">50</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">target_chromatogram_aligned</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">correct_segment</span><span class="p">(</span><span class="n">target_chromatogram</span><span class="p">,</span> <span class="n">best_scale</span><span class="p">,</span> <span class="n">best_lag</span><span class="p">)</span>
            <span class="n">accumulated_lag</span> <span class="o">=</span> <span class="n">best_lag</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">target_chromatogram_aligned</span> <span class="o">=</span> <span class="n">target_chromatogram</span>
            <span class="n">accumulated_lag</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">reference_peaks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">reference_chromatogram</span><span class="p">)</span>
        <span class="n">all_target_peaks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">target_chromatogram_aligned</span><span class="p">)</span>

        <span class="c1"># Ensure peaks are within segments in the target signal</span>
        <span class="n">target_peaks</span><span class="p">,</span> <span class="n">valid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensure_peaks_in_segments</span><span class="p">(</span>
            <span class="n">target_chromatogram_aligned</span><span class="p">,</span> <span class="n">all_target_peaks</span><span class="p">,</span> <span class="n">num_segments</span><span class="o">=</span><span class="n">num_segments</span><span class="p">,</span> <span class="n">peak_ord</span><span class="o">=</span><span class="n">peak_order</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please change parameters, peaks found in target.&quot;</span><span class="p">)</span>

        <span class="c1"># Add zero to scale the first part of the chromatogram</span>
        <span class="n">reference_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="n">reference_peaks</span><span class="p">])</span>
        <span class="n">target_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="n">target_peaks</span><span class="p">])</span>

        <span class="c1"># Initialize lists to store the calculated lags and their corresponding locations</span>
        <span class="n">lags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lags_loc</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">num_initial_peaks</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">target_peaks</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">reference_peaks</span><span class="p">))</span>

        <span class="c1"># Loop over each peak, starting from the second peak (index 1) to the last peak</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_initial_peaks</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Find the previous peak in the target signal (this is to scale interval on the left of target)</span>
                <span class="n">target_peak_prev</span> <span class="o">=</span> <span class="n">all_target_peaks</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">all_target_peaks</span> <span class="o">==</span> <span class="n">target_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error finding previous peak in target signal.&#39;</span><span class="p">)</span>
                <span class="k">continue</span>  <span class="c1"># If the previous peak cannot be found, skip this iteration</span>

            <span class="c1"># Get the current target peak</span>
            <span class="n">target_peak</span> <span class="o">=</span> <span class="n">target_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">reference_peak_prev</span> <span class="o">=</span> <span class="n">target_peak_prev</span>  <span class="c1"># INitialize the previous reference peak to the previous target peak</span>

            <span class="c1"># Find the closest peak in the reference signal to the current target peak</span>
            <span class="n">closest_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">reference_peaks</span> <span class="o">-</span> <span class="n">target_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">start_index</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">closest_index</span> <span class="o">-</span> <span class="n">scan_range</span><span class="p">)</span>  <span class="c1"># Start of scanning from a range around the closest peak</span>
            <span class="n">end_index</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reference_peaks</span><span class="p">),</span> <span class="n">closest_index</span> <span class="o">+</span> <span class="n">scan_range</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># End of scanning</span>

            <span class="c1"># Initialize minimum distance to the parameter-passed minimum average peak distance</span>
            <span class="n">min_distance</span> <span class="o">=</span> <span class="n">min_avg_peak_distance</span>

            <span class="c1"># Define the start and end retention times of the segment in the target signal that will be adjusted</span>
            <span class="n">start</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">target_peak_prev</span><span class="p">,</span> <span class="n">target_peak</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">target_peak_prev</span><span class="p">,</span> <span class="n">target_peak</span><span class="p">)</span>

            <span class="c1"># Explore the surroundings of the reference peak within the specified range</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_index</span><span class="p">,</span> <span class="n">end_index</span><span class="p">):</span>
                <span class="n">reference_peak</span> <span class="o">=</span> <span class="n">reference_peaks</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>  <span class="c1"># Get the current reference peak within the scan range</span>

                <span class="c1"># Check if the current peaks fall within the valid range of the chromatogram</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">reference_peak</span> <span class="o">+</span> <span class="n">interval_after</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">reference_chromatogram</span><span class="p">))</span> <span class="ow">or</span>
                        <span class="p">(</span><span class="n">target_peak</span> <span class="o">+</span> <span class="n">interval_after</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_chromatogram_aligned</span><span class="p">))):</span>
                    <span class="k">continue</span>

                <span class="c1"># Calculate the intervals between the current and previous peaks for both signals</span>
                <span class="n">interval_target</span> <span class="o">=</span> <span class="n">target_peak</span> <span class="o">-</span> <span class="n">target_peak_prev</span>
                <span class="n">interval_reference</span> <span class="o">=</span> <span class="n">reference_peak</span> <span class="o">-</span> <span class="n">reference_peak_prev</span>

                <span class="c1"># Ensure the intervals are valid and within the allowed alignment tolerance</span>
                <span class="k">if</span> <span class="p">(</span>
                        <span class="nb">abs</span><span class="p">(</span><span class="n">reference_peak</span> <span class="o">-</span> <span class="n">target_peak</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">alignment_tolerance</span> <span class="ow">or</span>
                        <span class="n">interval_target</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span>
                        <span class="n">interval_reference</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span>
                        <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span>
                <span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># Calculate the scaling factor based on the ratio of intervals</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="n">interval_reference</span> <span class="o">/</span> <span class="n">interval_target</span>

                <span class="c1"># Extract the segment from the target signal and apply the scaling</span>
                <span class="n">target_segment</span> <span class="o">=</span> <span class="n">target_chromatogram_aligned</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
                <span class="n">scaled_segment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_chromatogram</span><span class="p">(</span><span class="n">target_segment</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scaled_segment</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>  <span class="c1"># Skip if the scaled segment is empty</span>

                <span class="c1"># Normalize the segments of both reference and target signals for comparison</span>
                <span class="n">norm_reference_segment</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">normalize_amplitude_minmax</span><span class="p">(</span>
                    <span class="n">reference_chromatogram</span><span class="p">[</span><span class="n">reference_peak_prev</span><span class="p">:</span><span class="n">reference_peak</span> <span class="o">+</span> <span class="n">interval_after</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">norm_target_segment</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">normalize_amplitude_minmax</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">scaled_segment</span><span class="p">,</span> <span class="n">target_chromatogram</span><span class="p">[</span><span class="n">end</span><span class="p">:</span><span class="n">end</span> <span class="o">+</span> <span class="n">interval_after</span><span class="p">]])</span>
                <span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Calculate the average peak distance between the normalized segments of target and referece</span>
                    <span class="n">avg_peak_dist</span> <span class="o">=</span> <span class="n">calculate_average_peak_distance</span><span class="p">(</span>
                        <span class="n">norm_reference_segment</span><span class="p">,</span> <span class="n">norm_target_segment</span><span class="p">,</span> <span class="n">prominence</span><span class="o">=</span><span class="mf">1E-6</span><span class="p">,</span> <span class="n">distance_type</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span>
                    <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error calculating average peak distance.&#39;</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="c1"># If the calculated average peak distance is less than the current minimum, update the best segment</span>
                <span class="k">if</span> <span class="n">avg_peak_dist</span> <span class="o">&lt;</span> <span class="n">min_distance</span><span class="p">:</span>
                    <span class="n">min_distance</span> <span class="o">=</span> <span class="n">avg_peak_dist</span>
                    <span class="n">best_scaled_segment</span> <span class="o">=</span> <span class="n">scaled_segment</span>
                    <span class="n">best_end</span> <span class="o">=</span> <span class="n">end</span>
                    <span class="n">best_reference_peak</span> <span class="o">=</span> <span class="n">reference_peak</span>

            <span class="c1"># Ensure a best segment was found; otherwise, default to the original segment</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">best_scaled_segment</span>
            <span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
                <span class="n">best_end</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">target_peak_prev</span><span class="p">,</span> <span class="n">target_peak</span><span class="p">)</span>
                <span class="n">best_reference_peak</span> <span class="o">=</span> <span class="n">reference_peak</span>
                <span class="n">best_scaled_segment</span> <span class="o">=</span> <span class="n">target_chromatogram_aligned</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>

            <span class="c1"># Check if the best reference peak is within the allowable alignment tolerance</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                    <span class="n">best_reference_peak</span> <span class="o">-</span> <span class="n">target_peak</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">alignment_tolerance</span> <span class="ow">or</span> <span class="n">best_reference_peak</span> <span class="o">&lt;=</span> <span class="n">reference_peak_prev</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_peaks</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">break</span>  <span class="c1"># If the last peak is reached and conditions are not met, break the loop</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">continue</span>  <span class="c1"># Skip to the next peak</span>

            <span class="c1"># Calculate the stretch required to align the peaks</span>
            <span class="n">stretch</span> <span class="o">=</span> <span class="n">best_reference_peak</span> <span class="o">-</span> <span class="n">target_peak</span>

            <span class="c1"># Identify the next peak in the target signal (this is to scale interval on the right of target)</span>
            <span class="n">next_peak</span> <span class="o">=</span> <span class="n">all_target_peaks</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">all_target_peaks</span> <span class="o">==</span> <span class="n">target_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># If there is another peak after and sufficient space after the peak to apply the stretch</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_peaks</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_chromatogram_aligned</span><span class="p">[</span><span class="n">best_end</span><span class="p">:</span><span class="n">next_peak</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">stretch</span><span class="p">):</span>
                <span class="n">next_segment</span> <span class="o">=</span> <span class="n">target_chromatogram_aligned</span><span class="p">[</span><span class="n">best_end</span><span class="p">:</span><span class="n">next_peak</span><span class="p">]</span>  <span class="c1"># Extract the section to be scaled</span>
                <span class="n">compensate_factor</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">next_segment</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">next_segment</span><span class="p">)</span> <span class="o">+</span> <span class="n">stretch</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Scale the section using the compensating factor</span>
                    <span class="n">next_segment_corrected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_chromatogram</span><span class="p">(</span><span class="n">next_segment</span><span class="p">,</span> <span class="n">compensate_factor</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error scaling next segment.&#39;</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="c1"># Update the aligned target signal with the corrected segment</span>
                <span class="n">temp_target_chromatogram_aligned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">target_chromatogram_aligned</span><span class="p">[:</span><span class="n">start</span><span class="p">],</span>
                        <span class="n">best_scaled_segment</span><span class="p">,</span>
                        <span class="n">next_segment_corrected</span><span class="p">,</span>
                        <span class="n">target_chromatogram_aligned</span><span class="p">[</span><span class="n">next_peak</span><span class="p">:]</span>
                     <span class="p">]</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If compensation is not needed or possible, just update the aligned target signal with the best segment</span>
                <span class="n">temp_target_chromatogram_aligned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">target_chromatogram_aligned</span><span class="p">[:</span><span class="n">start</span><span class="p">],</span> <span class="n">best_scaled_segment</span><span class="p">,</span> <span class="n">target_chromatogram_aligned</span><span class="p">[</span><span class="n">best_end</span><span class="p">:]]</span>
                <span class="p">)</span>

            <span class="c1"># Update peaks after realignment and ensure they remain in their respective segments</span>
            <span class="n">temp_target_peaks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">temp_target_chromatogram_aligned</span><span class="p">)</span>
            <span class="n">all_target_peaks</span> <span class="o">=</span> <span class="n">temp_target_peaks</span>
            <span class="n">target_peaks</span><span class="p">,</span> <span class="n">valid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensure_peaks_in_segments</span><span class="p">(</span>
                <span class="n">temp_target_chromatogram_aligned</span><span class="p">,</span> <span class="n">temp_target_peaks</span><span class="p">,</span> <span class="n">num_segments</span><span class="o">=</span><span class="n">num_segments</span><span class="p">,</span> <span class="n">peak_ord</span><span class="o">=</span><span class="n">peak_order</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please change parameters, no peaks found.&quot;</span><span class="p">)</span>

            <span class="n">target_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="n">target_peaks</span><span class="p">])</span>

            <span class="c1"># If not enough peaks are left after alignment, break the loop</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_peaks</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_initial_peaks</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_peaks</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="c1"># Update the aligned target signal</span>
            <span class="n">target_chromatogram_aligned</span> <span class="o">=</span> <span class="n">temp_target_chromatogram_aligned</span>

            <span class="c1"># Avoid the adjusted peak position (target_peak + stretch) ending up at or before any of the existing lag</span>
            <span class="c1"># locations</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lags_loc</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">target_peak</span> <span class="o">+</span> <span class="n">stretch</span> <span class="o">&lt;=</span> <span class="n">loc</span> <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">lags_loc</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># Append the calculated stretch and its location to the lags list</span>
            <span class="n">lags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stretch</span><span class="p">)</span>
            <span class="n">lags_loc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target_peak</span> <span class="o">+</span> <span class="n">stretch</span><span class="p">)</span>

        <span class="c1"># Add one last point equal to the last one at a specific position (e.g., 30000) to avoid spline growing too large</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lags</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lags</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">lags_loc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">30000</span><span class="p">)</span>

        <span class="c1"># Return the arrays of lag locations and lag values</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lags_loc</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lags</span><span class="p">)</span></div>


<div class="viewcode-block" id="SyncChromatograms.ensure_peaks_in_segments">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.SyncChromatograms.ensure_peaks_in_segments">[docs]</a>
    <span class="k">def</span> <span class="nf">ensure_peaks_in_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span> <span class="n">peaks_in_signal</span><span class="p">,</span> <span class="n">num_segments</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">last_segment</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">peak_ord</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ensure that each segment of the signal has at least one peak by selecting the most prominent peaks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        signal : array-like</span>
<span class="sd">            The signal data from which peaks have been identified.</span>
<span class="sd">        peaks_in_signal : array-like</span>
<span class="sd">            Indices of the peaks identified in the signal.</span>
<span class="sd">        num_segments : int, optional</span>
<span class="sd">            The number of segments to divide the signal into. Default is 10.</span>
<span class="sd">        last_segment : int or None, optional</span>
<span class="sd">            The index of the last segment to process. If None, all segments are processed. Default is None.</span>
<span class="sd">        peak_ord : int, optional</span>
<span class="sd">            The ordinal rank of the peak to select in each segment when sorted by prominence. Default is 0 (highest peak).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The indices of the selected peaks across all segments.</span>
<span class="sd">        bool</span>
<span class="sd">            True if peaks were successfully found in all segments, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">segment_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span> <span class="o">//</span> <span class="n">num_segments</span>

        <span class="c1"># Initialize an empty list to store the selected peaks from each segment</span>
        <span class="n">new_peaks</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Iterate through each segment</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_segments</span><span class="p">):</span>
            <span class="c1"># Calculate the start and end indices for the current segment</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">segment_length</span>
            <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">segment_length</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_segments</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>

            <span class="c1"># Find peaks that fall within the current segment</span>
            <span class="n">segment_peaks</span> <span class="o">=</span> <span class="p">[</span><span class="n">peak</span> <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">peaks_in_signal</span> <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">peak</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">]</span>

            <span class="c1"># If no peaks are found in this segment, skip to the next segment</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">segment_peaks</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Sort the peaks in the segment based on their prominence (or signal value at the peak) in descending order</span>
            <span class="n">sorted_peaks</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">segment_peaks</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">signal</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Select the peak based on the specified ordinal rank (e.g., highest, second highest, etc.)</span>
                <span class="n">selected_peak</span> <span class="o">=</span> <span class="n">sorted_peaks</span><span class="p">[</span><span class="n">peak_ord</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>  <span class="c1"># Catch exception if peak_ord is out of range</span>
                <span class="k">continue</span>  <span class="c1"># If the peak_ord is invalid, skip to the next segment</span>

            <span class="c1"># Add the selected peak to the list of new peaks</span>
            <span class="n">new_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">selected_peak</span><span class="p">)</span>

            <span class="c1"># If a specific last segment is defined and reached, break out of the loop</span>
            <span class="k">if</span> <span class="n">last_segment</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">==</span> <span class="n">last_segment</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="c1"># If no peaks were added to the new_peaks list, return an empty array and False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">new_peaks</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_peaks</span><span class="p">),</span> <span class="kc">False</span>

        <span class="c1"># Return the array of selected peaks and True, indicating successful peak selection</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_peaks</span><span class="p">),</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="SyncChromatograms.adjust_chromatogram">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.SyncChromatograms.adjust_chromatogram">[docs]</a>
    <span class="k">def</span> <span class="nf">adjust_chromatogram</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adjusts the chromatogram to match a reference chromatogram.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The adjusted chromatogram after applying the synchronization algorithm.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#### Local functions ####</span>
        <span class="k">def</span> <span class="nf">apply_shift_spline</span><span class="p">(</span><span class="n">c2</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">spline</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Apply a spline-based retention time shift to a chromatogram signal.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            c2 : array-like</span>
<span class="sd">                The chromatogram to be adjusted.</span>
<span class="sd">            t : array-like</span>
<span class="sd">                The time indices in the chromatogram.</span>
<span class="sd">            spline : UnivariateSpline</span>
<span class="sd">                The spline function representing the time shift to be applied.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            numpy.ndarray</span>
<span class="sd">                The chromatogram after the shift has been applied.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">shifted_t</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="n">spline</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">interpolator</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s2">&quot;extrapolate&quot;</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">interpolator</span><span class="p">(</span><span class="n">shifted_t</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">objective_function_spline</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">spline</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;l2&#39;</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Objective function to minimize the difference between the reference and adjusted chromatograms.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            params : array-like</span>
<span class="sd">                Parameters to optimize, typically the smoothing factor for the spline.</span>
<span class="sd">            c1 : array-like</span>
<span class="sd">                The reference chromatogram.</span>
<span class="sd">            c2 : array-like</span>
<span class="sd">                The chromatogram to be adjusted.</span>
<span class="sd">            t : array-like</span>
<span class="sd">                The time points corresponding to the chromatograms.</span>
<span class="sd">            spline : UnivariateSpline</span>
<span class="sd">                The spline function representing the shift to be applied.</span>
<span class="sd">            loss : str, optional</span>
<span class="sd">                The loss function to be used in the optimization. Options are:</span>
<span class="sd">                - &#39;l1&#39;: Mean absolute error</span>
<span class="sd">                - &#39;l2&#39;: Mean squared error (default)</span>
<span class="sd">                - &#39;corr&#39;: Negative maximum cross-correlation</span>
<span class="sd">                - &#39;mse&#39;: Mean squared error</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            float</span>
<span class="sd">                The value of the loss function for the given parameters.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">spline</span><span class="o">.</span><span class="n">set_smoothing_factor</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error in spline.set_smoothing_factor(params[0])&#39;</span><span class="p">)</span>
            <span class="n">c2_shifted</span> <span class="o">=</span> <span class="n">apply_shift_spline</span><span class="p">(</span><span class="n">c2</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">spline</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">loss</span> <span class="o">==</span> <span class="s1">&#39;l1&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">c1</span> <span class="o">-</span> <span class="n">c2_shifted</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">loss</span> <span class="o">==</span> <span class="s1">&#39;l2&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">c2_shifted</span> <span class="o">-</span> <span class="n">c1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">loss</span> <span class="o">==</span> <span class="s1">&#39;corr&#39;</span><span class="p">:</span>
                <span class="n">cross_corr</span> <span class="o">=</span> <span class="n">correlate</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2_shifted</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cross_corr</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">loss</span> <span class="o">==</span> <span class="s1">&#39;mse&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">c2_shifted</span> <span class="o">-</span> <span class="n">c1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">correct_with_spline</span><span class="p">(</span><span class="n">corrected_c2</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Correct the chromatogram using a spline-based shift.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            corrected_c2 : array-like</span>
<span class="sd">                The chromatogram to be corrected.</span>
<span class="sd">            s : float</span>
<span class="sd">                Smoothing factor for the spline.</span>
<span class="sd">            k : int</span>
<span class="sd">                Degree of the spline.</span>
<span class="sd">            normalize : bool, optional</span>
<span class="sd">                Whether to normalize the chromatograms before correction. Default is True.</span>
<span class="sd">            plot : bool, optional</span>
<span class="sd">                Whether to plot the results. Default is False.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            numpy.ndarray</span>
<span class="sd">                The corrected chromatogram after applying the spline-based shift.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">min_len</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">corrected_c2</span><span class="p">))</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">min_max_normalize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[:</span><span class="n">min_len</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
                <span class="n">chrom</span> <span class="o">=</span> <span class="n">min_max_normalize</span><span class="p">(</span><span class="n">corrected_c2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[:</span><span class="n">min_len</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">chrom</span> <span class="o">=</span> <span class="n">corrected_c2</span><span class="p">[:</span><span class="n">min_len</span><span class="p">]</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">spline</span> <span class="o">=</span> <span class="n">UnivariateSpline</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lag_res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">lag_res</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error creating spline&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">chrom</span>

            <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="p">))</span>

            <span class="n">initial_guess</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span>
                <span class="n">objective_function_spline</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">spline</span><span class="p">,</span> <span class="s1">&#39;mse&#39;</span><span class="p">),</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span>
            <span class="p">)</span>

            <span class="n">optimized_smoothing_factor</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">spline</span><span class="o">.</span><span class="n">set_smoothing_factor</span><span class="p">(</span><span class="n">optimized_smoothing_factor</span><span class="p">)</span>
            <span class="n">corrected_c2</span> <span class="o">=</span> <span class="n">apply_shift_spline</span><span class="p">(</span><span class="n">chrom</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">spline</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plot_signal_and_fit</span><span class="p">(</span>
                    <span class="n">t</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">corrected_c2</span><span class="p">,</span> <span class="n">fit_type</span><span class="o">=</span><span class="s1">&#39;spline&#39;</span><span class="p">,</span> <span class="n">fit_params</span><span class="o">=</span><span class="n">spline</span><span class="p">,</span> <span class="n">data_points</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lag_res</span>
                <span class="p">)</span>

            <span class="k">return</span> <span class="n">corrected_c2</span>
        <span class="c1">##### End of local functions #####</span>


        <span class="n">corrected_c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c2</span>

        <span class="c1"># Start first adjustment based on scaling of retention times between main peaks</span>
        <span class="k">for</span> <span class="n">prox</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">40</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lag_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lag_profile_from_peaks</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c1</span><span class="p">,</span> <span class="n">corrected_c2</span><span class="p">,</span> <span class="n">alignment_tolerance</span><span class="o">=</span><span class="n">prox</span><span class="p">,</span> <span class="n">num_segments</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">apply_global_alignment</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="n">corrected_c2</span> <span class="o">=</span> <span class="n">correct_with_spline</span><span class="p">(</span><span class="n">corrected_c2</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Start second adjustment based on moving individual peaks to match the reference&#39;s</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># Apply Gaussian smoothing to the chromatograms (sigma value found experimentally)</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">corrected_c2</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">corrected_c2</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

        <span class="n">plot</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Iterate over the specified peak order sequence to refine the alignment. Iteratively doing it several times for</span>
        <span class="c1"># each order improves accuracy</span>
        <span class="k">for</span> <span class="nb">ord</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lag_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lag_profile_moving_peaks_individually</span><span class="p">(</span>
                <span class="n">c1</span><span class="p">,</span> <span class="n">corrected_c2</span><span class="p">,</span> <span class="n">alignment_tolerance</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">num_segments</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">apply_global_alignment</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">scan_range</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                <span class="n">peak_order</span><span class="o">=</span><span class="nb">ord</span><span class="p">,</span> <span class="n">scaling_distance</span><span class="o">=</span><span class="mi">250</span><span class="p">,</span> <span class="n">interval_after</span><span class="o">=</span><span class="mi">3000</span><span class="p">,</span> <span class="n">min_avg_peak_distance</span><span class="o">=</span><span class="mi">10</span>
            <span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lag_res</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># Apply spline-based correction to the chromatogram based on the current lag profile</span>
            <span class="n">corrected_c2</span> <span class="o">=</span> <span class="n">correct_with_spline</span><span class="p">(</span><span class="n">corrected_c2</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">)</span>

            <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">corrected_c2</span><span class="p">)</span></div>


    <span class="c1"># Function to plot the results</span>
<div class="viewcode-block" id="SyncChromatograms.plot_signal_and_fit">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.SyncChromatograms.plot_signal_and_fit">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_signal_and_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">corrected_c2</span><span class="p">,</span> <span class="n">fit_type</span><span class="o">=</span><span class="s1">&#39;spline&#39;</span><span class="p">,</span> <span class="n">fit_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data_points</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the original and corrected signals, as well as the fitting curve (spline, quadratic, or linear).</span>

<span class="sd">        Parameters:</span>
<span class="sd">        - t: Time axis or index.</span>
<span class="sd">        - ref: Reference signal.</span>
<span class="sd">        - chrom: Original signal before correction.</span>
<span class="sd">        - corrected_c2: Corrected signal after applying the shift.</span>
<span class="sd">        - fit_type: Type of fitting (&#39;spline&#39;, &#39;quadratic&#39;, or &#39;linear&#39;).</span>
<span class="sd">        - fit_params: Parameters for the fit. Could be the spline object, quadratic coefficients, or linear coefficients.</span>
<span class="sd">        - data_points: Data points related to the lag or shift used for plotting (optional).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>

        <span class="c1"># Plot the original and corrected signals</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Reference Signal c1&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Original Signal c2&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">corrected_c2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Shifted Signal c2&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Signals&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Retention time&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Intensity&#39;</span><span class="p">)</span>

        <span class="c1"># Plot the fitting curve along with the data points</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data_points</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">data_points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data_points</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Time shifts&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fit_type</span> <span class="o">==</span> <span class="s1">&#39;spline&#39;</span> <span class="ow">and</span> <span class="n">fit_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">spline</span> <span class="o">=</span> <span class="n">fit_params</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">spline</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Fitted Spline&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">fit_type</span> <span class="o">==</span> <span class="s1">&#39;quadratic&#39;</span> <span class="ow">and</span> <span class="n">fit_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">fit_params</span>
            <span class="n">quadratic_fit</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">data_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="n">data_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">data_points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">quadratic_fit</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Quadratic Fit&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;orange&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">fit_type</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span> <span class="ow">and</span> <span class="n">fit_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">fit_params</span>
            <span class="n">linear_shift</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="n">b</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">linear_shift</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Linear Fit&#39;</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">fit_type</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span><span class="si">}</span><span class="s1"> Fit&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Retention time&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Lag&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>
</div>






</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Wine Analysis</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../main.html">Main script</a></li>
<li class="toctree-l1"><a class="reference internal" href="../wine_analysis.html">Wine analysis module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">Utils module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dimensionality_reduction.html">Dimensionality reduction module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data_loader.html">Data loader module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../visualizer.html">Visualizer module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../classification.html">Classification module</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Luis G. Camara.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.4.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>