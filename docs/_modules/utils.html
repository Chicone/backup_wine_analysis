<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>utils &#8212; Wine Analysis Library 0.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=4f649999" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=cb25574f" />
    <script src="../_static/documentation_options.js?v=01f34227"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for utils</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">subprocess</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">gcmswine</span> <span class="kn">import</span> <span class="n">utils</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span><span class="p">,</span> <span class="n">MinMaxScaler</span><span class="p">,</span> <span class="n">RobustScaler</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">correlate</span><span class="p">,</span> <span class="n">find_peaks</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">gaussian_filter</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">gaussian_filter1d</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">pearsonr</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>


<div class="viewcode-block" id="collapse_lists">
<a class="viewcode-back" href="../utils.html#utils.collapse_lists">[docs]</a>
<span class="k">def</span> <span class="nf">collapse_lists</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Collapse nested lists into a single list for each dictionary entry.</span>

<span class="sd">    This function is useful when the values in the dictionary are lists of lists, and you want to flatten them into a</span>
<span class="sd">    single list.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d : dict</span>
<span class="sd">        The dictionary with list or list of lists as values.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        The dictionary with the lists collapsed into single lists.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If a value in the dictionary is not a list or a list of lists.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># Check if the value is a list of lists</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">sublist</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">value</span><span class="p">):</span>
            <span class="c1"># Flatten the list of lists into a single list</span>
            <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">value</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Value for key &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; is not a list or a list of lists.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">d</span></div>



<div class="viewcode-block" id="concatenate_dict_values">
<a class="viewcode-back" href="../utils.html#utils.concatenate_dict_values">[docs]</a>
<span class="k">def</span> <span class="nf">concatenate_dict_values</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Concatenate the values of two dictionaries.</span>

<span class="sd">    If a key exists in both dictionaries, their values are concatenated. If a key exists in only one dictionary, its</span>
<span class="sd">    value is included as is.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d1 : dict</span>
<span class="sd">        The first dictionary.</span>
<span class="sd">    d2 : dict</span>
<span class="sd">        The second dictionary.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A new dictionary with concatenated values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Union of keys from both dictionaries</span>
    <span class="n">all_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">d1</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">d2</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">all_keys</span><span class="p">:</span>
        <span class="c1"># Concatenate values for each key</span>
        <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">d1</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[])</span> <span class="o">+</span> <span class="n">d2</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[])</span>

    <span class="k">return</span> <span class="n">result</span></div>



<div class="viewcode-block" id="find_first_and_last_position">
<a class="viewcode-back" href="../utils.html#utils.find_first_and_last_position">[docs]</a>
<span class="k">def</span> <span class="nf">find_first_and_last_position</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the positions of the first and last numbers in a string.</span>

<span class="sd">    This function searches for numbers in the string and returns the starting positions of the first and last occurrences.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    s : str</span>
<span class="sd">        The input string to search for numbers.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        A tuple containing the start positions of the first and last numbers. If no numbers are found, returns (-1, -1).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Define the regex pattern to find numbers</span>
    <span class="n">pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\d+&#39;</span>

    <span class="c1"># Find the first occurrence of the pattern</span>
    <span class="n">first_match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="n">first_pos</span> <span class="o">=</span> <span class="n">first_match</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="k">if</span> <span class="n">first_match</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># Find the last occurrence of the pattern</span>
    <span class="n">last_match</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="n">last_match</span> <span class="o">=</span> <span class="n">match</span>
    <span class="n">last_pos</span> <span class="o">=</span> <span class="n">last_match</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="k">if</span> <span class="n">last_match</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">return</span> <span class="n">first_pos</span><span class="p">,</span> <span class="n">last_pos</span></div>



<div class="viewcode-block" id="load_chromatograms">
<a class="viewcode-back" href="../utils.html#utils.load_chromatograms">[docs]</a>
<span class="k">def</span> <span class="nf">load_chromatograms</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load chromatogram data from a given file path.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    file_path : str</span>
<span class="sd">        The path to the file containing the chromatogram data.</span>
<span class="sd">    normalize : bool, optional</span>
<span class="sd">        Whether to normalize the chromatogram data. Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A dictionary containing the loaded chromatogram data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">wine_analysis</span> <span class="kn">import</span> <span class="n">WineAnalysis</span>

    <span class="c1"># Expand the user path to the full file path</span>
    <span class="n">analysis</span> <span class="o">=</span> <span class="n">WineAnalysis</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">file_path</span><span class="p">))</span>

    <span class="c1"># Return the data loaded by the WineAnalysis instance</span>
    <span class="k">return</span> <span class="n">analysis</span><span class="o">.</span><span class="n">data_loader</span><span class="o">.</span><span class="n">data</span></div>



<div class="viewcode-block" id="min_max_normalize">
<a class="viewcode-back" href="../utils.html#utils.min_max_normalize">[docs]</a>
<span class="k">def</span> <span class="nf">min_max_normalize</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">min_range</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_range</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform Min-Max normalization on data.</span>

<span class="sd">    This function scales the input data to a specified range [min_range, max_range] using Min-Max normalization.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : numpy.ndarray</span>
<span class="sd">        The data to be normalized.</span>
<span class="sd">    min_range : float, optional</span>
<span class="sd">        The minimum value of the desired range. Default is 0.</span>
<span class="sd">    max_range : float, optional</span>
<span class="sd">        The maximum value of the desired range. Default is 1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        The normalized data within the specified range.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Min-Max normalization rescales the data to a fixed range, typically [0, 1], based on the minimum and maximum values in the data.</span>
<span class="sd">    - This function normalizes the data across all values (i.e., sample-wise normalization) in the input array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">min_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">max_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">normalized_data</span> <span class="o">=</span> <span class="n">min_range</span> <span class="o">+</span> <span class="p">((</span><span class="n">data</span> <span class="o">-</span> <span class="n">min_val</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_range</span> <span class="o">-</span> <span class="n">min_range</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_val</span> <span class="o">-</span> <span class="n">min_val</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">normalized_data</span></div>



<div class="viewcode-block" id="normalize_mz_profiles_amplitude">
<a class="viewcode-back" href="../utils.html#utils.normalize_mz_profiles_amplitude">[docs]</a>
<span class="k">def</span> <span class="nf">normalize_mz_profiles_amplitude</span><span class="p">(</span><span class="n">data_dict</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;z-score&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize the amplitude of each m/z profile (column-wise normalization</span>
<span class="sd">    across retention times) using z-score or min-max normalization.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    data_dict : dict</span>
<span class="sd">        Dictionary where each key is a sample and each value is a 2D matrix</span>
<span class="sd">        (rows: retention times, columns: m/z values).</span>
<span class="sd">    method : str</span>
<span class="sd">        Normalization method, either &quot;z-score&quot; or &quot;min-max&quot;.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    dict</span>
<span class="sd">        Dictionary with normalized matrices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;z-score&quot;</span><span class="p">,</span> <span class="s2">&quot;min-max&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid method. Choose &#39;z-score&#39; or &#39;min-max&#39;.&quot;</span><span class="p">)</span>

    <span class="n">normalized_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">matrix</span> <span class="ow">in</span> <span class="n">data_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># Convert matrix to NumPy array if not already</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;z-score&quot;</span><span class="p">:</span>
            <span class="c1"># Z-score normalization</span>
            <span class="n">col_mean</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Mean for each column (m/z profile)</span>
            <span class="n">col_std</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>    <span class="c1"># Standard deviation for each column (m/z profile)</span>
            <span class="n">normalized_matrix</span> <span class="o">=</span> <span class="p">(</span><span class="n">matrix</span> <span class="o">-</span> <span class="n">col_mean</span><span class="p">)</span> <span class="o">/</span> <span class="n">col_std</span>

            <span class="c1"># Handle columns with zero standard deviation (avoid NaN)</span>
            <span class="n">normalized_matrix</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">normalized_matrix</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Replace NaN with 0</span>

        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;min-max&quot;</span><span class="p">:</span>
            <span class="c1"># Min-max normalization</span>
            <span class="n">col_min</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Min for each column (m/z profile)</span>
            <span class="n">col_max</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Max for each column (m/z profile)</span>
            <span class="n">normalized_matrix</span> <span class="o">=</span> <span class="p">(</span><span class="n">matrix</span> <span class="o">-</span> <span class="n">col_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">col_max</span> <span class="o">-</span> <span class="n">col_min</span><span class="p">)</span>

            <span class="c1"># Handle columns with zero range (avoid division by zero)</span>
            <span class="n">normalized_matrix</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">normalized_matrix</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Replace NaN with 0</span>

        <span class="c1"># Store the normalized matrix in the dictionary</span>
        <span class="n">normalized_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">normalized_matrix</span>

    <span class="k">return</span> <span class="n">normalized_dict</span></div>



<div class="viewcode-block" id="smooth_mz_profiles">
<a class="viewcode-back" href="../utils.html#utils.smooth_mz_profiles">[docs]</a>
<span class="k">def</span> <span class="nf">smooth_mz_profiles</span><span class="p">(</span><span class="n">data_dict</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Smooth the m/z profiles using a Gaussian filter.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    data_dict : dict</span>
<span class="sd">        Dictionary where each key is a sample and each value is a 2D matrix</span>
<span class="sd">        (rows: retention times, columns: m/z values).</span>
<span class="sd">    sigma : float</span>
<span class="sd">        The standard deviation for the Gaussian kernel. Larger values result in smoother profiles.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    dict</span>
<span class="sd">        Dictionary with smoothed matrices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">smoothed_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">matrix</span> <span class="ow">in</span> <span class="n">data_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># Convert to NumPy array if not already</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>

        <span class="c1"># Apply Gaussian filter along each m/z profile (column)</span>
        <span class="n">smoothed_matrix</span> <span class="o">=</span> <span class="n">gaussian_filter1d</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Store in the new dictionary</span>
        <span class="n">smoothed_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">smoothed_matrix</span>

    <span class="k">return</span> <span class="n">smoothed_dict</span></div>



<div class="viewcode-block" id="normalize_amplitude_minmax">
<a class="viewcode-back" href="../utils.html#utils.normalize_amplitude_minmax">[docs]</a>
<span class="k">def</span> <span class="nf">normalize_amplitude_minmax</span><span class="p">(</span><span class="n">signal</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize the signal using min-max normalization.</span>

<span class="sd">    This method scales the input signal so that its values range between 0 and 1. The minimum value</span>
<span class="sd">    of the signal becomes 0, and the maximum value becomes 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal : numpy.ndarray</span>
<span class="sd">        The input signal to be normalized.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        The normalized signal, where the values are scaled to the range [0, 1].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">min_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="n">max_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="n">normalized_signal</span> <span class="o">=</span> <span class="p">(</span><span class="n">signal</span> <span class="o">-</span> <span class="n">min_val</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_val</span> <span class="o">-</span> <span class="n">min_val</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">normalized_signal</span></div>



<div class="viewcode-block" id="normalize_amplitude_zscore">
<a class="viewcode-back" href="../utils.html#utils.normalize_amplitude_zscore">[docs]</a>
<span class="k">def</span> <span class="nf">normalize_amplitude_zscore</span><span class="p">(</span><span class="n">signal</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize the signal using standard normalization (z-score normalization).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal : numpy.ndarray</span>
<span class="sd">        The input signal to be normalized.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        The normalized signal.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mean_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="n">std_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="n">normalized_signal</span> <span class="o">=</span> <span class="p">(</span><span class="n">signal</span> <span class="o">-</span> <span class="n">mean_val</span><span class="p">)</span> <span class="o">/</span> <span class="n">std_val</span>

    <span class="k">return</span> <span class="n">normalized_signal</span></div>



<div class="viewcode-block" id="normalize_data">
<a class="viewcode-back" href="../utils.html#utils.normalize_data">[docs]</a>
<span class="k">def</span> <span class="nf">normalize_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">scaler</span><span class="o">=</span><span class="s1">&#39;standard&#39;</span><span class="p">,</span> <span class="n">feature_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize data which can be either a dictionary or an array.</span>

<span class="sd">    This function normalizes each feature (column) across all samples (rows) using the specified scaler.</span>
<span class="sd">    It ensures that the normalization is consistent for each feature across the dataset.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : dict or np.ndarray</span>
<span class="sd">        The data to be normalized. If dict, values should be arrays. If np.ndarray, it should be a 2D array.</span>
<span class="sd">    scaler : str, optional</span>
<span class="sd">        The type of scaler to use for normalization. Options are &#39;standard&#39;, &#39;minmax&#39;, &#39;robust&#39;. Default is &#39;standard&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict or np.ndarray</span>
<span class="sd">        The normalized data. If input was a dict, returns a dict with the same keys and normalized values.</span>
<span class="sd">        If input was an array, returns a normalized array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">values</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input data must be either a dictionary or a numpy array.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">scaler</span> <span class="o">==</span> <span class="s1">&#39;standard&#39;</span><span class="p">:</span>
        <span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">scaler</span> <span class="o">==</span> <span class="s1">&#39;minmax&#39;</span><span class="p">:</span>
        <span class="n">scaler</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">(</span><span class="n">feature_range</span><span class="o">=</span><span class="n">feature_range</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">scaler</span> <span class="o">==</span> <span class="s1">&#39;robust&#39;</span><span class="p">:</span>
        <span class="n">scaler</span> <span class="o">=</span> <span class="n">RobustScaler</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported scaler type. Choose from &#39;standard&#39;, &#39;minmax&#39;, or &#39;robust&#39;.&quot;</span><span class="p">)</span>

    <span class="n">values_scaled</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">norm_data</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">values_scaled</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">keys</span><span class="p">)}</span>
        <span class="k">return</span> <span class="n">norm_data</span><span class="p">,</span> <span class="n">scaler</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">values_scaled</span><span class="p">,</span> <span class="n">scaler</span></div>



<div class="viewcode-block" id="normalize_dict">
<a class="viewcode-back" href="../utils.html#utils.normalize_dict">[docs]</a>
<span class="k">def</span> <span class="nf">normalize_dict</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">scaler</span><span class="o">=</span><span class="s1">&#39;standard&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize the values in a dictionary across samples.</span>

<span class="sd">    This function normalizes each feature (column) in the dictionary across all samples (rows) using the specified scaler.</span>
<span class="sd">    The dictionary keys remain the same, while the values are normalized.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : dict</span>
<span class="sd">        The input dictionary to be normalized. The values should be lists or numpy arrays representing the features.</span>
<span class="sd">    scaler : str, optional</span>
<span class="sd">        The type of scaler to use for normalization. Options are &#39;standard&#39; (Z-score normalization),</span>
<span class="sd">        &#39;minmax&#39; (Min-Max scaling), and &#39;robust&#39; (RobustScaler). Default is &#39;standard&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A dictionary with the same keys and normalized values.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Normalization is performed feature-wise across all samples in the dictionary, meaning each feature (value associated with a key)</span>
<span class="sd">      is normalized across all samples (rows) in the dataset.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
    <span class="n">values_scaled</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">scaler</span> <span class="o">==</span> <span class="s1">&#39;standard&#39;</span><span class="p">:</span>
        <span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
        <span class="n">values_scaled</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">scaler</span> <span class="o">==</span> <span class="s1">&#39;minmax&#39;</span><span class="p">:</span>
        <span class="n">scaler</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span>
        <span class="n">values_scaled</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">scaler</span> <span class="o">==</span> <span class="s1">&#39;robust&#39;</span><span class="p">:</span>
        <span class="n">scaler</span> <span class="o">=</span> <span class="n">RobustScaler</span><span class="p">()</span>
        <span class="n">values_scaled</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="n">norm_data</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">values_scaled</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">keys</span><span class="p">)}</span>
    <span class="k">return</span> <span class="n">norm_data</span></div>



<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span><span class="p">,</span> <span class="n">MinMaxScaler</span><span class="p">,</span> <span class="n">RobustScaler</span>

<div class="viewcode-block" id="normalize_dict_multichannel">
<a class="viewcode-back" href="../utils.html#utils.normalize_dict_multichannel">[docs]</a>
<span class="k">def</span> <span class="nf">normalize_dict_multichannel</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">scaler</span><span class="o">=</span><span class="s1">&#39;standard&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize the values in a dictionary across samples for each channel separately.</span>
<span class="sd">    The output for each sample will be a matrix where columns represent channels and rows represent values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : dict</span>
<span class="sd">        The input dictionary to be normalized. The values should be lists of numpy arrays,</span>
<span class="sd">        where each inner array represents a channel.</span>
<span class="sd">    scaler : str, optional</span>
<span class="sd">        The type of scaler to use for normalization. Options are &#39;standard&#39; (Z-score normalization),</span>
<span class="sd">        &#39;minmax&#39; (Min-Max scaling), and &#39;robust&#39; (RobustScaler). Default is &#39;standard&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A dictionary with the same keys and normalized values, where each sample is a NumPy matrix.</span>
<span class="sd">        Columns represent channels, and rows represent normalized values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="c1"># Get the number of channels from the second dimension of any sample</span>
    <span class="n">first_sample</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>  <span class="c1"># Retrieve the first sample</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">first_sample</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Each sample in the dictionary should be a NumPy array.&quot;</span><span class="p">)</span>
    <span class="n">num_channels</span> <span class="o">=</span> <span class="n">first_sample</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Number of columns (channels)</span>

    <span class="n">norm_data</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Normalize each channel independently</span>
    <span class="k">for</span> <span class="n">channel_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_channels</span><span class="p">):</span>
        <span class="c1"># Extract data for the current channel across all samples</span>
        <span class="n">channel_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sample</span><span class="p">[:,</span> <span class="n">channel_idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>

        <span class="c1"># Choose and apply the scaler</span>
        <span class="k">if</span> <span class="n">scaler</span> <span class="o">==</span> <span class="s1">&#39;standard&#39;</span><span class="p">:</span>
            <span class="n">scaler_instance</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">scaler</span> <span class="o">==</span> <span class="s1">&#39;minmax&#39;</span><span class="p">:</span>
            <span class="n">scaler_instance</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">scaler</span> <span class="o">==</span> <span class="s1">&#39;robust&#39;</span><span class="p">:</span>
            <span class="n">scaler_instance</span> <span class="o">=</span> <span class="n">RobustScaler</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported scaler type. Choose &#39;standard&#39;, &#39;minmax&#39;, or &#39;robust&#39;.&quot;</span><span class="p">)</span>

        <span class="c1"># Normalize the current channel with all samples</span>
        <span class="n">channel_data_scaled</span> <span class="o">=</span> <span class="n">scaler_instance</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">channel_data</span><span class="p">)</span>

        <span class="c1"># Store normalized data back into the dictionary, grouped by sample</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">norm_data</span><span class="p">:</span>
                <span class="n">norm_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Append the normalized channel for the corresponding sample. Also normalize the amplitude</span>
            <span class="c1"># norm_data[key].append(utils.normalize_amplitude_zscore(channel_data_scaled[idx, :]))  # Ensure correct slicing</span>
            <span class="n">norm_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel_data_scaled</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:])</span>  <span class="c1"># Ensure correct slicing</span>

    <span class="c1"># Convert lists of channels into matrices (columns are channels, rows are values)</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">norm_data</span><span class="p">:</span>
        <span class="n">norm_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">(</span><span class="n">norm_data</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>  <span class="c1"># Stack as columns for all cases</span>

    <span class="k">return</span> <span class="n">norm_data</span></div>



<div class="viewcode-block" id="normalize_multichannel">
<a class="viewcode-back" href="../utils.html#utils.normalize_multichannel">[docs]</a>
<span class="k">def</span> <span class="nf">normalize_multichannel</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">scaler</span><span class="o">=</span><span class="s1">&#39;standard&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize the values across samples for each channel separately.</span>
<span class="sd">    The output for each sample will be a matrix where columns represent channels and rows represent values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : dict or np.ndarray</span>
<span class="sd">        If a dictionary, the values should be NumPy arrays where rows are timepoints and columns are channels.</span>
<span class="sd">        If an array, it should have shape (samples, timepoints, channels).</span>
<span class="sd">    scaler : str, optional</span>
<span class="sd">        The type of scaler to use for normalization. Options are &#39;standard&#39; (Z-score normalization),</span>
<span class="sd">        &#39;minmax&#39; (Min-Max scaling), and &#39;robust&#39; (RobustScaler). Default is &#39;standard&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict or np.ndarray</span>
<span class="sd">        If input is a dictionary, returns a dictionary with the same keys and normalized values.</span>
<span class="sd">        If input is an array, returns an array of the same shape with normalized values.</span>
<span class="sd">        Columns represent channels, and rows represent normalized values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Determine if input is a dictionary or array</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># Ensure the first sample is a NumPy array</span>
        <span class="n">first_sample</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">first_sample</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Each sample in the dictionary should be a NumPy array.&quot;</span><span class="p">)</span>

        <span class="n">num_channels</span> <span class="o">=</span> <span class="n">first_sample</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Number of channels</span>
        <span class="n">norm_data</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Normalize each channel independently</span>
        <span class="k">for</span> <span class="n">channel_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_channels</span><span class="p">):</span>
            <span class="c1"># Extract data for the current channel across all samples</span>
            <span class="n">channel_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sample</span><span class="p">[:,</span> <span class="n">channel_idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>

            <span class="c1"># Choose and apply the scaler</span>
            <span class="k">if</span> <span class="n">scaler</span> <span class="o">==</span> <span class="s1">&#39;standard&#39;</span><span class="p">:</span>
                <span class="n">scaler_instance</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">scaler</span> <span class="o">==</span> <span class="s1">&#39;minmax&#39;</span><span class="p">:</span>
                <span class="n">scaler_instance</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">scaler</span> <span class="o">==</span> <span class="s1">&#39;robust&#39;</span><span class="p">:</span>
                <span class="n">scaler_instance</span> <span class="o">=</span> <span class="n">RobustScaler</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported scaler type. Choose &#39;standard&#39;, &#39;minmax&#39;, or &#39;robust&#39;.&quot;</span><span class="p">)</span>

            <span class="c1"># Normalize the current channel with all samples</span>
            <span class="n">channel_data_scaled</span> <span class="o">=</span> <span class="n">scaler_instance</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">channel_data</span><span class="p">)</span>

            <span class="c1"># Store normalized data back into the dictionary, grouped by sample</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">norm_data</span><span class="p">:</span>
                    <span class="n">norm_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">norm_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel_data_scaled</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:])</span>  <span class="c1"># Ensure correct slicing</span>

        <span class="c1"># Convert lists of channels into matrices (columns are channels, rows are values)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">norm_data</span><span class="p">:</span>
            <span class="n">norm_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">(</span><span class="n">norm_data</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>  <span class="c1"># Stack as columns for all cases</span>

        <span class="k">return</span> <span class="n">norm_data</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input array must have shape (samples, timepoints, channels).&quot;</span><span class="p">)</span>

        <span class="n">samples</span><span class="p">,</span> <span class="n">timepoints</span><span class="p">,</span> <span class="n">channels</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">norm_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="c1"># Normalize each channel independently</span>
        <span class="k">for</span> <span class="n">channel_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">channels</span><span class="p">):</span>
            <span class="c1"># Extract data for the current channel across all samples</span>
            <span class="n">channel_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">channel_idx</span><span class="p">]</span>

            <span class="c1"># Choose and apply the scaler</span>
            <span class="k">if</span> <span class="n">scaler</span> <span class="o">==</span> <span class="s1">&#39;standard&#39;</span><span class="p">:</span>
                <span class="n">scaler_instance</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">scaler</span> <span class="o">==</span> <span class="s1">&#39;minmax&#39;</span><span class="p">:</span>
                <span class="n">scaler_instance</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">scaler</span> <span class="o">==</span> <span class="s1">&#39;robust&#39;</span><span class="p">:</span>
                <span class="n">scaler_instance</span> <span class="o">=</span> <span class="n">RobustScaler</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported scaler type. Choose &#39;standard&#39;, &#39;minmax&#39;, or &#39;robust&#39;.&quot;</span><span class="p">)</span>

            <span class="c1"># Normalize the current channel</span>
            <span class="n">channel_data_scaled</span> <span class="o">=</span> <span class="n">scaler_instance</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">channel_data</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># Transpose for sample-wise normalization</span>
            <span class="n">norm_data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">channel_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel_data_scaled</span>

        <span class="k">return</span> <span class="n">norm_data</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input must be a dictionary or a 3D NumPy array.&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="filter_dict_by_keys">
<a class="viewcode-back" href="../utils.html#utils.filter_dict_by_keys">[docs]</a>
<span class="k">def</span> <span class="nf">filter_dict_by_keys</span><span class="p">(</span><span class="n">original_dict</span><span class="p">,</span> <span class="n">keys_to_keep</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">original_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys_to_keep</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">original_dict</span><span class="p">}</span></div>



<div class="viewcode-block" id="filter_dict_by_first_letter">
<a class="viewcode-back" href="../utils.html#utils.filter_dict_by_first_letter">[docs]</a>
<span class="k">def</span> <span class="nf">filter_dict_by_first_letter</span><span class="p">(</span><span class="n">original_dict</span><span class="p">,</span> <span class="n">letters</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">original_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">original_dict</span> <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">letters</span><span class="p">}</span></div>



<div class="viewcode-block" id="plot_data_from_dict">
<a class="viewcode-back" href="../utils.html#utils.plot_data_from_dict">[docs]</a>
<span class="k">def</span> <span class="nf">plot_data_from_dict</span><span class="p">(</span><span class="n">data_dict</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">legend</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots all lists of data contained in a dictionary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data_dict : dict</span>
<span class="sd">        A dictionary with labels as keys and lists of values as values.</span>
<span class="sd">    title : str</span>
<span class="sd">        The title of the plot.</span>
<span class="sd">    legend : bool, optional</span>
<span class="sd">        Whether to display the legend. Default is False.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the input dictionary is empty.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">cycle</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">data_dict</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The input data dictionary is empty.&quot;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

    <span class="c1"># Create a color cycle to avoid repeating colors</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;tab10&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_dict</span><span class="p">))</span><span class="o">.</span><span class="n">colors</span>
    <span class="n">color_cycle</span> <span class="o">=</span> <span class="n">cycle</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">data_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="nb">next</span><span class="p">(</span><span class="n">color_cycle</span><span class="p">))</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Retention time&#39;</span><span class="p">)</span>
    <span class="c1"># plt.xlabel(&#39;m/z&#39;)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Intensity&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">legend</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>



<div class="viewcode-block" id="plot_lag">
<a class="viewcode-back" href="../utils.html#utils.plot_lag">[docs]</a>
<span class="k">def</span> <span class="nf">plot_lag</span><span class="p">(</span><span class="n">lags_loc</span><span class="p">,</span> <span class="n">lags</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Lag as a function of retention time&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot the lag as a function of retention time.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lags_loc : numpy.ndarray</span>
<span class="sd">        Locations of the lags.</span>
<span class="sd">    lags : numpy.ndarray</span>
<span class="sd">        Lags for each datapoint.</span>
<span class="sd">    title : str, optional</span>
<span class="sd">        Title of the plot. Default is &#39;Lag as a function of retention time&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lags_loc</span><span class="p">,</span> <span class="n">lags</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Lag&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Retention time&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Lag&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>



<div class="viewcode-block" id="remove_peak">
<a class="viewcode-back" href="../utils.html#utils.remove_peak">[docs]</a>
<span class="k">def</span> <span class="nf">remove_peak</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">peak_idx</span><span class="p">,</span> <span class="n">window_size</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Smoothly removes a peak from a signal using interpolation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal : np.ndarray</span>
<span class="sd">        The input signal.</span>
<span class="sd">    peak_idx : int</span>
<span class="sd">        The index of the peak to remove.</span>
<span class="sd">    window_size : int, optional</span>
<span class="sd">        The size of the window around the peak to use for interpolation. Default is 5.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        The signal with the peak removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">left_idx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">peak_idx</span> <span class="o">-</span> <span class="n">window_size</span><span class="p">)</span>
    <span class="n">right_idx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">),</span> <span class="n">peak_idx</span> <span class="o">+</span> <span class="n">window_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Interpolate over the region including the peak</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">left_idx</span><span class="p">,</span> <span class="n">right_idx</span><span class="p">])</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
    <span class="n">interpolated_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">left_idx</span><span class="p">,</span> <span class="n">right_idx</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="c1"># Replace the values in the signal with the interpolated values</span>
    <span class="n">signal_smooth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="n">signal_smooth</span><span class="p">[</span><span class="n">left_idx</span><span class="p">:</span><span class="n">right_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">interpolated_values</span>

    <span class="k">return</span> <span class="n">signal_smooth</span></div>



<div class="viewcode-block" id="calculate_chance_accuracy_with_priors">
<a class="viewcode-back" href="../utils.html#utils.calculate_chance_accuracy_with_priors">[docs]</a>
<span class="k">def</span> <span class="nf">calculate_chance_accuracy_with_priors</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the chance accuracy with priors based on class distribution.</span>

<span class="sd">    This function computes the chance accuracy by using the class priors.</span>
<span class="sd">    The chance accuracy is the sum of squared class proportions, where the</span>
<span class="sd">    proportion of each class is based on its occurrence in the dataset.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    labels : list of str</span>
<span class="sd">        A list of labels representing the classes of the samples.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The calculated chance accuracy with priors.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; labels = [&#39;E&#39;, &#39;L&#39;, &#39;Q&#39;, &#39;D&#39;, &#39;P&#39;, &#39;E&#39;, &#39;E&#39;, &#39;Q&#39;, &#39;D&#39;, &#39;P&#39;, &#39;L&#39;, &#39;E&#39;, &#39;R&#39;, &#39;X&#39;, &#39;M&#39;]</span>
<span class="sd">    &gt;&gt;&gt; calculate_chance_accuracy_with_priors(labels)</span>
<span class="sd">    0.06842374493702534</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create a Counter object to count occurrences of each class</span>
    <span class="n">class_counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

    <span class="c1"># Calculate the total number of samples</span>
    <span class="n">total_samples</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">class_counts</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="c1"># Calculate chance accuracy by summing the square of the class proportions</span>
    <span class="n">chance_accuracy</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">((</span><span class="n">count</span> <span class="o">/</span> <span class="n">total_samples</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">class_counts</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">return</span> <span class="n">chance_accuracy</span></div>



<span class="c1"># def load_ms_csv_data_from_directories(directory, columns, row_start, row_end):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Reads CSV files from all .D directories in the specified directory and extracts specific columns and row ranges.</span>
<span class="c1">#</span>
<span class="c1">#     Args:</span>
<span class="c1">#         directory (str): The path to the main directory containing .D directories.</span>
<span class="c1">#         columns (list of int): A list of column indices to extract from each CSV file.</span>
<span class="c1">#         row_start (int): The starting row index to extract (inclusive).</span>
<span class="c1">#         row_end (int): The ending row index to extract (exclusive).</span>
<span class="c1">#</span>
<span class="c1">#     Returns:</span>
<span class="c1">#         dict of numpy arrays: A dictionary where each key is a .D directory name (without the .D suffix),</span>
<span class="c1">#                               and each value is a numpy array containing the extracted data from each CSV file.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     data_dict = {}</span>
<span class="c1">#</span>
<span class="c1">#     # Loop through all .D directories in the specified directory</span>
<span class="c1">#     for subdir in sorted(os.listdir(directory)):</span>
<span class="c1">#         if subdir.endswith(&#39;.D&#39;):</span>
<span class="c1">#             # Remove the &#39;.D&#39; part for use as the dictionary key</span>
<span class="c1">#             dir_name = subdir[:-2]</span>
<span class="c1">#</span>
<span class="c1">#             # Construct the expected CSV file path</span>
<span class="c1">#             # csv_file_path = os.path.join(directory, subdir, f&quot;{dir_name}_MS.csv&quot;)</span>
<span class="c1">#             csv_file_path = os.path.join(directory, subdir, f&quot;{dir_name}.csv&quot;)</span>
<span class="c1">#</span>
<span class="c1">#             # Check if the expected CSV file exists</span>
<span class="c1">#             if os.path.isfile(csv_file_path):</span>
<span class="c1">#                 try:</span>
<span class="c1">#                     # Read the CSV file with pandas</span>
<span class="c1">#                     df = pd.read_csv(csv_file_path)</span>
<span class="c1">#</span>
<span class="c1">#                     # Select the specified columns and row range</span>
<span class="c1">#                     extracted_data = df.iloc[row_start:row_end, columns].to_numpy()</span>
<span class="c1">#</span>
<span class="c1">#                     # Store the extracted data in the dictionary with the directory name as the key</span>
<span class="c1">#                     data_dict[dir_name] = extracted_data</span>
<span class="c1">#</span>
<span class="c1">#                 except Exception as e:</span>
<span class="c1">#                     print(f&quot;Error processing file {csv_file_path}: {e}&quot;)</span>
<span class="c1">#             else:</span>
<span class="c1">#                 print(f&quot;No matching CSV file found in {subdir}.&quot;)</span>
<span class="c1">#</span>
<span class="c1">#     return data_dict</span>

<div class="viewcode-block" id="load_ms_csv_data_from_directories">
<a class="viewcode-back" href="../utils.html#utils.load_ms_csv_data_from_directories">[docs]</a>
<span class="k">def</span> <span class="nf">load_ms_csv_data_from_directories</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">row_start</span><span class="p">,</span> <span class="n">row_end</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reads CSV files from all .D directories in the specified directory and extracts specific columns and row ranges.</span>
<span class="sd">    Uses .npy caching to speed up repeated loading.</span>

<span class="sd">    Args:</span>
<span class="sd">        directory (str): The path to the main directory containing .D directories.</span>
<span class="sd">        columns (list of int): A list of column indices to extract from each CSV file.</span>
<span class="sd">        row_start (int): The starting row index to extract (inclusive).</span>
<span class="sd">        row_end (int): The ending row index to extract (exclusive).</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict of numpy arrays: A dictionary where each key is a .D directory name (without the .D suffix),</span>
<span class="sd">                              and each value is a numpy array containing the extracted data from each CSV file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">os</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

    <span class="n">data_dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Loop through all .D directories in the specified directory</span>
    <span class="k">for</span> <span class="n">subdir</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">directory</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">subdir</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.D&#39;</span><span class="p">):</span>
            <span class="n">dir_name</span> <span class="o">=</span> <span class="n">subdir</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># without &#39;.D&#39;</span>
            <span class="n">csv_file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">subdir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dir_name</span><span class="si">}</span><span class="s2">.csv&quot;</span><span class="p">)</span>
            <span class="n">cache_file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">subdir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dir_name</span><span class="si">}</span><span class="s2">_cached.npy&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">cache_file_path</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">extracted_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">cache_file_path</span><span class="p">)</span>
                    <span class="n">data_dict</span><span class="p">[</span><span class="n">dir_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">extracted_data</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loaded cached data from </span><span class="si">{</span><span class="n">cache_file_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error loading cache for </span><span class="si">{</span><span class="n">dir_name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">csv_file_path</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">csv_file_path</span><span class="p">)</span>
                    <span class="n">extracted_data</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">row_start</span><span class="p">:</span><span class="n">row_end</span><span class="p">,</span> <span class="n">columns</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">cache_file_path</span><span class="p">,</span> <span class="n">extracted_data</span><span class="p">)</span>
                    <span class="n">data_dict</span><span class="p">[</span><span class="n">dir_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">extracted_data</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processed and cached data from </span><span class="si">{</span><span class="n">csv_file_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error processing file </span><span class="si">{</span><span class="n">csv_file_path</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No matching CSV file found in </span><span class="si">{</span><span class="n">subdir</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data_dict</span></div>


<div class="viewcode-block" id="find_data_margins_in_csv">
<a class="viewcode-back" href="../utils.html#utils.find_data_margins_in_csv">[docs]</a>
<span class="k">def</span> <span class="nf">find_data_margins_in_csv</span><span class="p">(</span><span class="n">directory</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the first CSV file in a .D directory within the specified directory,</span>
<span class="sd">    returns the number of rows, and identifies the indices of the first and last columns</span>
<span class="sd">    with integer headers, or handles the special case of 2-column files.</span>

<span class="sd">    Args:</span>
<span class="sd">        directory (str): Path to the main directory containing .D directories.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: (int, int, int) where:</span>
<span class="sd">            - The first element is the row count in the CSV,</span>
<span class="sd">            - The second element is the index of the first relevant column,</span>
<span class="sd">            - The third element is the index of the last relevant column.</span>
<span class="sd">        Returns (None, None, None) if no valid CSV file is found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">subdir</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">directory</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">subdir</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.D&#39;</span><span class="p">):</span>
            <span class="n">dir_name</span> <span class="o">=</span> <span class="n">subdir</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">csv_file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">subdir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dir_name</span><span class="si">}</span><span class="s2">.csv&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">csv_file_path</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Load the CSV to get row count</span>
                    <span class="n">df_full</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">csv_file_path</span><span class="p">)</span>
                    <span class="n">row_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">df_full</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># +1 includes header row</span>

                    <span class="c1"># Load a few rows to inspect the columns</span>
                    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">csv_file_path</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
                    <span class="n">col_names</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">col_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="c1"># Special case: only 2 columns (e.g., Ret. Time, TIC)</span>
                        <span class="k">return</span> <span class="n">row_count</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>

                    <span class="c1"># General case: look for integer-named columns</span>
                    <span class="n">integer_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">col_names</span><span class="p">)</span> <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()]</span>

                    <span class="k">if</span> <span class="n">integer_columns</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">row_count</span><span class="p">,</span> <span class="n">integer_columns</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">integer_columns</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error processing file </span><span class="si">{</span><span class="n">csv_file_path</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No CSV file found in any .D directory.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="sum_data_in_data_dict">
<a class="viewcode-back" href="../utils.html#utils.sum_data_in_data_dict">[docs]</a>
<span class="k">def</span> <span class="nf">sum_data_in_data_dict</span><span class="p">(</span><span class="n">data_dict</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a dictionary with arrays as values and returns a new dictionary with the same keys.</span>
<span class="sd">    Depending on the axis parameter, each value is a list of either row sums or column sums.</span>

<span class="sd">    Args:</span>
<span class="sd">        data_dict (dict): A dictionary where keys are directory names, and values are 2D numpy arrays.</span>
<span class="sd">        axis (int): Axis along which to sum:</span>
<span class="sd">                    - 1 for summing all columns in a row (default)</span>
<span class="sd">                    - 0 for summing all rows in a column</span>
<span class="sd">    Returns:</span>
<span class="sd">        dict: A dictionary with the same keys as data_dict. Each value is a list of sums along the specified axis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sum_dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Loop through each key and array in the input dictionary</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">array</span> <span class="ow">in</span> <span class="n">data_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># Calculate the sum along the specified axis and convert to a list</span>
        <span class="n">sums</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="c1"># Store the list of sums in the new dictionary</span>
        <span class="n">sum_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">sums</span>

    <span class="k">return</span> <span class="n">sum_dict</span></div>



<div class="viewcode-block" id="string_to_latex_confusion_matrix">
<a class="viewcode-back" href="../utils.html#utils.string_to_latex_confusion_matrix">[docs]</a>
<span class="k">def</span> <span class="nf">string_to_latex_confusion_matrix</span><span class="p">(</span><span class="n">data_str</span><span class="p">,</span> <span class="n">headers</span><span class="p">):</span>
    <span class="c1"># Convert string to numpy array</span>
    <span class="n">data_str</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\s+&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">data_str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">))</span>  <span class="c1"># Clean up whitespace</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">row</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">data_str</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;] [&#39;</span><span class="p">)])</span>

    <span class="c1"># Multiply by 100 and convert to integer</span>
    <span class="c1"># data = np.round(data * 100).astype(int)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">data</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Begin LaTeX table string</span>
    <span class="n">latex_string</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">begin</span><span class="si">{table}</span><span class="s2">[h!]</span><span class="se">\n\\</span><span class="s2">centering</span><span class="se">\n\\</span><span class="s2">begin</span><span class="si">{tabular}</span><span class="s2">{|c|&quot;</span> <span class="o">+</span> <span class="s2">&quot;c|&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">headers</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}</span><span class="se">\n</span><span class="s2">    </span><span class="se">\\</span><span class="s2">hline</span><span class="se">\n</span><span class="s2">&quot;</span>

    <span class="c1"># Add column headers with rotated labels</span>
    <span class="n">latex_string</span> <span class="o">+=</span> <span class="s2">&quot;    &amp; &quot;</span> <span class="o">+</span> <span class="s2">&quot; &amp; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">rotatebox</span><span class="se">{{</span><span class="s2">90</span><span class="se">}}{{</span><span class="si">{</span><span class="n">header</span><span class="si">}</span><span class="se">}}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">header</span> <span class="ow">in</span> <span class="n">headers</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; </span><span class="se">\\\\\\</span><span class="s2">hline</span><span class="se">\n</span><span class="s2">&quot;</span>

    <span class="c1"># Populate rows with cell color and no display value</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="n">row_name</span> <span class="o">=</span> <span class="n">headers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">row_cells</span> <span class="o">=</span> <span class="s2">&quot; &amp; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">cellcolorval</span><span class="se">{{</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="se">}}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">row</span><span class="p">)</span>
        <span class="n">latex_string</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;    </span><span class="si">{</span><span class="n">row_name</span><span class="si">}</span><span class="s2"> &amp; </span><span class="si">{</span><span class="n">row_cells</span><span class="si">}</span><span class="s2"> </span><span class="se">\\\\\\</span><span class="s2">hline</span><span class="se">\n</span><span class="s2">&quot;</span>

    <span class="c1"># Complete LaTeX table</span>
    <span class="n">latex_string</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">end</span><span class="si">{tabular}</span><span class="se">\n\\</span><span class="s2">caption{Confusion Matrix in LaTeX}</span><span class="se">\n\\</span><span class="s2">end</span><span class="si">{table}</span><span class="s2">&quot;</span>

    <span class="c1"># Print without escape characters</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">latex_string</span><span class="p">)</span></div>



<div class="viewcode-block" id="string_to_latex_confusion_matrix_modified">
<a class="viewcode-back" href="../utils.html#utils.string_to_latex_confusion_matrix_modified">[docs]</a>
<span class="k">def</span> <span class="nf">string_to_latex_confusion_matrix_modified</span><span class="p">(</span><span class="n">data_str</span><span class="p">,</span> <span class="n">headers</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Header labels at the bottom&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">round_row_to_100_percent</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Round a row of probabilities to integers summing to 100.&quot;&quot;&quot;</span>
        <span class="n">scaled</span> <span class="o">=</span> <span class="n">row</span> <span class="o">*</span> <span class="mi">100</span>
        <span class="n">floored</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">scaled</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">remainder</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">100</span> <span class="o">-</span> <span class="n">floored</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>

        <span class="c1"># Distribute the remaining +1s to the highest decimals</span>
        <span class="n">decimal_parts</span> <span class="o">=</span> <span class="n">scaled</span> <span class="o">-</span> <span class="n">floored</span>
        <span class="n">top_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">decimal_parts</span><span class="p">)[:</span><span class="n">remainder</span><span class="p">]</span>
        <span class="n">floored</span><span class="p">[</span><span class="n">top_indices</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">floored</span>

    <span class="c1"># Clean up and convert string to numpy array</span>
    <span class="n">data_str</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\s+&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">data_str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">))</span>  <span class="c1"># Clean up whitespace</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">row</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">data_str</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;] [&#39;</span><span class="p">)])</span>
    <span class="c1"># data = np.round(data * 100).astype(int)  # Scale to percentages</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">round_row_to_100_percent</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">data</span><span class="p">])</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">headers</span><span class="p">)</span>

    <span class="n">latex</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">latex</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">begin</span><span class="si">{table}</span><span class="s2">[h!]&quot;</span><span class="p">)</span>
    <span class="n">latex</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;    </span><span class="se">\\</span><span class="s2">centering&quot;</span><span class="p">)</span>
    <span class="n">latex</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;    </span><span class="se">\\</span><span class="s2">setlength{</span><span class="se">\\</span><span class="s2">tabcolsep}</span><span class="si">{3pt}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">latex</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    </span><span class="se">\\</span><span class="s2">begin</span><span class="se">{{</span><span class="s2">tabular</span><span class="se">}}{{</span><span class="s2">l</span><span class="si">{</span><span class="s1">&#39;|c&#39;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="si">}</span><span class="s2">|</span><span class="se">}}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">latex</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;        </span><span class="se">\\</span><span class="s2">hline&quot;</span><span class="p">)</span>

    <span class="c1"># Add data rows</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="n">row_cells</span> <span class="o">=</span> <span class="s2">&quot; &amp; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">cellcolorval</span><span class="se">{{</span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="se">}}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">row</span><span class="p">)</span>
        <span class="n">latex</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;        </span><span class="si">{</span><span class="n">headers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2"> &amp; </span><span class="si">{</span><span class="n">row_cells</span><span class="si">}</span><span class="s2"> </span><span class="se">\\\\\\</span><span class="s2">hline&quot;</span><span class="p">)</span>

    <span class="c1"># Space before bottom headers</span>
    <span class="n">latex</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;        </span><span class="se">\\\\</span><span class="s2">[-3.8ex]&quot;</span><span class="p">)</span>
    <span class="n">latex</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;        </span><span class="se">\\</span><span class="s2">multicolumn</span><span class="se">{{</span><span class="si">{</span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="se">}}{{</span><span class="s2">c</span><span class="se">}}{{}}</span><span class="s2"> </span><span class="se">\\\\</span><span class="s2">[-1.9ex]&quot;</span><span class="p">)</span>

    <span class="c1"># Bottom column headers</span>
    <span class="n">header_row</span> <span class="o">=</span> <span class="s2">&quot; &amp; &quot;</span> <span class="o">+</span> <span class="s2">&quot; &amp; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">rotatebox</span><span class="se">{{</span><span class="s2">90</span><span class="se">}}{{</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="se">}}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">headers</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; </span><span class="se">\\\\</span><span class="s2">&quot;</span>
    <span class="n">latex</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;        </span><span class="si">{</span><span class="n">header_row</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Close tabular and table</span>
    <span class="n">latex</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;    </span><span class="se">\\</span><span class="s2">end</span><span class="si">{tabular}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">latex</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="s2">&quot;    </span><span class="se">\\</span><span class="s2">caption{Normalized confusion matrix with RGC classifier and TIC+TIS feature vectors for the Changins dataset. Rows represent the true labels, columns the predicted labels. Cell values are percentage of samples assigned to each predicted label. Darker blue = stronger prediction confidence.}&quot;</span><span class="p">)</span>
    <span class="n">latex</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">end</span><span class="si">{table}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">latex</span><span class="p">))</span></div>



<div class="viewcode-block" id="string_to_latex_correlation_matrix">
<a class="viewcode-back" href="../utils.html#utils.string_to_latex_correlation_matrix">[docs]</a>
<span class="k">def</span> <span class="nf">string_to_latex_correlation_matrix</span><span class="p">(</span><span class="n">data_str</span><span class="p">,</span> <span class="n">headers</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a correlation matrix string to a LaTeX table with \cellcolorval highlighting.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    ----------</span>
<span class="sd">    data_str : str</span>
<span class="sd">        The correlation matrix as a string (e.g., from np.array2string()).</span>
<span class="sd">    headers : list of str</span>
<span class="sd">        List of column and row headers.</span>

<span class="sd">    Returns:</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">        Prints the LaTeX-formatted table with \cellcolorval for values in [0, 1].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Cleanup and parse matrix from string to numpy array</span>
    <span class="n">data_str</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\s+&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">data_str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">))</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">row</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">data_str</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;] [&#39;</span><span class="p">)])</span>

    <span class="c1"># Begin LaTeX table string</span>
    <span class="n">latex</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">begin</span><span class="si">{table}</span><span class="s2">[h!]</span><span class="se">\n\\</span><span class="s2">centering</span><span class="se">\n\\</span><span class="s2">begin</span><span class="si">{tabular}</span><span class="s2">{|c|&quot;</span> <span class="o">+</span> <span class="s2">&quot;c|&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">headers</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}</span><span class="se">\n\\</span><span class="s2">hline</span><span class="se">\n</span><span class="s2">&quot;</span>

    <span class="c1"># Add headers</span>
    <span class="n">latex</span> <span class="o">+=</span> <span class="s2">&quot; &amp; &quot;</span> <span class="o">+</span> <span class="s2">&quot; &amp; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">rotatebox</span><span class="se">{{</span><span class="s2">90</span><span class="se">}}{{</span><span class="si">{</span><span class="n">h</span><span class="si">}</span><span class="se">}}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">headers</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; </span><span class="se">\\\\\n\\</span><span class="s2">hline</span><span class="se">\n</span><span class="s2">&quot;</span>

    <span class="c1"># Populate rows with \cellcolorval and actual values</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="n">row_label</span> <span class="o">=</span> <span class="n">headers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">formatted_row</span> <span class="o">=</span> <span class="s2">&quot; &amp; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">cellcolorval</span><span class="se">{{</span><span class="si">{</span><span class="n">v</span><span class="si">:</span><span class="s2">.3f</span><span class="se">}}</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">v</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">row</span><span class="p">)</span>
        <span class="n">latex</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">row_label</span><span class="si">}</span><span class="s2"> &amp; </span><span class="si">{</span><span class="n">formatted_row</span><span class="si">}</span><span class="s2"> </span><span class="se">\\\\\n\\</span><span class="s2">hline</span><span class="se">\n</span><span class="s2">&quot;</span>

    <span class="n">latex</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">end</span><span class="si">{tabular}</span><span class="se">\n\\</span><span class="s2">caption{Correlation Matrix with Heatmap Coloring}</span><span class="se">\n\\</span><span class="s2">end</span><span class="si">{table}</span><span class="s2">&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">latex</span><span class="p">)</span></div>



<div class="viewcode-block" id="string_to_latex_colored_matrix">
<a class="viewcode-back" href="../utils.html#utils.string_to_latex_colored_matrix">[docs]</a>
<span class="k">def</span> <span class="nf">string_to_latex_colored_matrix</span><span class="p">(</span><span class="n">data_str</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">round_decimals</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a correlation matrix string to a LaTeX table with dynamic cell coloring and font color for readability.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    data_str : str</span>
<span class="sd">        Correlation matrix as a string from np.array2string().</span>
<span class="sd">    headers : list of str</span>
<span class="sd">        Labels for rows/columns.</span>
<span class="sd">    round_decimals : int</span>
<span class="sd">        Number of decimals to display in the cell.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">re</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

    <span class="c1"># Parse and clean string matrix</span>
    <span class="n">data_str</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\s+&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">data_str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">))</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">row</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">data_str</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;] [&#39;</span><span class="p">)])</span>

    <span class="c1"># Begin LaTeX table</span>
    <span class="n">latex</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">begin</span><span class="si">{table}</span><span class="s2">[h!]</span><span class="se">\n\\</span><span class="s2">centering</span><span class="se">\n\\</span><span class="s2">begin</span><span class="si">{tabular}</span><span class="s2">{|c|&quot;</span> <span class="o">+</span> <span class="s2">&quot;c|&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">headers</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}</span><span class="se">\n\\</span><span class="s2">hline</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">latex</span> <span class="o">+=</span> <span class="s2">&quot; &amp; &quot;</span> <span class="o">+</span> <span class="s2">&quot; &amp; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">rotatebox</span><span class="se">{{</span><span class="s2">90</span><span class="se">}}{{</span><span class="si">{</span><span class="n">h</span><span class="si">}</span><span class="se">}}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">headers</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; </span><span class="se">\\\\\n\\</span><span class="s2">hline</span><span class="se">\n</span><span class="s2">&quot;</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">headers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">row</span><span class="p">:</span>
            <span class="n">colorval</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">val</span> <span class="o">*</span> <span class="mi">100</span><span class="p">))</span>
            <span class="n">text_color</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="c1"># text_color = &quot;\\textcolor{white}&quot; if colorval &gt; 70 else &quot;&quot;</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">cellcolor</span><span class="se">{{</span><span class="s2">lightblue!</span><span class="si">{</span><span class="n">colorval</span><span class="si">}</span><span class="s2">!white</span><span class="se">}}</span><span class="s2"> </span><span class="si">{</span><span class="n">text_color</span><span class="si">}</span><span class="se">{{</span><span class="si">{</span><span class="n">val</span><span class="si">:</span><span class="s2">.</span><span class="si">{</span><span class="n">round_decimals</span><span class="si">}</span><span class="s2">f</span><span class="se">}}</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">cells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
        <span class="n">latex</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2"> &amp; </span><span class="si">{</span><span class="s1">&#39; &amp; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span><span class="si">}</span><span class="s2"> </span><span class="se">\\\\\n\\</span><span class="s2">hline</span><span class="se">\n</span><span class="s2">&quot;</span>

    <span class="n">latex</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">end</span><span class="si">{tabular}</span><span class="se">\n\\</span><span class="s2">caption{Correlation Matrix with Heatmap Coloring}</span><span class="se">\n\\</span><span class="s2">end</span><span class="si">{table}</span><span class="s2">&quot;</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">latex</span><span class="p">)</span></div>





<div class="viewcode-block" id="plot_image">
<a class="viewcode-back" href="../utils.html#utils.plot_image">[docs]</a>
<span class="k">def</span> <span class="nf">plot_image</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot a 1-channel or 3-channel image (either a torch.Tensor or a numpy.ndarray) using Matplotlib.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    image : torch.Tensor or numpy.ndarray</span>
<span class="sd">        A 1-channel or 3-channel image of shape (1, H, W), (3, H, W), (H, W), or (H, W, 3).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Handle PyTorch tensor input</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
        <span class="c1"># Ensure the image is on the CPU and not batched</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>  <span class="c1"># Handle batch dimension</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>  <span class="c1"># Move to CPU if needed</span>

        <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># Convert 3-channel tensor to (H, W, 3)</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># Convert 1-channel tensor to (H, W)</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input tensor should have shape (1, H, W), (3, H, W), or (N, 3/1, H, W).&quot;</span><span class="p">)</span>

    <span class="c1"># Handle NumPy array input</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># (H, W, 3)</span>
            <span class="k">pass</span>  <span class="c1"># Already in the correct format</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># (H, W)</span>
            <span class="k">pass</span>  <span class="c1"># Already single-channel</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input numpy array should have shape (H, W) or (H, W, 3).&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input should be a torch.Tensor or numpy.ndarray.&quot;</span><span class="p">)</span>

    <span class="c1"># De-normalize if needed (for 3-channel images, using ImageNet stats)</span>
    <span class="n">mean</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.485</span><span class="p">,</span> <span class="mf">0.456</span><span class="p">,</span> <span class="mf">0.406</span><span class="p">]</span>
    <span class="n">std</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.229</span><span class="p">,</span> <span class="mf">0.224</span><span class="p">,</span> <span class="mf">0.225</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># (H, W, 3)</span>
        <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">:</span>  <span class="c1"># Assume it&#39;s in the [0, 255] range</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">image</span> <span class="o">/</span> <span class="mf">255.0</span>
        <span class="n">image</span> <span class="o">=</span> <span class="p">(</span><span class="n">image</span> <span class="o">*</span> <span class="n">std</span><span class="p">)</span> <span class="o">+</span> <span class="n">mean</span>  <span class="c1"># De-normalize</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Clip values to [0, 1] for display</span>

    <span class="c1"># Plot the image</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># RGB Image</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># Grayscale Image</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">)</span>  <span class="c1"># Use grayscale colormap</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unexpected image format for plotting.&quot;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>  <span class="c1"># Turn off axes</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>



<div class="viewcode-block" id="aggregate_retention_times">
<a class="viewcode-back" href="../utils.html#utils.aggregate_retention_times">[docs]</a>
<span class="k">def</span> <span class="nf">aggregate_retention_times</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Aggregate GCMS data along the retention time dimension.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    ----------</span>
<span class="sd">    data : numpy.ndarray</span>
<span class="sd">        A 2D array with shape (retention time, m/z).</span>
<span class="sd">    window_size : int</span>
<span class="sd">        The number of retention times to aggregate into one.</span>
<span class="sd">    method : str</span>
<span class="sd">        The aggregation method: &quot;mean&quot;, &quot;max&quot;, or &quot;median&quot;.</span>

<span class="sd">    Returns:</span>
<span class="sd">    -------</span>
<span class="sd">    aggregated_data : numpy.ndarray</span>
<span class="sd">        A 2D array with reduced retention time dimension.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Ensure the number of retention times is divisible by the window size</span>
    <span class="n">n_retention_times</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">truncated_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="n">n_retention_times</span> <span class="o">//</span> <span class="n">window_size</span> <span class="o">*</span> <span class="n">window_size</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># Reshape for aggregation</span>
    <span class="n">reshaped_data</span> <span class="o">=</span> <span class="n">truncated_data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># (num_windows, window_size, m/z)</span>

    <span class="c1"># Perform aggregation</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span><span class="p">:</span>
        <span class="n">aggregated_data</span> <span class="o">=</span> <span class="n">reshaped_data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Aggregate along the window size dimension</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;max&quot;</span><span class="p">:</span>
        <span class="n">aggregated_data</span> <span class="o">=</span> <span class="n">reshaped_data</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;median&quot;</span><span class="p">:</span>
        <span class="n">aggregated_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">reshaped_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid method. Choose &#39;mean&#39;, &#39;max&#39;, or &#39;median&#39;.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">aggregated_data</span></div>



<div class="viewcode-block" id="split_tensor_into_overlapping_windows">
<a class="viewcode-back" href="../utils.html#utils.split_tensor_into_overlapping_windows">[docs]</a>
<span class="k">def</span> <span class="nf">split_tensor_into_overlapping_windows</span><span class="p">(</span><span class="n">tensor</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split the last dimension of a tensor into overlapping windows.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    ----------</span>
<span class="sd">    tensor : torch.Tensor</span>
<span class="sd">        The input tensor of shape (batch_size, channels, length, 1).</span>
<span class="sd">    window_size : int</span>
<span class="sd">        The size of each window along the last dimension.</span>
<span class="sd">    stride : int</span>
<span class="sd">        The stride (step size) for overlapping windows.</span>

<span class="sd">    Returns:</span>
<span class="sd">    -------</span>
<span class="sd">    torch.Tensor</span>
<span class="sd">        A tensor of shape (batch_size * num_overlaps, channels, window_size).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Ensure the input tensor is 4D</span>
    <span class="k">if</span> <span class="n">tensor</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input tensor must be 4D (batch_size, channels, length, 1)&quot;</span><span class="p">)</span>

    <span class="c1"># Calculate the number of overlaps</span>
    <span class="n">num_overlaps</span> <span class="o">=</span> <span class="p">(</span><span class="n">tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">window_size</span><span class="p">)</span> <span class="o">//</span> <span class="n">stride</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># Apply unfolding to create windows</span>
    <span class="n">windows</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">unfold</span><span class="p">(</span>
        <span class="n">tensor</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>  <span class="c1"># Permute to (batch_size, 1, channels, length)</span>
        <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="n">tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">window_size</span><span class="p">),</span>  <span class="c1"># Window size for channels and length</span>
        <span class="n">stride</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">stride</span><span class="p">)</span>  <span class="c1"># Stride for channels and length</span>
    <span class="p">)</span>

    <span class="c1"># Reshape and permute back to the desired format</span>
    <span class="n">windows</span> <span class="o">=</span> <span class="n">windows</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">window_size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">windows</span><span class="p">,</span> <span class="n">num_overlaps</span></div>


<span class="c1"># def reduce_columns_in_dict(matrices_dict, n):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Reduces the column dimension of matrices in a dictionary by summing n contiguous columns.</span>
<span class="c1">#     Excess columns are added to the last column of the reduced matrix if the total is not divisible by n.</span>
<span class="c1">#</span>
<span class="c1">#     Parameters:</span>
<span class="c1">#         matrices_dict (dict): Dictionary of matrices (key: name, value: numpy.ndarray).</span>
<span class="c1">#                               Each matrix should have the same number of columns.</span>
<span class="c1">#         n (int): Number of contiguous columns to sum.</span>
<span class="c1">#</span>
<span class="c1">#     Returns:</span>
<span class="c1">#         dict: A new dictionary with reduced-dimension matrices.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     reduced_dict = {}</span>
<span class="c1">#     for key, matrix in matrices_dict.items():</span>
<span class="c1">#         rows, cols = matrix.shape</span>
<span class="c1">#         full_groups = cols // n</span>
<span class="c1">#</span>
<span class="c1">#         # Handle the main contiguous columns</span>
<span class="c1">#         reshaped_data = matrix[:, :full_groups * n].reshape(rows, full_groups, n)</span>
<span class="c1">#         reduced_matrix = reshaped_data.sum(axis=2)</span>
<span class="c1">#</span>
<span class="c1">#         # Handle excess columns</span>
<span class="c1">#         if cols % n != 0:</span>
<span class="c1">#             excess_columns = matrix[:, full_groups * n:].sum(axis=1, keepdims=True)</span>
<span class="c1">#             # Add excess to the last column of the reduced matrix</span>
<span class="c1">#             reduced_matrix[:, -1] += excess_columns.flatten()</span>
<span class="c1">#</span>
<span class="c1">#         reduced_matrix = np.apply_along_axis(utils.normalize_amplitude_zscore, axis=0, arr=reduced_matrix)</span>
<span class="c1">#</span>
<span class="c1">#         # Store in the result dictionary</span>
<span class="c1">#         reduced_dict[key] = reduced_matrix</span>
<span class="c1">#</span>
<span class="c1">#     return reduced_dict</span>


<div class="viewcode-block" id="reduce_columns_in_dict">
<a class="viewcode-back" href="../utils.html#utils.reduce_columns_in_dict">[docs]</a>
<span class="k">def</span> <span class="nf">reduce_columns_in_dict</span><span class="p">(</span><span class="n">matrices_dict</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reduces the column dimension of matrices in a dictionary by summing n contiguous columns.</span>
<span class="sd">    Excess columns are added to the last column of the reduced matrix if the total is not divisible by n.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        matrices_dict (dict): Dictionary of matrices (key: name, value: numpy.ndarray).</span>
<span class="sd">                              Each matrix should have the same number of columns.</span>
<span class="sd">        n (int): Number of contiguous columns to sum.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: A new dictionary with reduced-dimension matrices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">reduced_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">matrix</span> <span class="ow">in</span> <span class="n">matrices_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">full_groups</span> <span class="o">=</span> <span class="n">cols</span> <span class="o">//</span> <span class="n">n</span>

        <span class="c1"># Handle the main contiguous columns</span>
        <span class="n">reshaped_data</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[:,</span> <span class="p">:</span><span class="n">full_groups</span> <span class="o">*</span> <span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">full_groups</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">reduced_matrix</span> <span class="o">=</span> <span class="n">reshaped_data</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Handle excess columns</span>
        <span class="k">if</span> <span class="n">cols</span> <span class="o">%</span> <span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">excess_columns</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[:,</span> <span class="n">full_groups</span> <span class="o">*</span> <span class="n">n</span><span class="p">:]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Add excess to the last column of the reduced matrix</span>
            <span class="n">reduced_matrix</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">excess_columns</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">reduced_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">normalize_amplitude_zscore</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">arr</span><span class="o">=</span><span class="n">reduced_matrix</span><span class="p">)</span>

        <span class="c1"># Store in the result dictionary</span>
        <span class="n">reduced_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduced_matrix</span>

    <span class="k">return</span> <span class="n">reduced_dict</span></div>


<div class="viewcode-block" id="reduce_columns_to_final_channels">
<a class="viewcode-back" href="../utils.html#utils.reduce_columns_to_final_channels">[docs]</a>
<span class="k">def</span> <span class="nf">reduce_columns_to_final_channels</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">final_channels</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reduces the column dimension of a 3D array to a specified number of final channels by averaging</span>
<span class="sd">    contiguous elements across the last dimension. Excess elements are added to the last group&#39;s average.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        matrix (numpy.ndarray): A 3D array to process (shape: samples x features x channels).</span>
<span class="sd">        final_channels (int): The desired number of channels after reduction.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: A reduced-dimension 3D array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">samples</span><span class="p">,</span> <span class="n">features</span><span class="p">,</span> <span class="n">channels</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># Calculate the number of channels to group (n) and handle any remaining channels</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">channels</span> <span class="o">//</span> <span class="n">final_channels</span>  <span class="c1"># Number of contiguous channels to average per group</span>
    <span class="n">remaining</span> <span class="o">=</span> <span class="n">channels</span> <span class="o">%</span> <span class="n">final_channels</span>  <span class="c1"># Remaining channels to add to the last group</span>

    <span class="c1"># Initialize the reduced matrix</span>
    <span class="n">reduced_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">samples</span><span class="p">,</span> <span class="n">features</span><span class="p">,</span> <span class="n">final_channels</span><span class="p">))</span>

    <span class="c1"># Aggregate channels into groups</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">final_channels</span><span class="p">):</span>
        <span class="n">start_idx</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">n</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">final_channels</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># Include the remaining channels in the last group</span>
            <span class="n">end_idx</span> <span class="o">=</span> <span class="n">channels</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">end_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span>
        <span class="n">reduced_matrix</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">matrix</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">reduced_matrix</span></div>



<span class="kn">import</span> <span class="nn">netCDF4</span>
<span class="kn">import</span> <span class="nn">csv</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">subprocess</span>


<div class="viewcode-block" id="convert_ms_files_to_cdf_in_place">
<a class="viewcode-back" href="../utils.html#utils.convert_ms_files_to_cdf_in_place">[docs]</a>
<span class="k">def</span> <span class="nf">convert_ms_files_to_cdf_in_place</span><span class="p">(</span><span class="n">root_folder</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recursively converts all .ms files in the root_folder (including subdirectories)</span>
<span class="sd">    to .cdf format using ProteoWizard&#39;s msconvert and saves the output in the same folder.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        root_folder (str): Path to the directory containing .ms files.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">root</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">files</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">root_folder</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;data.ms&quot;</span><span class="p">):</span>
                <span class="n">input_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
                <span class="n">output_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">file</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.ms&quot;</span><span class="p">,</span> <span class="s2">&quot;.cdf&quot;</span><span class="p">))</span>

                <span class="c1"># Run msconvert command</span>
                <span class="n">command</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="s2">&quot;msconvert&quot;</span><span class="p">,</span> <span class="n">input_path</span><span class="p">,</span>
                    <span class="s2">&quot;--outdir&quot;</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span>  <span class="c1"># Save in the same folder</span>
                    <span class="s2">&quot;--mzML&quot;</span>
                <span class="p">]</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">subprocess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Converted: </span><span class="si">{</span><span class="n">input_path</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">CalledProcessError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error converting </span><span class="si">{</span><span class="n">input_path</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="convert_cdf_to_csv">
<a class="viewcode-back" href="../utils.html#utils.convert_cdf_to_csv">[docs]</a>
<span class="k">def</span> <span class="nf">convert_cdf_to_csv</span><span class="p">(</span><span class="n">cdf_file</span><span class="p">,</span> <span class="n">csv_file</span><span class="p">,</span> <span class="n">mz_min</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">mz_max</span><span class="o">=</span><span class="mi">220</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a CDF file to a CSV file with retention time and m/z intensity channels.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    cdf_file (str): Path to the input CDF file.</span>
<span class="sd">    csv_file (str): Path to the output CSV file.</span>
<span class="sd">    mz_min (int): Minimum m/z value for the channels.</span>
<span class="sd">    mz_max (int): Maximum m/z value for the channels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Open the NetCDF file</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">netCDF4</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">cdf_file</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>

        <span class="c1"># Retrieve necessary variables</span>
        <span class="n">retention_times</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s1">&#39;scan_acquisition_time&#39;</span><span class="p">][:]</span> <span class="o">*</span> <span class="mi">1000</span>  <span class="c1"># Convert to milliseconds</span>
        <span class="n">mass_values</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s1">&#39;mass_values&#39;</span><span class="p">][:]</span>
        <span class="n">intensity_values</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s1">&#39;intensity_values&#39;</span><span class="p">][:]</span>
        <span class="n">point_counts</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s1">&#39;point_count&#39;</span><span class="p">][:]</span>

        <span class="c1"># Define m/z range (integer values between mz_min and mz_max)</span>
        <span class="n">mz_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">mz_min</span><span class="p">,</span> <span class="n">mz_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Include mz_max</span>

        <span class="c1"># Prepare the output matrix</span>
        <span class="c1"># Rows: Retention times, Columns: Retention time + m/z channels</span>
        <span class="n">output_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">retention_times</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">mz_range</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">output_matrix</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">retention_times</span>  <span class="c1"># First column is retention time</span>

        <span class="c1"># Precompute all rounded m/z values and corresponding intensity values</span>
        <span class="n">mz_rounded_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">mass_values</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># Precompute valid m/z indices (those in range [mz_min, mz_max])</span>
        <span class="n">valid_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">mz_rounded_all</span> <span class="o">&gt;=</span> <span class="n">mz_min</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mz_rounded_all</span> <span class="o">&lt;=</span> <span class="n">mz_max</span><span class="p">)</span>
        <span class="n">mz_indices</span> <span class="o">=</span> <span class="n">mz_rounded_all</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span> <span class="o">-</span> <span class="n">mz_min</span>  <span class="c1"># Map valid m/z to column indices</span>
        <span class="n">valid_intensities</span> <span class="o">=</span> <span class="n">intensity_values</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span>

        <span class="c1"># Create a pointer for the current position in point_counts</span>
        <span class="n">current_index</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Iterate over scans and aggregate intensities</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">point_count</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">point_counts</span><span class="p">):</span>
            <span class="c1"># Get the range for this scan</span>
            <span class="n">scan_range</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">current_index</span><span class="p">,</span> <span class="n">current_index</span> <span class="o">+</span> <span class="n">point_count</span><span class="p">)</span>

            <span class="c1"># Apply the valid mask for this scan</span>
            <span class="n">scan_mz_values</span> <span class="o">=</span> <span class="n">mz_rounded_all</span><span class="p">[</span><span class="n">scan_range</span><span class="p">]</span>
            <span class="n">scan_intensities</span> <span class="o">=</span> <span class="n">intensity_values</span><span class="p">[</span><span class="n">scan_range</span><span class="p">]</span>

            <span class="c1"># Apply filter to get valid m/z and intensities</span>
            <span class="n">valid_scan_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">scan_mz_values</span> <span class="o">&gt;=</span> <span class="n">mz_min</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">scan_mz_values</span> <span class="o">&lt;=</span> <span class="n">mz_max</span><span class="p">)</span>
            <span class="n">mz_indices_scan</span> <span class="o">=</span> <span class="n">scan_mz_values</span><span class="p">[</span><span class="n">valid_scan_mask</span><span class="p">]</span> <span class="o">-</span> <span class="n">mz_min</span>
            <span class="n">intensities_scan</span> <span class="o">=</span> <span class="n">scan_intensities</span><span class="p">[</span><span class="n">valid_scan_mask</span><span class="p">]</span>

            <span class="c1"># Use NumPy&#39;s add.at for fast accumulation</span>
            <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">output_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">:],</span> <span class="n">mz_indices_scan</span><span class="p">,</span> <span class="n">intensities_scan</span><span class="p">)</span>

            <span class="c1"># Move to the next scan range</span>
            <span class="n">current_index</span> <span class="o">+=</span> <span class="n">point_count</span>

        <span class="c1"># Write the output matrix to a CSV file</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">csv_file</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">csv_output</span><span class="p">:</span>
            <span class="n">writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">csv_output</span><span class="p">)</span>

            <span class="c1"># Write the header</span>
            <span class="n">header</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Retention Time (ms)&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">mz</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">mz</span> <span class="ow">in</span> <span class="n">mz_range</span><span class="p">]</span>
            <span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>

            <span class="c1"># Write the rows of data</span>
            <span class="n">writer</span><span class="o">.</span><span class="n">writerows</span><span class="p">(</span><span class="n">output_matrix</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Successfully converted </span><span class="si">{</span><span class="n">cdf_file</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">csv_file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">ke</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Key Error: </span><span class="si">{</span><span class="n">ke</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="c1"># Close the dataset</span>
        <span class="n">dataset</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>




<div class="viewcode-block" id="convert_cdf_directory_to_csv">
<a class="viewcode-back" href="../utils.html#utils.convert_cdf_directory_to_csv">[docs]</a>
<span class="k">def</span> <span class="nf">convert_cdf_directory_to_csv</span><span class="p">(</span><span class="n">input_dir</span><span class="p">,</span> <span class="n">mz_min</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">mz_max</span><span class="o">=</span><span class="mi">220</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts all CDF files in *.D directories to CSV files in the same directories.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    input_dir (str): Path to the root directory containing *.D subdirectories with CDF files.</span>
<span class="sd">    mz_min (int): Minimum m/z value for the channels.</span>
<span class="sd">    mz_max (int): Maximum m/z value for the channels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Walk through all subdirectories in the input directory</span>
    <span class="k">for</span> <span class="n">subdir</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">input_dir</span><span class="p">):</span>
        <span class="n">subdir_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">input_dir</span><span class="p">,</span> <span class="n">subdir</span><span class="p">)</span>

        <span class="c1"># Check if the subdirectory is a *.D directory</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">subdir_path</span><span class="p">)</span> <span class="ow">and</span> <span class="n">subdir</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.D&#39;</span><span class="p">):</span>
            <span class="n">cdf_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">subdir_path</span><span class="p">,</span> <span class="s1">&#39;data.cdf&#39;</span><span class="p">)</span>  <span class="c1"># Path to the data.cdf file</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">cdf_file</span><span class="p">):</span>
                <span class="c1"># Generate the output CSV file name</span>
                <span class="n">csv_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">subdir_path</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">subdir</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">.csv&quot;</span><span class="p">)</span>

                <span class="c1"># Convert the CDF file to CSV</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Converting </span><span class="si">{</span><span class="n">cdf_file</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">csv_file</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
                    <span class="n">convert_cdf_to_csv</span><span class="p">(</span><span class="n">cdf_file</span><span class="p">,</span> <span class="n">csv_file</span><span class="p">,</span> <span class="n">mz_min</span><span class="o">=</span><span class="n">mz_min</span><span class="p">,</span> <span class="n">mz_max</span><span class="o">=</span><span class="n">mz_max</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to convert </span><span class="si">{</span><span class="n">cdf_file</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>




<div class="viewcode-block" id="plot_aggregated_weights">
<a class="viewcode-back" href="../utils.html#utils.plot_aggregated_weights">[docs]</a>
<span class="k">def</span> <span class="nf">plot_aggregated_weights</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">bin_size</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">class_index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Aggregates feature weights into bins and plots the average weight per bin.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    weights : np.ndarray</span>
<span class="sd">        Array of feature weights (1D array for binary classification or row for a specific class in multi-class classification).</span>
<span class="sd">    bin_size : int</span>
<span class="sd">        Number of features per bin for aggregation.</span>
<span class="sd">    class_index : int or None</span>
<span class="sd">        Index of the class for labeling (used only for multi-class classification).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Ensure weights is a 1D array</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>

    <span class="c1"># Calculate number of bins</span>
    <span class="n">num_bins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">//</span> <span class="n">bin_size</span>
    <span class="n">remainder</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">%</span> <span class="n">bin_size</span>

    <span class="c1"># Aggregate weights by bins</span>
    <span class="n">binned_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">weights</span><span class="p">[:</span><span class="n">num_bins</span> <span class="o">*</span> <span class="n">bin_size</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">num_bins</span><span class="p">,</span> <span class="n">bin_size</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Handle remainder features if they exist</span>
    <span class="k">if</span> <span class="n">remainder</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">remainder_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="n">num_bins</span> <span class="o">*</span> <span class="n">bin_size</span><span class="p">:])</span>
        <span class="n">binned_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">binned_weights</span><span class="p">,</span> <span class="n">remainder_avg</span><span class="p">)</span>

    <span class="c1"># Plot aggregated weights</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">binned_weights</span><span class="p">)),</span> <span class="n">binned_weights</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Feature Bins&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Average Weight Value&quot;</span><span class="p">)</span>
    <span class="n">title</span> <span class="o">=</span> <span class="s2">&quot;Aggregated Feature Weights by Bin&quot;</span>
    <span class="k">if</span> <span class="n">class_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">title</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; (Class </span><span class="si">{</span><span class="n">class_index</span><span class="si">}</span><span class="s2">)&quot;</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>



<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<div class="viewcode-block" id="compute_channel_correlation_single_sample">
<a class="viewcode-back" href="../utils.html#utils.compute_channel_correlation_single_sample">[docs]</a>
<span class="k">def</span> <span class="nf">compute_channel_correlation_single_sample</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sample_index</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;coolwarm&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes and visualizes the correlation matrix for m/z channels within a single sample.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : np.ndarray</span>
<span class="sd">        Input 3D array with shape (samples, features, channels).</span>
<span class="sd">    sample_index : int</span>
<span class="sd">        Index of the sample to analyze.</span>
<span class="sd">    figsize : tuple</span>
<span class="sd">        Size of the heatmap figure (default: (8, 6)).</span>
<span class="sd">    cmap : str</span>
<span class="sd">        Colormap for the heatmap (default: &quot;coolwarm&quot;).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        Correlation matrix of shape (channels, channels) for the selected sample.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Step 1: Extract the data for the specific sample</span>
    <span class="n">sample_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">sample_index</span><span class="p">]</span>  <span class="c1"># Shape: (features, channels)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Shape of sample_data: </span><span class="si">{</span><span class="n">sample_data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># Should be (features, channels)</span>

    <span class="c1"># Step 2: Compute the correlation matrix for the channels within this sample</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">correlation_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">sample_data</span><span class="p">,</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># Shape: (channels, channels)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error computing correlation matrix: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Step 3: Plot the correlation matrix</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
    <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">correlation_matrix</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">square</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">annot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;.2f&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Correlation Between m/z Channels (Sample </span><span class="si">{</span><span class="n">sample_index</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Channels&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Channels&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">correlation_matrix</span></div>



<div class="viewcode-block" id="split_train_val_test">
<a class="viewcode-back" href="../utils.html#utils.split_train_val_test">[docs]</a>
<span class="k">def</span> <span class="nf">split_train_val_test</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">validation_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">42</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits the dataset into train, validation, and test sets.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : np.ndarray</span>
<span class="sd">        Feature matrix.</span>
<span class="sd">    labels : np.ndarray</span>
<span class="sd">        Corresponding labels.</span>
<span class="sd">    test_size : float</span>
<span class="sd">        Proportion of data to reserve for the test set.</span>
<span class="sd">    validation_size : float</span>
<span class="sd">        Proportion of the training data to reserve for the validation set.</span>
<span class="sd">    random_seed : int</span>
<span class="sd">        Random seed for reproducibility.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    X_train : np.ndarray</span>
<span class="sd">        Training features.</span>
<span class="sd">    X_val : np.ndarray</span>
<span class="sd">        Validation features.</span>
<span class="sd">    X_test : np.ndarray</span>
<span class="sd">        Test features.</span>
<span class="sd">    y_train : np.ndarray</span>
<span class="sd">        Training labels.</span>
<span class="sd">    y_val : np.ndarray</span>
<span class="sd">        Validation labels.</span>
<span class="sd">    y_test : np.ndarray</span>
<span class="sd">        Test labels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># First, split off the test set</span>
    <span class="n">X_train_val</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train_val</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">,</span> <span class="n">stratify</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_seed</span>
    <span class="p">)</span>

    <span class="c1"># Then, split the remaining data into train and validation sets</span>
    <span class="n">val_size_adjusted</span> <span class="o">=</span> <span class="n">validation_size</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">test_size</span><span class="p">)</span>  <span class="c1"># Adjust validation size proportion</span>
    <span class="n">X_train</span><span class="p">,</span> <span class="n">X_val</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_val</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span>
        <span class="n">X_train_val</span><span class="p">,</span> <span class="n">y_train_val</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">val_size_adjusted</span><span class="p">,</span> <span class="n">stratify</span><span class="o">=</span><span class="n">y_train_val</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_seed</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">X_val</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_val</span><span class="p">,</span> <span class="n">y_test</span></div>



<div class="viewcode-block" id="copy_files_to_matching_directories">
<a class="viewcode-back" href="../utils.html#utils.copy_files_to_matching_directories">[docs]</a>
<span class="k">def</span> <span class="nf">copy_files_to_matching_directories</span><span class="p">(</span><span class="n">source_dir</span><span class="p">,</span> <span class="n">mother_dir</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reads files from source_dir and copies each file into a directory inside</span>
<span class="sd">    mother_dir (or its subdirectories) that matches the file&#39;s name (without extension, ignoring &#39;.D&#39;).</span>

<span class="sd">    If no matching directory is found, a new directory named &#39;file.D&#39; is created at the root.</span>

<span class="sd">    Args:</span>
<span class="sd">        source_dir (str): Path to the directory containing files to be copied.</span>
<span class="sd">        mother_dir (str): Path to the mother directory where files will be organized.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">find_matching_directory</span><span class="p">(</span><span class="n">folder_name</span><span class="p">,</span> <span class="n">mother_dir</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursively search for a directory named &#39;folder_name.D&#39; within &#39;mother_dir&#39;.</span>
<span class="sd">        Returns the path if found, otherwise None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">root</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">mother_dir</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">directory</span> <span class="ow">in</span> <span class="n">dirs</span><span class="p">:</span>
                <span class="c1"># Ignore case and check if directory ends with .D and matches folder_name</span>
                <span class="k">if</span> <span class="n">directory</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.d&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">directory</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">folder_name</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">directory</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Ensure the mother directory exists</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">mother_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Loop through each file in the source directory</span>
    <span class="k">for</span> <span class="n">file_name</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">source_dir</span><span class="p">):</span>
        <span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">source_dir</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>

        <span class="c1"># Only process files</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">file_path</span><span class="p">):</span>
            <span class="c1"># Extract filename without extension</span>
            <span class="n">folder_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">file_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Search for a matching directory recursively (ignoring &#39;.D&#39;)</span>
            <span class="n">destination_folder</span> <span class="o">=</span> <span class="n">find_matching_directory</span><span class="p">(</span><span class="n">folder_name</span><span class="p">,</span> <span class="n">mother_dir</span><span class="p">)</span>

            <span class="c1"># If no directory is found, create one at the root of mother_dir with .D suffix</span>
            <span class="k">if</span> <span class="n">destination_folder</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">destination_folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">mother_dir</span><span class="p">,</span> <span class="n">folder_name</span> <span class="o">+</span> <span class="s2">&quot;.D&quot;</span><span class="p">)</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">destination_folder</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Copy the file to the destination folder</span>
            <span class="n">destination_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">destination_folder</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">destination_path</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Copied: </span><span class="si">{</span><span class="n">file_name</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">destination_folder</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>



<span class="c1"># def remove_zero_variance_channels(data_dict):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Removes channels with zero variance across all samples in the dataset.</span>
<span class="c1">#</span>
<span class="c1">#     Parameters:</span>
<span class="c1">#         data_dict (dict): Dictionary where keys are sample IDs and values are NumPy arrays</span>
<span class="c1">#                           of shape (timepoints, num_channels).</span>
<span class="c1">#</span>
<span class="c1">#     Returns:</span>
<span class="c1">#         filtered_data_dict (dict): Dictionary with zero-variance channels removed.</span>
<span class="c1">#         valid_channels (list): Indices of retained channels.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     # Stack all sample arrays along a new axis: shape (num_samples, timepoints, num_channels)</span>
<span class="c1">#     all_samples = np.array(list(data_dict.values()))  # Shape: (num_samples, timepoints, num_channels)</span>
<span class="c1">#</span>
<span class="c1">#     # Compute variance for each channel across all timepoints and samples</span>
<span class="c1">#     channel_variances = np.var(all_samples, axis=(0, 1))  # Shape: (num_channels,)</span>
<span class="c1">#</span>
<span class="c1">#     # Identify valid channels (non-zero variance)</span>
<span class="c1">#     valid_channels = np.where(channel_variances &gt; 1e-8)[0]  # Indices of channels to keep</span>
<span class="c1">#</span>
<span class="c1">#     # Remove zero-variance channels from each sample</span>
<span class="c1">#     filtered_data_dict = {</span>
<span class="c1">#         sample_id: data[:, valid_channels] for sample_id, data in data_dict.items()</span>
<span class="c1">#     }</span>
<span class="c1">#</span>
<span class="c1">#     return filtered_data_dict, valid_channels</span>

<div class="viewcode-block" id="remove_zero_variance_channels">
<a class="viewcode-back" href="../utils.html#utils.remove_zero_variance_channels">[docs]</a>
<span class="k">def</span> <span class="nf">remove_zero_variance_channels</span><span class="p">(</span><span class="n">data_dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes channels with zero variance across all samples in the dataset.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        data_dict (dict): Dictionary where keys are sample IDs and values are NumPy arrays</span>
<span class="sd">                          of shape (timepoints, num_channels).</span>

<span class="sd">    Returns:</span>
<span class="sd">        filtered_data_dict (dict): Dictionary with zero-variance channels removed.</span>
<span class="sd">        valid_channels (list): Indices of retained channels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sample_shapes</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
    <span class="n">num_channels</span> <span class="o">=</span> <span class="n">sample_shapes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">sample_shapes</span> <span class="k">else</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">num_channels</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; Only one channel found (or data is not multi-channel). Skipping variance filtering.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data_dict</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_channels</span><span class="p">))</span>

    <span class="c1"># Stack all samples: (num_samples, timepoints, num_channels)</span>
    <span class="n">all_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">data_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

    <span class="c1"># Compute variance for each channel</span>
    <span class="n">channel_variances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">all_samples</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Keep channels with variance &gt; threshold</span>
    <span class="n">valid_channels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">channel_variances</span> <span class="o">&gt;</span> <span class="mf">1e-8</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">filtered_data_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">sample_id</span><span class="p">:</span> <span class="n">data</span><span class="p">[:,</span> <span class="n">valid_channels</span><span class="p">]</span> <span class="k">for</span> <span class="n">sample_id</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">data_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">filtered_data_dict</span><span class="p">,</span> <span class="n">valid_channels</span></div>



<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>


<div class="viewcode-block" id="plot_snr_per_channel">
<a class="viewcode-back" href="../utils.html#utils.plot_snr_per_channel">[docs]</a>
<span class="k">def</span> <span class="nf">plot_snr_per_channel</span><span class="p">(</span><span class="n">data_dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plots the Signal-to-Noise Ratio (SNR) for each channel as a bar plot.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - data_dict: dict</span>
<span class="sd">        Dictionary where keys are sample identifiers and values are 2D NumPy arrays</span>
<span class="sd">        representing chromatographic data (retention times as rows, m/z channels as columns).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">matplotlib</span>
    <span class="n">matplotlib</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;TkAgg&#39;</span><span class="p">)</span>

    <span class="c1"># Convert data dictionary to an array (num_samples, num_timepoints, num_channels)</span>
    <span class="n">valid_channels_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">data_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>  <span class="c1"># Shape: (num_samples, num_timepoints, num_channels)</span>

    <span class="c1"># Compute the mean and standard deviation across timepoints and samples for each channel</span>
    <span class="n">mean_signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">valid_channels_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># Shape: (num_channels,)</span>
    <span class="n">std_noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">valid_channels_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># Shape: (num_channels,)</span>

    <span class="c1"># Compute Signal-to-Noise Ratio (SNR) for each channel (avoid division by zero)</span>
    <span class="n">snr_values</span> <span class="o">=</span> <span class="n">mean_signal</span> <span class="o">/</span> <span class="p">(</span><span class="n">std_noise</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">)</span>

    <span class="c1"># Plot SNR per channel</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">snr_values</span><span class="p">)),</span> <span class="n">snr_values</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Channel Index&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Signal-to-Noise Ratio (SNR)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;SNR for Each Channel&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


    <span class="c1"># Example usage:</span>
    <span class="c1"># plot_snr_per_channel(data_dict)</span>


<span class="c1"># def rename_directories(directory_path):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Renames directories in the specified path according to the transformation rules:</span>
<span class="c1">#       - Remove &#39;ML&#39; prefix</span>
<span class="c1">#       - Replace &#39;Ester-&#39; with &#39;Est&#39;</span>
<span class="c1">#       - Keep the numeric part after &#39;ML&#39; and move it after &#39;Est&#39;</span>
<span class="c1">#       - Replace &#39;_&#39; with &#39;-&#39; in the remaining part of the name</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     for dir_name in os.listdir(directory_path):</span>
<span class="c1">#         old_path = os.path.join(directory_path, dir_name)</span>
<span class="c1">#</span>
<span class="c1">#         # Ensure it&#39;s a directory before renaming</span>
<span class="c1">#         if os.path.isdir(old_path) and dir_name.startswith(&quot;ML&quot;) and &quot;Ester-&quot; in dir_name:</span>
<span class="c1">#             # Extract the numeric part after &#39;ML&#39;</span>
<span class="c1">#             parts = dir_name.split(&#39;_&#39;)</span>
<span class="c1">#             first_part = parts[0]  # ML23_Ester-CSA9</span>
<span class="c1">#             rest = &#39;_&#39;.join(parts[1:])  # 2.D</span>
<span class="c1">#</span>
<span class="c1">#             # Remove &#39;ML&#39; prefix and extract the numeric value</span>
<span class="c1">#             ml_part, ester_part = dir_name.split(&quot;_Ester-&quot;)</span>
<span class="c1">#             number = ml_part.replace(&quot;ML&quot;, &quot;&quot;, 1)</span>
<span class="c1">#</span>
<span class="c1">#             # Construct the new name</span>
<span class="c1">#             new_name = f&quot;Est{number}{ester_part}&quot;.replace(&quot;_&quot;, &quot;-&quot;)</span>
<span class="c1">#</span>
<span class="c1">#             new_path = os.path.join(directory_path, new_name)</span>
<span class="c1">#</span>
<span class="c1">#             try:</span>
<span class="c1">#                 os.rename(old_path, new_path)</span>
<span class="c1">#                 print(f&quot;Renamed: {dir_name} -&gt; {new_name}&quot;)</span>
<span class="c1">#             except Exception as e:</span>
<span class="c1">#                 print(f&quot;Error renaming {dir_name}: {e}&quot;)</span>


<div class="viewcode-block" id="rename_directories">
<a class="viewcode-back" href="../utils.html#utils.rename_directories">[docs]</a>
<span class="k">def</span> <span class="nf">rename_directories</span><span class="p">(</span><span class="n">directory_path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Renames directories in the specified path according to the transformation rules:</span>
<span class="sd">      - Remove &#39;ML_&#39; prefix</span>
<span class="sd">      - Extract the numeric part after &#39;ML_&#39; and use it as the year (e.g., ML_MA1_3.D -&gt; Est21MA1-3.D)</span>
<span class="sd">      - Replace &#39;_&#39; with &#39;-&#39; in the remaining part of the name</span>
<span class="sd">      - If there is no &#39;_number&#39; before &#39;.D&#39;, add &#39;_1&#39; before &#39;.D&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">dir_name</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">directory_path</span><span class="p">):</span>
        <span class="n">old_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">directory_path</span><span class="p">,</span> <span class="n">dir_name</span><span class="p">)</span>

        <span class="c1"># Ensure it&#39;s a directory before renaming</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">old_path</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dir_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;ML_&quot;</span><span class="p">):</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="n">dir_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Extract the numeric part (assuming it&#39;s a year reference)</span>
                <span class="n">number</span> <span class="o">=</span> <span class="s2">&quot;21&quot;</span>  <span class="c1"># Assuming &#39;21&#39; is the correct year reference</span>

                <span class="c1"># Check if there is a &#39;_number&#39; before &#39;.D&#39;</span>
                <span class="n">base_name</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;_\d+(?=\.D$)&#39;</span><span class="p">,</span> <span class="n">base_name</span><span class="p">):</span>
                    <span class="n">base_name</span> <span class="o">=</span> <span class="n">base_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.D&quot;</span><span class="p">,</span> <span class="s2">&quot;_1.D&quot;</span><span class="p">)</span>

                <span class="c1"># Construct the new name</span>
                <span class="n">new_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Est</span><span class="si">{</span><span class="n">number</span><span class="si">}{</span><span class="n">base_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">)</span>
                <span class="n">new_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">directory_path</span><span class="p">,</span> <span class="n">new_name</span><span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">old_path</span><span class="p">,</span> <span class="n">new_path</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Renamed: </span><span class="si">{</span><span class="n">dir_name</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">new_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error renaming </span><span class="si">{</span><span class="n">dir_name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="join_datasets">
<a class="viewcode-back" href="../utils.html#utils.join_datasets">[docs]</a>
<span class="k">def</span> <span class="nf">join_datasets</span><span class="p">(</span><span class="n">selected_datasets</span><span class="p">,</span> <span class="n">data_directories</span><span class="p">,</span> <span class="n">n_decimation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Joins multiple datasets based on the given indices.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        dataset_indices (list of str): List of dataset names to join (e.g., [&quot;press_2022&quot;, &quot;merlot_2021&quot;]).</span>
<span class="sd">        data_directories (dict): Dictionary mapping dataset names to their directories.</span>
<span class="sd">        n_decimation (int): Decimation factor for reducing data size.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">merged_data</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">merged_origins</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">dataset_dicts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">dataset_origins_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">row_start</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Define row start</span>
    <span class="n">first_dataset</span> <span class="o">=</span> <span class="n">selected_datasets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Use the first dataset to determine column indices</span>
    <span class="n">first_directory</span> <span class="o">=</span> <span class="n">data_directories</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">first_dataset</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">first_directory</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Dataset </span><span class="si">{</span><span class="n">first_dataset</span><span class="si">}</span><span class="s2"> does not have a corresponding directory.&quot;</span><span class="p">)</span>

    <span class="n">row_end_1</span><span class="p">,</span> <span class="n">fc_idx_1</span><span class="p">,</span> <span class="n">lc_idx_1</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">find_data_margins_in_csv</span><span class="p">(</span><span class="n">first_directory</span><span class="p">)</span>
    <span class="n">column_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">fc_idx_1</span><span class="p">,</span> <span class="n">lc_idx_1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Load and process each selected dataset</span>
    <span class="k">for</span> <span class="n">dataset_name</span> <span class="ow">in</span> <span class="n">selected_datasets</span><span class="p">:</span>
        <span class="n">directory</span> <span class="o">=</span> <span class="n">data_directories</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dataset_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">directory</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Dataset </span><span class="si">{</span><span class="n">dataset_name</span><span class="si">}</span><span class="s2"> does not have a corresponding directory.&quot;</span><span class="p">)</span>

        <span class="n">row_end</span><span class="p">,</span> <span class="n">fc_idx</span><span class="p">,</span> <span class="n">lc_idx</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">find_data_margins_in_csv</span><span class="p">(</span><span class="n">directory</span><span class="p">)</span>

        <span class="c1"># Ensure column indices match</span>
        <span class="k">assert</span> <span class="n">fc_idx</span> <span class="o">==</span> <span class="n">fc_idx_1</span> <span class="ow">and</span> <span class="n">lc_idx</span> <span class="o">==</span> <span class="n">lc_idx_1</span><span class="p">,</span> <span class="s2">&quot;Mismatch in column indices between datasets.&quot;</span>

        <span class="n">data_dict</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_ms_csv_data_from_directories</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">column_indices</span><span class="p">,</span> <span class="n">row_start</span><span class="p">,</span> <span class="n">row_end</span><span class="p">)</span>
        <span class="n">dataset_origins</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">dataset_name</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">data_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>

        <span class="n">dataset_dicts</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">data_dict</span><span class="p">,</span> <span class="s1">&#39;origins&#39;</span><span class="p">:</span> <span class="n">dataset_origins</span><span class="p">})</span>

    <span class="c1"># Determine the minimum sample length across all datasets</span>
    <span class="n">min_length</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
        <span class="nb">min</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">array</span> <span class="ow">in</span> <span class="n">dataset_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="k">for</span> <span class="n">dataset_dict</span> <span class="ow">in</span> <span class="n">dataset_dicts</span>
    <span class="p">)</span>

    <span class="c1"># Trim and decimate datasets</span>
    <span class="k">for</span> <span class="n">dataset_dict</span> <span class="ow">in</span> <span class="n">dataset_dicts</span><span class="p">:</span>
        <span class="n">dataset_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">array</span><span class="p">[:</span><span class="n">min_length</span><span class="p">,</span> <span class="p">:]</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">array</span> <span class="ow">in</span> <span class="n">dataset_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">dataset_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">matrix</span><span class="p">[::</span><span class="n">n_decimation</span><span class="p">,</span> <span class="p">:]</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">matrix</span> <span class="ow">in</span> <span class="n">dataset_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">dataset_origins_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dataset_dict</span><span class="p">[</span><span class="s1">&#39;origins&#39;</span><span class="p">])</span>

    <span class="c1"># Merge datasets</span>
    <span class="k">for</span> <span class="n">dataset_dict</span> <span class="ow">in</span> <span class="n">dataset_dicts</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dataset_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">merged_data</span><span class="p">:</span>
                <span class="n">merged_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataset_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span>
                <span class="n">merged_origins</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataset_dict</span><span class="p">[</span><span class="s1">&#39;origins&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">merged_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">merged_data</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">dataset_dict</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">merged_data</span><span class="p">,</span> <span class="n">merged_origins</span></div>



<div class="viewcode-block" id="compute_pairwise_pearson">
<a class="viewcode-back" href="../utils.html#utils.compute_pairwise_pearson">[docs]</a>
<span class="k">def</span> <span class="nf">compute_pairwise_pearson</span><span class="p">(</span><span class="n">chrom_dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute pairwise Pearson correlation coefficients between chromatograms.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    chrom_dict : dict</span>
<span class="sd">        Dictionary with keys as sample names and values as 1D NumPy arrays (chromatograms).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pairwise_results : list of tuples</span>
<span class="sd">        Each tuple contains (sample1, sample2, correlation).</span>
<span class="sd">    mean_corr : float</span>
<span class="sd">        Mean Pearson correlation coefficient across all unique pairs.</span>
<span class="sd">    std_corr : float</span>
<span class="sd">        Standard deviation of the Pearson correlation coefficients.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">pairwise_results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">correlations</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Iterate through all unique pairs of samples</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">c1</span><span class="p">),</span> <span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="n">chrom_dict</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="mi">2</span><span class="p">):</span>
        <span class="c1"># Ensure they are the same length</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">c2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Chromatograms </span><span class="si">{</span><span class="n">s1</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">s2</span><span class="si">}</span><span class="s2"> have different lengths.&quot;</span><span class="p">)</span>

        <span class="n">corr</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">pearsonr</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span>
        <span class="n">pairwise_results</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">corr</span><span class="p">))</span>
        <span class="n">correlations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">corr</span><span class="p">)</span>

    <span class="n">mean_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">correlations</span><span class="p">)</span>
    <span class="n">std_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">correlations</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pairwise_results</span><span class="p">,</span> <span class="n">mean_corr</span><span class="p">,</span> <span class="n">std_corr</span></div>



<div class="viewcode-block" id="average_confusion_matrices_ignore_empty_rows">
<a class="viewcode-back" href="../utils.html#utils.average_confusion_matrices_ignore_empty_rows">[docs]</a>
<span class="k">def</span> <span class="nf">average_confusion_matrices_ignore_empty_rows</span><span class="p">(</span><span class="n">confusion_matrices</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Averages a list of confusion matrices row-wise, ignoring zero-sum rows in each matrix.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    confusion_matrices : list of np.ndarray</span>
<span class="sd">        List of raw (unnormalized) confusion matrices of the same shape.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        A row-normalized confusion matrix where each row is averaged over non-zero rows only.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">confusion_matrices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">confusion_matrices</span><span class="p">)</span>
    <span class="n">num_classes</span> <span class="o">=</span> <span class="n">confusion_matrices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">mean_cm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_classes</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_classes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">cm</span> <span class="ow">in</span> <span class="n">confusion_matrices</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_classes</span><span class="p">):</span>
            <span class="n">row_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cm</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">row_sum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mean_cm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Avoid division by zero by skipping zero-count rows</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_classes</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mean_cm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="c1"># Normalize row-wise</span>
    <span class="n">row_sums</span> <span class="o">=</span> <span class="n">mean_cm</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">normalized_mean_cm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">mean_cm</span><span class="p">,</span> <span class="n">row_sums</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">row_sums</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">normalized_mean_cm</span></div>


<div class="viewcode-block" id="create_dir_of_samples_from_champagnes">
<a class="viewcode-back" href="../utils.html#utils.create_dir_of_samples_from_champagnes">[docs]</a>
<span class="k">def</span> <span class="nf">create_dir_of_samples_from_champagnes</span><span class="p">(</span><span class="n">input_csv_path</span><span class="p">,</span> <span class="n">output_root</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">use_cache</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; Reading raw CSV: </span><span class="si">{</span><span class="n">input_csv_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">raw_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">input_csv_path</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="c1"># Use second row as header (row index 1), and keep the rest as data</span>
    <span class="n">sample_names</span> <span class="o">=</span> <span class="n">raw_df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># row 1 has names</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">raw_df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>    <span class="c1"># skip rows 0 and 1</span>
    <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">sample_names</span>

    <span class="n">sample_counts</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Process columns in pairs (Ret. Time, TIC)</span>
    <span class="n">col_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">col_names</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">sample_name</span> <span class="o">=</span> <span class="n">col_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">rt_col</span> <span class="o">=</span> <span class="n">col_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">tic_col</span> <span class="o">=</span> <span class="n">col_names</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Update count for suffix</span>
        <span class="n">sample_counts</span><span class="p">[</span><span class="n">sample_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">sample_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sample_name</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">suffix</span> <span class="o">=</span> <span class="n">sample_counts</span><span class="p">[</span><span class="n">sample_name</span><span class="p">]</span>

        <span class="n">full_sample_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">sample_name</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">dir_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">full_sample_name</span><span class="si">}</span><span class="s2">.D&quot;</span>
        <span class="n">dir_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">input_csv_path</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dir_name</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">dir_path</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Extract and rename</span>
        <span class="n">sub_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">sub_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Ret. Time&quot;</span><span class="p">,</span> <span class="s2">&quot;TIC&quot;</span><span class="p">]</span>

        <span class="c1"># Save</span>
        <span class="n">output_csv_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dir_path</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">full_sample_name</span><span class="si">}</span><span class="s2">.csv&quot;</span><span class="p">)</span>
        <span class="n">sub_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">output_csv_path</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; Saved: </span><span class="si">{</span><span class="n">output_csv_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; All samples extracted.&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="get_custom_order_for_pinot_noir_region">
<a class="viewcode-back" href="../utils.html#utils.get_custom_order_for_pinot_noir_region">[docs]</a>
<span class="k">def</span> <span class="nf">get_custom_order_for_pinot_noir_region</span><span class="p">(</span><span class="n">region</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a custom label order for confusion matrix based on the specified region level.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        region (str): One of &#39;winery&#39;, &#39;origin&#39;, &#39;country&#39;, &#39;continent&#39;</span>

<span class="sd">    Returns:</span>
<span class="sd">        list or None: Custom ordering of labels, or None if no custom order is needed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">region</span> <span class="o">==</span> <span class="s1">&#39;winery&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;Q&#39;</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="s1">&#39;J&#39;</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">region</span> <span class="o">==</span> <span class="s1">&#39;origin&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;Beaune&#39;</span><span class="p">,</span> <span class="s1">&#39;Alsace&#39;</span><span class="p">,</span> <span class="s1">&#39;Neuchatel&#39;</span><span class="p">,</span> <span class="s1">&#39;Genve&#39;</span><span class="p">,</span> <span class="s1">&#39;Valais&#39;</span><span class="p">,</span> <span class="s1">&#39;Californie&#39;</span><span class="p">,</span> <span class="s1">&#39;Oregon&#39;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">region</span> <span class="o">==</span> <span class="s1">&#39;country&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;France&#39;</span><span class="p">,</span> <span class="s1">&#39;Switzerland&#39;</span><span class="p">,</span> <span class="s1">&#39;US&#39;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">region</span> <span class="o">==</span> <span class="s1">&#39;continent&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;Europe&#39;</span><span class="p">,</span> <span class="s1">&#39;America&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="infer_wine_kind">
<a class="viewcode-back" href="../utils.html#utils.infer_wine_kind">[docs]</a>
<span class="k">def</span> <span class="nf">infer_wine_kind</span><span class="p">(</span><span class="n">selected_datasets</span><span class="p">,</span> <span class="n">dataset_directories</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Infers the wine kind (&#39;pinot_noir&#39;, &#39;press&#39;, or &#39;champagne&#39;) from the dataset paths.</span>
<span class="sd">    Ensures all selected datasets belong to the same wine kind.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wine_kind</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">selected_datasets</span><span class="p">:</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">dataset_directories</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="k">if</span> <span class="s2">&quot;pinot_noir&quot;</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="s2">&quot;pinot_noir&quot;</span>
        <span class="k">elif</span> <span class="s2">&quot;press_wines&quot;</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="s2">&quot;press&quot;</span>
        <span class="k">elif</span> <span class="s2">&quot;champagne&quot;</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="s2">&quot;champagne&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not determine wine_kind from dataset path: </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">wine_kind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wine_kind</span> <span class="o">=</span> <span class="n">kind</span>
        <span class="k">elif</span> <span class="n">wine_kind</span> <span class="o">!=</span> <span class="n">kind</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Selected datasets include mixed wine kinds (&#39;</span><span class="si">{</span><span class="n">wine_kind</span><span class="si">}</span><span class="s2">&#39; and &#39;</span><span class="si">{</span><span class="n">kind</span><span class="si">}</span><span class="s2">&#39;). &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Please use datasets from the same category.&quot;</span>
            <span class="p">)</span>

    <span class="k">return</span> <span class="n">wine_kind</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Wine Analysis Library</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../pinot_noir.html">Pinot Noir Classification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../press_wines.html">Press Wines Classification</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2025, Luis Gomez Camara.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>