<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>classification &#8212; Wine Analysis Library 0.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=4f649999" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=cb25574f" />
    <script src="../_static/documentation_options.js?v=01f34227"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for classification</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pynndescent.optimal_transport</span> <span class="kn">import</span> <span class="n">total_cost</span>
<span class="kn">from</span> <span class="nn">sklearn.discriminant_analysis</span> <span class="kn">import</span> <span class="n">LinearDiscriminantAnalysis</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span><span class="p">,</span> <span class="n">Perceptron</span><span class="p">,</span> <span class="n">RidgeClassifier</span><span class="p">,</span> <span class="n">PassiveAggressiveClassifier</span><span class="p">,</span> <span class="n">SGDClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">RandomForestClassifier</span><span class="p">,</span> <span class="n">GradientBoostingClassifier</span><span class="p">,</span> <span class="n">HistGradientBoostingClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">StratifiedKFold</span><span class="p">,</span> <span class="n">BaseCrossValidator</span>
<span class="kn">from</span> <span class="nn">sklearn.utils</span> <span class="kn">import</span> <span class="n">resample</span>
<span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ProcessPoolExecutor</span>
<span class="kn">from</span> <span class="nn">sklearn.feature_selection</span> <span class="kn">import</span> <span class="n">mutual_info_classif</span>

<span class="kn">from</span> <span class="nn">gcmswine</span> <span class="kn">import</span> <span class="n">utils</span>
<span class="kn">from</span> <span class="nn">gcmswine.dimensionality_reduction</span> <span class="kn">import</span> <span class="n">DimensionalityReducer</span>
<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>
<span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>
<span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.tree</span> <span class="kn">import</span> <span class="n">DecisionTreeClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.naive_bayes</span> <span class="kn">import</span> <span class="n">GaussianNB</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">precision_score</span><span class="p">,</span> <span class="n">recall_score</span><span class="p">,</span> <span class="n">f1_score</span><span class="p">,</span> <span class="n">confusion_matrix</span><span class="p">,</span> <span class="n">balanced_accuracy_score</span>
<span class="kn">from</span> <span class="nn">sklearn.utils.class_weight</span> <span class="kn">import</span> <span class="n">compute_sample_weight</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">RidgeClassifierCV</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GroupShuffleSplit</span><span class="p">,</span> <span class="n">GridSearchCV</span><span class="p">,</span> <span class="n">ShuffleSplit</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">LabelEncoder</span><span class="p">,</span> <span class="n">StandardScaler</span><span class="p">,</span> <span class="n">MinMaxScaler</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span><span class="p">,</span> <span class="n">StratifiedKFold</span><span class="p">,</span> <span class="n">LeaveOneOut</span><span class="p">,</span> <span class="n">LeavePOut</span>

<span class="kn">from</span> <span class="nn">gcmswine.utils</span> <span class="kn">import</span> <span class="n">find_first_and_last_position</span><span class="p">,</span> <span class="n">normalize_dict</span><span class="p">,</span> <span class="n">normalize_data</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="nn">nn</span>
<span class="kn">import</span> <span class="nn">torch.optim</span> <span class="k">as</span> <span class="nn">optim</span>
<span class="kn">from</span> <span class="nn">torch.nn.parallel</span> <span class="kn">import</span> <span class="n">DataParallel</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">accuracy_score</span>
<span class="kn">from</span> <span class="nn">torch.utils.data</span> <span class="kn">import</span> <span class="n">DataLoader</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">,</span> <span class="n">random_split</span><span class="p">,</span> <span class="n">TensorDataset</span>
<span class="kn">from</span> <span class="nn">torchvision</span> <span class="kn">import</span> <span class="n">models</span>
<span class="kn">from</span> <span class="nn">torchvision</span> <span class="kn">import</span> <span class="n">transforms</span>
<span class="kn">import</span> <span class="nn">torch.nn.functional</span> <span class="k">as</span> <span class="nn">F</span>

<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>  <span class="c1"># For the progress bar</span>
<span class="kn">from</span> <span class="nn">skopt</span> <span class="kn">import</span> <span class="n">gp_minimize</span>
<span class="kn">from</span> <span class="nn">skopt.space</span> <span class="kn">import</span> <span class="n">Real</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">Categorical</span>
<span class="kn">from</span> <span class="nn">skopt.utils</span> <span class="kn">import</span> <span class="n">use_named_args</span>

<span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span><span class="p">,</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">csv</span>

<div class="viewcode-block" id="leave_one_sample_per_class_split">
<a class="viewcode-back" href="../classification.html#classification.leave_one_sample_per_class_split">[docs]</a>
<span class="k">def</span> <span class="nf">leave_one_sample_per_class_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_composite_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split dataset by selecting one sample per class (plus its duplicates if composite labels) for the test set.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X : array-like</span>
<span class="sd">        Feature matrix (not used, kept for compatibility).</span>
<span class="sd">    y : array-like</span>
<span class="sd">        Labels (composite labels or simple class labels).</span>
<span class="sd">    random_state : int, optional</span>
<span class="sd">        Random seed for reproducibility.</span>
<span class="sd">    is_composite_labels : bool, optional</span>
<span class="sd">        Whether y are composite labels like &#39;A1&#39;, &#39;B2&#39;. If False, assumes simple class labels.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    train_indices : np.ndarray</span>
<span class="sd">        Indices for training set.</span>
<span class="sd">    test_indices : np.ndarray</span>
<span class="sd">        Indices for test set.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
    <span class="kn">import</span> <span class="nn">re</span>

    <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">is_composite_labels</span><span class="p">:</span>
        <span class="c1"># Group indices by full sample labels (for composite cases)</span>
        <span class="n">sample_to_indices</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="n">sample_to_indices</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="c1"># Group sample labels by class (A, B, C)</span>
        <span class="n">class_to_samples</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">get_class_from_label</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Extract the class (first letter) from composite label like &#39;A1&#39;.&quot;&quot;&quot;</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;([A-Z])&#39;</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">match</span> <span class="k">else</span> <span class="n">label</span>

        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">sample_to_indices</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">class_label</span> <span class="o">=</span> <span class="n">get_class_from_label</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="n">class_to_samples</span><span class="p">[</span><span class="n">class_label</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

        <span class="c1"># Choose one sample label per class</span>
        <span class="n">test_sample_labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">class_label</span><span class="p">,</span> <span class="n">samples</span> <span class="ow">in</span> <span class="n">class_to_samples</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">chosen_sample</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
            <span class="n">test_sample_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chosen_sample</span><span class="p">)</span>

        <span class="c1"># Expand into indices</span>
        <span class="n">test_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">test_sample_labels</span><span class="p">:</span>
            <span class="n">test_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sample_to_indices</span><span class="p">[</span><span class="n">label</span><span class="p">])</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Simple class labels (e.g., &#39;Beaune&#39;, &#39;Alsace&#39;, &#39;C&#39;, &#39;D&#39;)</span>
        <span class="n">class_to_indices</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="n">class_to_indices</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="c1"># Pick one random index per class</span>
        <span class="n">test_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">class_label</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">class_to_indices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">chosen_idx</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
            <span class="n">test_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chosen_idx</span><span class="p">)</span>

    <span class="n">test_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">test_indices</span><span class="p">)</span>
    <span class="n">all_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
    <span class="n">train_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">all_indices</span><span class="p">,</span> <span class="n">test_indices</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">train_indices</span><span class="p">,</span> <span class="n">test_indices</span></div>


<div class="viewcode-block" id="CustomDataParallel">
<a class="viewcode-back" href="../classification.html#classification.CustomDataParallel">[docs]</a>
<span class="k">class</span> <span class="nc">CustomDataParallel</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">DataParallel</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getattr__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">module</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="Classifier">
<a class="viewcode-back" href="../classification.html#classification.Classifier">[docs]</a>
<span class="k">class</span> <span class="nc">Classifier</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A classifier class that wraps around various machine learning algorithms</span>
<span class="sd">    provided by scikit-learn. This class allows for easy switching between different classifiers</span>
<span class="sd">    and provides methods for training and evaluating the models using cross-validation or separate datasets.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : numpy.ndarray</span>
<span class="sd">        The input data to be used for training and evaluation.</span>
<span class="sd">    labels : numpy.ndarray</span>
<span class="sd">        The labels corresponding to the input data.</span>
<span class="sd">    classifier_type : str, optional</span>
<span class="sd">        The type of classifier to use. Default is &#39;LDA&#39;.</span>
<span class="sd">        Supported values:</span>
<span class="sd">        - &#39;LDA&#39;: Linear Discriminant Analysis</span>
<span class="sd">        - &#39;LR&#39;: Logistic Regression</span>
<span class="sd">        - &#39;RFC&#39;: Random Forest Classifier</span>
<span class="sd">        - &#39;PAC&#39;: Passive Aggressive Classifier</span>
<span class="sd">        - &#39;PER&#39;: Perceptron</span>
<span class="sd">        - &#39;RGC&#39;: Ridge Classifier</span>
<span class="sd">        - &#39;SGD&#39;: Stochastic Gradient Descent Classifier</span>
<span class="sd">        - &#39;SVM&#39;: Support Vector Machine</span>
<span class="sd">        - &#39;KNN&#39;: K-Nearest Neighbors</span>
<span class="sd">        - &#39;DTC&#39;: Decision Tree Classifier</span>
<span class="sd">        - &#39;GNB&#39;: Gaussian Naive Bayes</span>
<span class="sd">        - &#39;GBC&#39;: Gradient Boosting Classifier</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">classifier_type</span><span class="o">=</span><span class="s1">&#39;LDA&#39;</span><span class="p">,</span> <span class="n">wine_kind</span><span class="o">=</span><span class="s1">&#39;bordeaux&#39;</span><span class="p">,</span> <span class="n">window_size</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2500</span><span class="p">,</span>
                 <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">year_labels</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dataset_origins</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span> <span class="o">=</span> <span class="n">window_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stride</span> <span class="o">=</span> <span class="n">stride</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wine_kind</span> <span class="o">=</span> <span class="n">wine_kind</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="s2">&quot;cuda&quot;</span> <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">()</span> <span class="k">else</span> <span class="s2">&quot;cpu&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_classifier</span><span class="p">(</span><span class="n">classifier_type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">year_labels</span> <span class="o">=</span> <span class="n">year_labels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset_origins</span> <span class="o">=</span> <span class="n">dataset_origins</span>

<div class="viewcode-block" id="Classifier.shuffle_split_without_splitting_duplicates">
<a class="viewcode-back" href="../classification.html#classification.Classifier.shuffle_split_without_splitting_duplicates">[docs]</a>
    <span class="k">def</span> <span class="nf">shuffle_split_without_splitting_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                   <span class="n">group_duplicates</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                   <span class="n">dataset_origins</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform ShuffleSplit on samples while ensuring:</span>
<span class="sd">        - Duplicates of the same sample (including dataset origin) are kept together (if enabled).</span>
<span class="sd">        - Each class is represented in the test set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">group_duplicates</span><span class="p">:</span>
            <span class="n">unique_samples</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># {(origin, label): [indices]}</span>
            <span class="n">class_samples</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>  <span class="c1"># {class_label: [(origin, label), ...]}</span>

            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
                <span class="n">origin</span> <span class="o">=</span> <span class="n">dataset_origins</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
                <span class="n">unique_samples</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                <span class="n">class_label</span> <span class="o">=</span> <span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># e.g. &#39;A&#39; from &#39;A1&#39;</span>
                <span class="n">class_samples</span><span class="p">[</span><span class="n">class_label</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

            <span class="n">sample_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">unique_samples</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">rng</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">sample_keys</span><span class="p">)</span>

            <span class="c1"># Step 1: Randomly select test samples</span>
            <span class="n">num_test_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sample_keys</span><span class="p">)</span> <span class="o">*</span> <span class="n">test_size</span><span class="p">)</span>
            <span class="n">test_sample_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">sample_keys</span><span class="p">[:</span><span class="n">num_test_samples</span><span class="p">])</span>

            <span class="c1"># Step 2: Ensure all class labels are represented</span>
            <span class="n">test_classes</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">test_sample_keys</span><span class="p">}</span>  <span class="c1"># e.g. &#39;A&#39; from (&#39;merlot&#39;, &#39;A1&#39;)</span>
            <span class="n">missing_classes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">cls</span> <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">class_samples</span> <span class="k">if</span> <span class="bp">cls</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">test_classes</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">class_label</span> <span class="ow">in</span> <span class="n">missing_classes</span><span class="p">:</span>
                <span class="n">candidate_keys</span> <span class="o">=</span> <span class="n">class_samples</span><span class="p">[</span><span class="n">class_label</span><span class="p">]</span>
                <span class="n">additional_key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">candidate_keys</span><span class="p">))</span>
                <span class="n">test_sample_keys</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">additional_key</span><span class="p">)</span>

            <span class="c1"># Step 3: Translate keys into train/test indices</span>
            <span class="n">test_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">test_sample_keys</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">unique_samples</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span>
            <span class="n">train_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">sample_keys</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">test_sample_keys</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span>
                             <span class="n">unique_samples</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Fallback: treat each instance independently</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
            <span class="n">rng</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
            <span class="n">num_test_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">*</span> <span class="n">test_size</span><span class="p">)</span>
            <span class="n">test_indices</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[:</span><span class="n">num_test_samples</span><span class="p">]</span>
            <span class="n">train_indices</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">num_test_samples</span><span class="p">:]</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">train_indices</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">test_indices</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_get_classifier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">classifier_type</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the classifier object based on the classifier type.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        classifier_type : str</span>
<span class="sd">            The type of classifier to initialize. Supported types include &#39;LDA&#39;, &#39;LR&#39;, &#39;RFC&#39;,</span>
<span class="sd">            &#39;PAC&#39;, &#39;PER&#39;, &#39;RGC&#39;, &#39;SGD&#39;, &#39;SVM&#39;, &#39;KNN&#39;, &#39;DTC&#39;, &#39;GNB&#39;, and &#39;GBC&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sklearn.base.BaseEstimator</span>
<span class="sd">            An instance of the selected scikit-learn classifier.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Classifier: </span><span class="si">{</span><span class="n">classifier_type</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">classifier_type</span> <span class="o">==</span> <span class="s1">&#39;LDA&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">LinearDiscriminantAnalysis</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">classifier_type</span> <span class="o">==</span> <span class="s1">&#39;LR&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">LogisticRegression</span><span class="p">(</span><span class="n">C</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">classifier_type</span> <span class="o">==</span> <span class="s1">&#39;RFC&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">RandomForestClassifier</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">classifier_type</span> <span class="o">==</span> <span class="s1">&#39;PAC&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">PassiveAggressiveClassifier</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">classifier_type</span> <span class="o">==</span> <span class="s1">&#39;PER&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Perceptron</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">classifier_type</span> <span class="o">==</span> <span class="s1">&#39;RGC&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">RidgeClassifier</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">classifier_type</span> <span class="o">==</span> <span class="s1">&#39;SGD&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SGDClassifier</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">classifier_type</span> <span class="o">==</span> <span class="s1">&#39;SVM&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s1">&#39;rbf&#39;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">classifier_type</span> <span class="o">==</span> <span class="s1">&#39;KNN&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">classifier_type</span> <span class="o">==</span> <span class="s1">&#39;DTC&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">DecisionTreeClassifier</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">classifier_type</span> <span class="o">==</span> <span class="s1">&#39;GNB&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">GaussianNB</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">classifier_type</span> <span class="o">==</span> <span class="s1">&#39;GBC&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">GradientBoostingClassifier</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">max_depth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">classifier_type</span> <span class="o">==</span> <span class="s1">&#39;HGBC&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">HistGradientBoostingClassifier</span><span class="p">(</span><span class="n">max_leaf_nodes</span><span class="o">=</span><span class="mi">31</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">max_bins</span><span class="o">=</span><span class="mi">128</span><span class="p">)</span>


<div class="viewcode-block" id="Classifier.train_and_evaluate_balanced">
<a class="viewcode-back" href="../classification.html#classification.Classifier.train_and_evaluate_balanced">[docs]</a>
    <span class="k">def</span> <span class="nf">train_and_evaluate_balanced</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_inner_repeats</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>
                                    <span class="n">test_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">scaler_type</span><span class="o">=</span><span class="s1">&#39;standard&#39;</span><span class="p">,</span>
                                    <span class="n">use_pca</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">vthresh</span><span class="o">=</span><span class="mf">0.97</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">print_results</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                                    <span class="n">test_on_discarded</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">LOOPC</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Train and evaluate the classifier using a train/test split followed by cross-validation on the training set.</span>
<span class="sd">        Evaluation metrics are averaged across multiple inner cross-validation repetitions.</span>

<span class="sd">        Depending on the value of `test_on_discarded`, either the inner validation set or the held-out test set</span>
<span class="sd">        is used to compute final metrics. Supports normalization, PCA, and custom confusion matrix ordering.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_inner_repeats : int, optional (default=50)</span>
<span class="sd">            Number of inner cross-validation folds or repetitions.</span>
<span class="sd">        random_seed : int, optional (default=42)</span>
<span class="sd">            Seed for reproducibility.</span>
<span class="sd">        test_size : float, optional (default=0.2)</span>
<span class="sd">            Fraction of data to hold out as a test set (only used when test_on_discarded=True).</span>
<span class="sd">        normalize : bool, optional (default=False)</span>
<span class="sd">            Whether to apply feature normalization (e.g., standard scaling).</span>
<span class="sd">        scaler_type : str, optional (default=&#39;standard&#39;)</span>
<span class="sd">            Type of scaler to use if normalization is enabled (&#39;standard&#39;, &#39;minmax&#39;, etc.).</span>
<span class="sd">        use_pca : bool, optional (default=False)</span>
<span class="sd">            Whether to apply PCA for dimensionality reduction.</span>
<span class="sd">        vthresh : float, optional (default=0.97)</span>
<span class="sd">            Proportion of variance to retain when applying PCA.</span>
<span class="sd">        region : str or None, optional (default=None)</span>
<span class="sd">            Custom region ordering for confusion matrix labels.</span>
<span class="sd">        print_results : bool, optional (default=True)</span>
<span class="sd">            Whether to print performance metrics to the console.</span>
<span class="sd">        n_jobs : int, optional (default=-1)</span>
<span class="sd">            Number of parallel jobs to use for cross-validation.</span>
<span class="sd">        test_on_discarded : bool, optional (default=False)</span>
<span class="sd">            If True, final evaluation is done on the held-out test set (outside CV).</span>
<span class="sd">            If False, metrics are computed on the inner cross-validation folds.</span>
<span class="sd">        LOOPC : bool, optional (default=True)</span>
<span class="sd">            If True, use Leave-One-Out-Per-Class strategy for cross-validation (i.e., select one full sample per class).</span>
<span class="sd">            If False, use standard cross-validation with grouped or stratified shuffle splits.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary containing average accuracy, precision, recall, F1-score, and normalized confusion matrix</span>
<span class="sd">            across all evaluation folds or test splits.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">StratifiedShuffleSplit</span>
        <span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">balanced_accuracy_score</span><span class="p">,</span> <span class="n">precision_score</span><span class="p">,</span> <span class="n">recall_score</span><span class="p">,</span> <span class="n">f1_score</span><span class="p">,</span> <span class="n">confusion_matrix</span>
        <span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>
        <span class="kn">from</span> <span class="nn">sklearn.utils.class_weight</span> <span class="kn">import</span> <span class="n">compute_sample_weight</span>

        <span class="k">class</span> <span class="nc">RepeatedLeaveOneSamplePerClassCV</span><span class="p">(</span><span class="n">BaseCrossValidator</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Custom cross-validator that randomly selects one sample per class as the test set,</span>
<span class="sd">            ensuring that all replicates of the same sample stay together, or selects individual</span>
<span class="sd">            samples if standard mode is chosen. Uses composite labels to preserve replicate information.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            n_repeats : int, optional (default=50)</span>
<span class="sd">                Number of repetitions.</span>
<span class="sd">            shuffle : bool, optional (default=True)</span>
<span class="sd">                Whether to shuffle the samples before splitting.</span>
<span class="sd">            random_state : int, optional (default=None)</span>
<span class="sd">                Seed for reproducibility.</span>
<span class="sd">            use_groups : bool, optional (default=True)</span>
<span class="sd">                If True, replicates of the same sample stay together (group-like behavior).</span>
<span class="sd">                If False, selects individual samples without considering replicates.</span>

<span class="sd">            Attributes</span>
<span class="sd">            ----------</span>
<span class="sd">            n_repeats : int</span>
<span class="sd">                Number of repetitions.</span>
<span class="sd">            shuffle : bool</span>
<span class="sd">                Whether to shuffle samples.</span>
<span class="sd">            random_state : int</span>
<span class="sd">                Random seed.</span>
<span class="sd">            use_groups : bool</span>
<span class="sd">                Determines whether to use group-like splitting or standard splitting.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_repeats</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_groups</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_repeats</span> <span class="o">=</span> <span class="n">n_repeats</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span> <span class="o">=</span> <span class="n">shuffle</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">use_groups</span> <span class="o">=</span> <span class="n">use_groups</span>

            <span class="k">def</span> <span class="nf">get_n_splits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">groups</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;Returns the number of splits.&quot;&quot;&quot;</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_repeats</span>

            <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Splits the dataset into training and test sets using either:</span>
<span class="sd">                - Group-like splitting (all replicates of the same sample stay together).</span>
<span class="sd">                - Standard splitting (individual samples are selected without considering replicates).</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                X : array-like, shape (n_samples, n_features)</span>
<span class="sd">                    Feature matrix or sample labels.</span>
<span class="sd">                y : array-like, shape (n_samples,)</span>
<span class="sd">                    Composite labels (e.g., &#39;A1&#39;, &#39;B9&#39;) that preserve replicate information.</span>

<span class="sd">                Yields</span>
<span class="sd">                ------</span>
<span class="sd">                train_indices : ndarray</span>
<span class="sd">                    Training indices.</span>
<span class="sd">                test_indices : ndarray</span>
<span class="sd">                    Test indices.</span>
<span class="sd">                &quot;&quot;&quot;</span>

                <span class="c1"># Step 1: Extract category from composite labels (e.g., &#39;A1&#39; -&gt; &#39;A&#39;)</span>
                <span class="k">def</span> <span class="nf">get_category</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
<span class="w">                    </span><span class="sd">&quot;&quot;&quot;Extracts the category (A, B, or C) from the composite label.&quot;&quot;&quot;</span>
                    <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;([A-C])\d+&#39;</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">match</span> <span class="k">else</span> <span class="n">label</span>  <span class="c1"># Fallback if no match</span>

                <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>

                <span class="c1">#  OPTION 1: Group-Like Splitting (use_groups=True)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_groups</span><span class="p">:</span>
                    <span class="c1"># Group indices by composite labels</span>
                    <span class="n">indices_by_sample</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
                        <span class="n">indices_by_sample</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

                    <span class="c1"># Generate splits</span>
                    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_repeats</span><span class="p">):</span>
                        <span class="n">test_indices</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">get_category</span><span class="p">,</span> <span class="n">y</span><span class="p">)):</span>
                            <span class="c1"># Select all samples that belong to the current category</span>
                            <span class="n">class_samples</span> <span class="o">=</span> <span class="p">[</span><span class="n">label</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">indices_by_sample</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span>
                                             <span class="n">get_category</span><span class="p">(</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="n">category</span><span class="p">]</span>

                            <span class="c1"># Randomly choose one sample</span>
                            <span class="n">chosen_sample</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">class_samples</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span> <span class="k">else</span> \
                            <span class="n">class_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                            <span class="c1"># Add all indices of the chosen sample to the test set</span>
                            <span class="n">test_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">indices_by_sample</span><span class="p">[</span><span class="n">chosen_sample</span><span class="p">])</span>

                        <span class="n">test_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">test_indices</span><span class="p">)</span>
                        <span class="n">train_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span> <span class="n">test_indices</span><span class="p">)</span>

                        <span class="k">yield</span> <span class="n">train_indices</span><span class="p">,</span> <span class="n">test_indices</span>

                <span class="c1">#  OPTION 2: Standard Splitting (use_groups=False)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Collect indices by category</span>
                    <span class="n">indices_by_category</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
                        <span class="n">category</span> <span class="o">=</span> <span class="n">get_category</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                        <span class="n">indices_by_category</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

                    <span class="c1"># Generate splits</span>
                    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_repeats</span><span class="p">):</span>
                        <span class="n">test_indices</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">category</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">indices_by_category</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="n">chosen</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span> <span class="k">else</span> <span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                            <span class="n">test_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">chosen</span><span class="p">)</span>

                        <span class="n">test_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">test_indices</span><span class="p">)</span>
                        <span class="n">train_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span> <span class="n">test_indices</span><span class="p">)</span>

                        <span class="k">yield</span> <span class="n">train_indices</span><span class="p">,</span> <span class="n">test_indices</span>

        <span class="k">def</span> <span class="nf">leave_one_sample_per_class_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_composite_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Split dataset by selecting one sample per class (plus its duplicates if composite labels) for the test set.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            X : array-like</span>
<span class="sd">                Feature matrix (not used, kept for compatibility).</span>
<span class="sd">            y : array-like</span>
<span class="sd">                Labels (composite labels or simple class labels).</span>
<span class="sd">            random_state : int, optional</span>
<span class="sd">                Random seed for reproducibility.</span>
<span class="sd">            is_composite_labels : bool, optional</span>
<span class="sd">                Whether y are composite labels like &#39;A1&#39;, &#39;B2&#39;. If False, assumes simple class labels.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            train_indices : np.ndarray</span>
<span class="sd">                Indices for training set.</span>
<span class="sd">            test_indices : np.ndarray</span>
<span class="sd">                Indices for test set.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
            <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
            <span class="kn">import</span> <span class="nn">re</span>

            <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">is_composite_labels</span><span class="p">:</span>
                <span class="c1"># Group indices by full sample labels (for composite cases)</span>
                <span class="n">sample_to_indices</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
                    <span class="n">sample_to_indices</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

                <span class="c1"># Group sample labels by class (A, B, C)</span>
                <span class="n">class_to_samples</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

                <span class="k">def</span> <span class="nf">get_class_from_label</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
<span class="w">                    </span><span class="sd">&quot;&quot;&quot;Extract the class (first letter) from composite label like &#39;A1&#39;.&quot;&quot;&quot;</span>
                    <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;([A-Z])&#39;</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">match</span> <span class="k">else</span> <span class="n">label</span>

                <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">sample_to_indices</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">class_label</span> <span class="o">=</span> <span class="n">get_class_from_label</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                    <span class="n">class_to_samples</span><span class="p">[</span><span class="n">class_label</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

                <span class="c1"># Choose one sample label per class</span>
                <span class="n">test_sample_labels</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">class_label</span><span class="p">,</span> <span class="n">samples</span> <span class="ow">in</span> <span class="n">class_to_samples</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">chosen_sample</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
                    <span class="n">test_sample_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chosen_sample</span><span class="p">)</span>

                <span class="c1"># Expand into indices</span>
                <span class="n">test_indices</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">test_sample_labels</span><span class="p">:</span>
                    <span class="n">test_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sample_to_indices</span><span class="p">[</span><span class="n">label</span><span class="p">])</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Simple class labels (e.g., &#39;Beaune&#39;, &#39;Alsace&#39;, &#39;C&#39;, &#39;D&#39;)</span>
                <span class="n">class_to_indices</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
                    <span class="n">class_to_indices</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

                <span class="c1"># Pick one random index per class</span>
                <span class="n">test_indices</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">class_label</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">class_to_indices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">chosen_idx</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
                    <span class="n">test_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chosen_idx</span><span class="p">)</span>

            <span class="n">test_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">test_indices</span><span class="p">)</span>
            <span class="n">all_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
            <span class="n">train_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">all_indices</span><span class="p">,</span> <span class="n">test_indices</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">train_indices</span><span class="p">,</span> <span class="n">test_indices</span>


            <span class="k">def</span> <span class="nf">get_class_from_label</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;Extract the class letter from a composite label like &#39;A1&#39;.&quot;&quot;&quot;</span>
                <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;([A-Z])&#39;</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">match</span> <span class="k">else</span> <span class="n">label</span>

            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">sample_to_indices</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">class_label</span> <span class="o">=</span> <span class="n">get_class_from_label</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                <span class="n">class_to_samples</span><span class="p">[</span><span class="n">class_label</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

            <span class="c1"># Select one sample label per class for test set</span>
            <span class="n">test_sample_labels</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">class_label</span><span class="p">,</span> <span class="n">samples</span> <span class="ow">in</span> <span class="n">class_to_samples</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">chosen_sample</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
                <span class="n">test_sample_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chosen_sample</span><span class="p">)</span>

            <span class="c1"># Expand to indices (all replicates of selected samples)</span>
            <span class="n">test_indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">test_sample_labels</span><span class="p">:</span>
                <span class="n">test_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sample_to_indices</span><span class="p">[</span><span class="n">label</span><span class="p">])</span>

            <span class="n">test_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">test_indices</span><span class="p">)</span>

            <span class="c1"># Train indices are all others</span>
            <span class="n">all_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
            <span class="n">train_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">all_indices</span><span class="p">,</span> <span class="n">test_indices</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">train_indices</span><span class="p">,</span> <span class="n">test_indices</span>


        <span class="k">def</span> <span class="nf">shuffle_split_without_splitting_duplicates</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">group_duplicates</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Perform ShuffleSplit on samples while ensuring that:</span>
<span class="sd">                - Duplicates of the same sample are kept together (if enabled).</span>
<span class="sd">                - Each class is represented in the test set.</span>

<span class="sd">            Args:</span>
<span class="sd">                X (array-like): Feature matrix or sample labels.</span>
<span class="sd">                y (array-like): Composite labels (e.g., [&#39;A1&#39;, &#39;A1&#39;, &#39;B2&#39;, &#39;B2&#39;]).</span>
<span class="sd">                test_size (float): Fraction of samples to include in the test set.</span>
<span class="sd">                random_state (int): Random seed for reproducibility.</span>
<span class="sd">                group_duplicates (bool): If True, duplicates of the same sample are kept together.</span>
<span class="sd">                                         If False, duplicates are treated independently.</span>

<span class="sd">            Returns:</span>
<span class="sd">                tuple: train_indices, test_indices (numpy arrays)</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

            <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">group_duplicates</span><span class="p">:</span>
                <span class="n">unique_samples</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># {sample_label: [indices]}</span>
                <span class="n">class_samples</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>  <span class="c1"># {class_label: [sample_label1, sample_label2, ...]}</span>

                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
                    <span class="n">unique_samples</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                    <span class="n">class_samples</span><span class="p">[</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>  <span class="c1"># Assuming class is the first character (e.g., &#39;A1&#39; -&gt; &#39;A&#39;)</span>

                <span class="n">sample_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">unique_samples</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="n">rng</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">sample_labels</span><span class="p">)</span>

                <span class="c1"># Step 1: Randomly select test samples</span>
                <span class="n">num_test_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sample_labels</span><span class="p">)</span> <span class="o">*</span> <span class="n">test_size</span><span class="p">)</span>
                <span class="n">test_sample_labels</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">sample_labels</span><span class="p">[:</span><span class="n">num_test_samples</span><span class="p">])</span>

                <span class="c1"># Step 2: Ensure each class is represented in the test set</span>
                <span class="n">test_classes</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">test_sample_labels</span><span class="p">}</span>
                <span class="n">missing_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">class_samples</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">test_classes</span><span class="p">]</span>

                <span class="c1"># Step 3: Force at least one sample from missing classes</span>
                <span class="k">for</span> <span class="n">class_label</span> <span class="ow">in</span> <span class="n">missing_classes</span><span class="p">:</span>
                    <span class="n">additional_sample</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">class_samples</span><span class="p">[</span><span class="n">class_label</span><span class="p">])</span>
                    <span class="n">test_sample_labels</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">additional_sample</span><span class="p">)</span>

                <span class="c1"># Step 4: Convert sample labels to index lists</span>
                <span class="n">test_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">test_sample_labels</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">unique_samples</span><span class="p">[</span><span class="n">label</span><span class="p">]]</span>
                <span class="n">train_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">sample_labels</span> <span class="k">if</span> <span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">test_sample_labels</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span>
                                 <span class="n">unique_samples</span><span class="p">[</span><span class="n">label</span><span class="p">]]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Treat each instance independently</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
                <span class="n">rng</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

                <span class="c1"># Calculate the number of test samples</span>
                <span class="n">num_test_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">*</span> <span class="n">test_size</span><span class="p">)</span>

                <span class="c1"># Split into train and test sets</span>
                <span class="n">test_indices</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[:</span><span class="n">num_test_samples</span><span class="p">]</span>
                <span class="n">train_indices</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">num_test_samples</span><span class="p">:]</span>

            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">train_indices</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">test_indices</span><span class="p">)</span>


        <span class="k">def</span> <span class="nf">extract_category_labels</span><span class="p">(</span><span class="n">composite_labels</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Convert composite labels (e.g., &#39;A1&#39;, &#39;B9&#39;, &#39;C2&#39;) to category labels (&#39;A&#39;, &#39;B&#39;, &#39;C&#39;).</span>

<span class="sd">            Args:</span>
<span class="sd">                composite_labels (array-like): List or array of composite labels.</span>

<span class="sd">            Returns:</span>
<span class="sd">                list: List of category labels.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;([A-C])&#39;</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;([A-C])&#39;</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span> <span class="k">else</span> <span class="n">label</span>
                    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">composite_labels</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">process_fold</span><span class="p">(</span><span class="n">inner_train_idx</span><span class="p">,</span> <span class="n">inner_val_idx</span><span class="p">,</span> <span class="n">X_train_full</span><span class="p">,</span> <span class="n">y_train_full</span><span class="p">,</span> <span class="n">normalize</span><span class="p">,</span> <span class="n">scaler_type</span><span class="p">,</span> <span class="n">use_pca</span><span class="p">,</span>
                         <span class="n">vthresh</span><span class="p">,</span> <span class="n">custom_order</span><span class="p">):</span>
            <span class="n">X_train</span> <span class="o">=</span> <span class="n">X_train_full</span><span class="p">[</span><span class="n">inner_train_idx</span><span class="p">]</span>
            <span class="n">y_train</span> <span class="o">=</span> <span class="n">extract_category_labels</span><span class="p">(</span><span class="n">y_train_full</span><span class="p">[</span><span class="n">inner_train_idx</span><span class="p">])</span>
            <span class="n">X_val</span> <span class="o">=</span> <span class="n">X_train_full</span><span class="p">[</span><span class="n">inner_val_idx</span><span class="p">]</span>
            <span class="n">y_val</span> <span class="o">=</span> <span class="n">extract_category_labels</span><span class="p">(</span><span class="n">y_train_full</span><span class="p">[</span><span class="n">inner_val_idx</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
                <span class="n">X_train</span><span class="p">,</span> <span class="n">scaler</span> <span class="o">=</span> <span class="n">normalize_data</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">scaler</span><span class="o">=</span><span class="n">scaler_type</span><span class="p">)</span>
                <span class="n">X_val</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_val</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">use_pca</span><span class="p">:</span>
                <span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">svd_solver</span><span class="o">=</span><span class="s1">&#39;randomized&#39;</span><span class="p">)</span>
                <span class="n">pca</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
                <span class="n">cumulative_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">explained_variance_ratio_</span><span class="p">)</span>
                <span class="n">n_components</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">cumulative_variance</span><span class="p">,</span> <span class="n">vthresh</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">n_components</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_components</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">y_train</span><span class="p">)))</span>
                <span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span> <span class="n">svd_solver</span><span class="o">=</span><span class="s1">&#39;randomized&#39;</span><span class="p">)</span>
                <span class="n">X_train</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
                <span class="n">X_val</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_val</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
            <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_val</span><span class="p">)</span>

            <span class="n">acc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_val</span><span class="p">,</span> <span class="n">y_val</span><span class="p">)</span>
            <span class="n">bal_acc</span> <span class="o">=</span> <span class="n">balanced_accuracy_score</span><span class="p">(</span><span class="n">y_val</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
            <span class="n">sw</span> <span class="o">=</span> <span class="n">compute_sample_weight</span><span class="p">(</span><span class="n">class_weight</span><span class="o">=</span><span class="s1">&#39;balanced&#39;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y_val</span><span class="p">)</span>
            <span class="n">w_acc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">y_pred</span> <span class="o">==</span> <span class="n">y_val</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">sw</span><span class="p">)</span>
            <span class="n">prec</span> <span class="o">=</span> <span class="n">precision_score</span><span class="p">(</span><span class="n">y_val</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;weighted&#39;</span><span class="p">,</span> <span class="n">zero_division</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">rec</span> <span class="o">=</span> <span class="n">recall_score</span><span class="p">(</span><span class="n">y_val</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;weighted&#39;</span><span class="p">,</span> <span class="n">zero_division</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">f1</span> <span class="o">=</span> <span class="n">f1_score</span><span class="p">(</span><span class="n">y_val</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;weighted&#39;</span><span class="p">,</span> <span class="n">zero_division</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">cm</span> <span class="o">=</span> <span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_val</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">custom_order</span> <span class="k">if</span> <span class="n">custom_order</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">acc</span><span class="p">,</span> <span class="n">bal_acc</span><span class="p">,</span> <span class="n">w_acc</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">cm</span>


        <span class="n">category_labels</span> <span class="o">=</span> <span class="n">extract_category_labels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>

        <span class="c1"># Compute class distribution</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">year_labels</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">year_labels</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">class_counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">year_labels</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">class_counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">category_labels</span><span class="p">)</span>
        <span class="c1"># class_counts = Counter(category_labels)</span>

        <span class="n">total_samples</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">class_counts</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="c1"># Compute Correct Chance Accuracy (Taking Class Distribution into Account)</span>
        <span class="n">class_probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">count</span> <span class="o">/</span> <span class="n">total_samples</span> <span class="k">for</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">class_counts</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
        <span class="n">chance_accuracy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">class_probabilities</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Sum of squared class probabilities</span>


        <span class="c1"># Set up a custom order for the confusion matrix if a region is specified.</span>
        <span class="k">if</span> <span class="n">region</span> <span class="o">==</span> <span class="s1">&#39;winery&#39;</span><span class="p">:</span>
            <span class="n">custom_order</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;Q&#39;</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="s1">&#39;J&#39;</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">region</span> <span class="o">==</span> <span class="s1">&#39;origin&#39;</span><span class="p">:</span>
            <span class="n">custom_order</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Beaune&#39;</span><span class="p">,</span> <span class="s1">&#39;Alsace&#39;</span><span class="p">,</span> <span class="s1">&#39;Neuchatel&#39;</span><span class="p">,</span> <span class="s1">&#39;Genve&#39;</span><span class="p">,</span> <span class="s1">&#39;Valais&#39;</span><span class="p">,</span> <span class="s1">&#39;Californie&#39;</span><span class="p">,</span> <span class="s1">&#39;Oregon&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">custom_order</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Initialize accumulators for outer-repetition averaged metrics.</span>
        <span class="n">eval_accuracy</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">eval_balanced_accuracy</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">eval_weighted_accuracy</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">eval_precision</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">eval_recall</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">eval_f1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">eval_cm</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Use a reproducible RNG.</span>
        <span class="k">if</span> <span class="n">random_seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">random_seed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1e6</span><span class="p">))</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>


        <span class="c1"># Choose whether to use groups based on wine type.</span>
        <span class="n">use_groups</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wine_kind</span> <span class="o">==</span> <span class="s2">&quot;press&quot;</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="c1"># use_groups = False</span>

        <span class="c1"># Outer split: use StratifiedShuffleSplit to split the data.</span>
        <span class="c1"># # sss = StratifiedShuffleSplit(n_splits=1, test_size=test_size, random_state=rng.integers(0, int(1e6)))</span>
        <span class="c1"># sss = ShuffleSplit(n_splits=1, test_size=test_size, random_state=rng.integers(0, int(1e6)))</span>
        <span class="c1"># train_idx, _ = next(sss.split(self.data, self.labels))</span>

        <span class="c1"># train_idx, test_idx = shuffle_split_without_splitting_duplicates(</span>
        <span class="c1">#     self.data, self.labels, test_size=test_size, random_state=rng.integers(0, int(1e6)),</span>
        <span class="c1">#     group_duplicates=use_groups</span>
        <span class="c1"># )</span>

        <span class="k">if</span> <span class="n">LOOPC</span><span class="p">:</span>
            <span class="n">train_idx</span><span class="p">,</span> <span class="n">test_idx</span> <span class="o">=</span> <span class="n">leave_one_sample_per_class_split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_seed</span><span class="p">,</span>
                                                                   <span class="n">is_composite_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">train_idx</span><span class="p">,</span> <span class="n">test_idx</span> <span class="o">=</span> <span class="n">shuffle_split_without_splitting_duplicates</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_seed</span><span class="p">,</span>
                <span class="n">group_duplicates</span><span class="o">=</span><span class="n">use_groups</span>
            <span class="p">)</span>

        <span class="n">X_train_full</span><span class="p">,</span> <span class="n">X_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">train_idx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">test_idx</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">year_labels</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">year_labels</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">y_train_full</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">year_labels</span><span class="p">[</span><span class="n">train_idx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">year_labels</span><span class="p">[</span><span class="n">test_idx</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y_train_full</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">train_idx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">test_idx</span><span class="p">]</span>

        <span class="c1"># y_train_full, y_test = self.labels[train_idx], self.labels[test_idx]</span>

        <span class="k">if</span> <span class="n">test_on_discarded</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
                <span class="n">X_train_full</span><span class="p">,</span> <span class="n">scaler</span> <span class="o">=</span> <span class="n">normalize_data</span><span class="p">(</span><span class="n">X_train_full</span><span class="p">,</span> <span class="n">scaler</span><span class="o">=</span><span class="n">scaler_type</span><span class="p">)</span>
                <span class="n">X_test</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">use_pca</span><span class="p">:</span>
                <span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">svd_solver</span><span class="o">=</span><span class="s1">&#39;randomized&#39;</span><span class="p">)</span>
                <span class="n">pca</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_full</span><span class="p">)</span>
                <span class="n">X_train_full</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_train_full</span><span class="p">)</span>
                <span class="n">X_test</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

            <span class="c1"># if self.year_labels.size &gt; 0 and np.any(self.year_labels != None):</span>
            <span class="c1">#     self.classifier.fit(X_train_full, y_train_full)</span>
            <span class="c1"># else:</span>
            <span class="c1">#     self.classifier.fit(X_train_full, np.array(extract_category_labels(y_train_full)))</span>
            <span class="c1">#     y_test = extract_category_labels(y_test)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">year_labels</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">year_labels</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_full</span><span class="p">,</span> <span class="n">y_train_full</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_full</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">extract_category_labels</span><span class="p">(</span><span class="n">y_train_full</span><span class="p">)))</span>
            <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot; Skipping evaluation due to SVD convergence error (likely caused by LDA on low-variance or singular data).&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">{</span>
                    <span class="s1">&#39;overall_accuracy&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                    <span class="s1">&#39;overall_balanced_accuracy&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                    <span class="s1">&#39;overall_weighted_accuracy&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                    <span class="s1">&#39;overall_precision&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                    <span class="s1">&#39;overall_recall&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                    <span class="s1">&#39;overall_f1_score&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                    <span class="s1">&#39;confusion_matrix&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="c1"># self.classifier.fit(X_train_full, extract_category_labels(y_train_full))</span>
            <span class="c1"># y_test = extract_category_labels(y_test)</span>

            <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>


            <span class="n">eval_accuracy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">accuracy_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>
            <span class="n">eval_balanced_accuracy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">balanced_accuracy_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>
            <span class="n">eval_weighted_accuracy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">y_pred</span> <span class="o">==</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">compute_sample_weight</span><span class="p">(</span><span class="s1">&#39;balanced&#39;</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
            <span class="n">eval_precision</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">precision_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;weighted&#39;</span><span class="p">,</span> <span class="n">zero_division</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">eval_recall</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">recall_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;weighted&#39;</span><span class="p">,</span> <span class="n">zero_division</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">eval_f1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f1_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;weighted&#39;</span><span class="p">,</span> <span class="n">zero_division</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">eval_cm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">custom_order</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">print_results</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Test on discarded data metrics:&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Accuracy: </span><span class="si">{</span><span class="n">eval_accuracy</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Balanced Accuracy: </span><span class="si">{</span><span class="n">eval_balanced_accuracy</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Weighted Accuracy: </span><span class="si">{</span><span class="n">eval_weighted_accuracy</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Precision: </span><span class="si">{</span><span class="n">eval_precision</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Recall: </span><span class="si">{</span><span class="n">eval_recall</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    F1 Score: </span><span class="si">{</span><span class="n">eval_f1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># cv = RepeatedLeaveOneFromEachClassCV(n_repeats=n_inner_repeats, shuffle=True, random_state=random_seed)</span>
            <span class="n">cv</span> <span class="o">=</span> <span class="n">RepeatedLeaveOneSamplePerClassCV</span><span class="p">(</span>
                <span class="n">n_repeats</span><span class="o">=</span><span class="n">n_inner_repeats</span><span class="p">,</span>
                <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="n">random_seed</span><span class="p">,</span>
                <span class="n">use_groups</span><span class="o">=</span><span class="n">use_groups</span>
            <span class="p">)</span>

            <span class="n">results</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="s1">&#39;loky&#39;</span><span class="p">)(</span>
                <span class="n">delayed</span><span class="p">(</span><span class="n">process_fold</span><span class="p">)(</span><span class="n">inner_train_idx</span><span class="p">,</span> <span class="n">inner_val_idx</span><span class="p">,</span> <span class="n">X_train_full</span><span class="p">,</span> <span class="n">y_train_full</span><span class="p">,</span> <span class="n">normalize</span><span class="p">,</span>
                                      <span class="n">scaler_type</span><span class="p">,</span> <span class="n">use_pca</span><span class="p">,</span> <span class="n">vthresh</span><span class="p">,</span> <span class="n">custom_order</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">inner_train_idx</span><span class="p">,</span> <span class="n">inner_val_idx</span> <span class="ow">in</span> <span class="n">cv</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">X_train_full</span><span class="p">,</span> <span class="n">y_train_full</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="n">inner_acc</span><span class="p">,</span> <span class="n">inner_bal_acc</span><span class="p">,</span> <span class="n">inner_w_acc</span><span class="p">,</span> <span class="n">inner_prec</span><span class="p">,</span> <span class="n">inner_rec</span><span class="p">,</span> <span class="n">inner_f1</span><span class="p">,</span> <span class="n">inner_cm</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">results</span><span class="p">)</span>

            <span class="n">eval_accuracy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">inner_acc</span><span class="p">))</span>
            <span class="n">eval_balanced_accuracy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">inner_bal_acc</span><span class="p">))</span>
            <span class="n">eval_weighted_accuracy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">inner_w_acc</span><span class="p">))</span>
            <span class="n">eval_precision</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">inner_prec</span><span class="p">))</span>
            <span class="n">eval_recall</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">inner_rec</span><span class="p">))</span>
            <span class="n">eval_f1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">inner_f1</span><span class="p">))</span>
            <span class="n">eval_cm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">inner_cm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">print_results</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Inner CV Averages:&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Accuracy: </span><span class="si">{</span><span class="n">eval_accuracy</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Balanced Accuracy: </span><span class="si">{</span><span class="n">eval_balanced_accuracy</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Weighted Accuracy: </span><span class="si">{</span><span class="n">eval_weighted_accuracy</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Precision: </span><span class="si">{</span><span class="n">eval_precision</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Recall: </span><span class="si">{</span><span class="n">eval_recall</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    F1 Score: </span><span class="si">{</span><span class="n">eval_f1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Compute the averaged confusion matrix across all repetitions</span>
        <span class="n">overall_cm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">eval_cm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Normalize confusion matrix row-wise (true label-wise)</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="n">overall_cm_normalized</span> <span class="o">=</span> <span class="n">overall_cm</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)</span> <span class="o">/</span> <span class="n">overall_cm</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">overall_cm_normalized</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">overall_cm_normalized</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">overall_results</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;chance_accuracy&#39;</span><span class="p">:</span> <span class="n">chance_accuracy</span><span class="p">,</span>
            <span class="s1">&#39;overall_accuracy&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">eval_accuracy</span><span class="p">),</span>
            <span class="s1">&#39;overall_balanced_accuracy&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">eval_balanced_accuracy</span><span class="p">),</span>
            <span class="s1">&#39;overall_weighted_accuracy&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">eval_weighted_accuracy</span><span class="p">),</span>
            <span class="s1">&#39;overall_precision&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">eval_precision</span><span class="p">),</span>
            <span class="s1">&#39;overall_recall&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">eval_recall</span><span class="p">),</span>
            <span class="s1">&#39;overall_f1_score&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">eval_f1</span><span class="p">),</span>
            <span class="s1">&#39;overall_confusion_matrix&#39;</span><span class="p">:</span> <span class="n">overall_cm</span><span class="p">,</span>
            <span class="s1">&#39;overall_confusion_matrix_normalized&#39;</span><span class="p">:</span> <span class="n">overall_cm_normalized</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">print_results</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Final Results:&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Overall Accuracy: </span><span class="si">{</span><span class="n">overall_results</span><span class="p">[</span><span class="s1">&#39;overall_accuracy&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Overall Balanced Accuracy: </span><span class="si">{</span><span class="n">overall_results</span><span class="p">[</span><span class="s1">&#39;overall_balanced_accuracy&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Overall Weighted Accuracy: </span><span class="si">{</span><span class="n">overall_results</span><span class="p">[</span><span class="s1">&#39;overall_weighted_accuracy&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Overall Precision: </span><span class="si">{</span><span class="n">overall_results</span><span class="p">[</span><span class="s1">&#39;overall_precision&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Overall Recall: </span><span class="si">{</span><span class="n">overall_results</span><span class="p">[</span><span class="s1">&#39;overall_recall&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Overall F1 Score: </span><span class="si">{</span><span class="n">overall_results</span><span class="p">[</span><span class="s1">&#39;overall_f1_score&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># print(&quot;Overall Mean Confusion Matrix:&quot;)</span>
            <span class="c1"># print(overall_results[&#39;overall_confusion_matrix&#39;])</span>
            <span class="c1"># print(overall_results[&#39;overall_confusion_matrix_normalized&#39;])</span>

        <span class="k">return</span> <span class="n">overall_results</span></div>




<div class="viewcode-block" id="Classifier.train_and_evaluate_balanced_diff_origins">
<a class="viewcode-back" href="../classification.html#classification.Classifier.train_and_evaluate_balanced_diff_origins">[docs]</a>
    <span class="k">def</span> <span class="nf">train_and_evaluate_balanced_diff_origins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_inner_repeats</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>
                                    <span class="n">test_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">scaler_type</span><span class="o">=</span><span class="s1">&#39;standard&#39;</span><span class="p">,</span>
                                    <span class="n">use_pca</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">vthresh</span><span class="o">=</span><span class="mf">0.97</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">print_results</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                                    <span class="n">test_on_discarded</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>


        <span class="k">def</span> <span class="nf">shuffle_split_without_splitting_duplicates</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                       <span class="n">group_duplicates</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Perform ShuffleSplit on samples while ensuring:</span>
<span class="sd">            - Duplicates of the same sample (including dataset origin) are kept together (if enabled).</span>
<span class="sd">            - Each class is represented in the test set.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">group_duplicates</span><span class="p">:</span>
                <span class="n">unique_samples</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># {(origin, label): [indices]}</span>
                <span class="n">class_samples</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>  <span class="c1"># {class_label: [(origin, label), ...]}</span>

                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
                    <span class="n">origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_origins</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
                    <span class="n">unique_samples</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                    <span class="n">class_label</span> <span class="o">=</span> <span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># e.g. &#39;A&#39; from &#39;A1&#39;</span>
                    <span class="n">class_samples</span><span class="p">[</span><span class="n">class_label</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

                <span class="n">sample_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">unique_samples</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="n">rng</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">sample_keys</span><span class="p">)</span>

                <span class="c1"># Step 1: Randomly select test samples</span>
                <span class="n">num_test_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sample_keys</span><span class="p">)</span> <span class="o">*</span> <span class="n">test_size</span><span class="p">)</span>
                <span class="n">test_sample_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">sample_keys</span><span class="p">[:</span><span class="n">num_test_samples</span><span class="p">])</span>

                <span class="c1"># Step 2: Ensure all class labels are represented</span>
                <span class="n">test_classes</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">test_sample_keys</span><span class="p">}</span>  <span class="c1"># e.g. &#39;A&#39; from (&#39;merlot&#39;, &#39;A1&#39;)</span>
                <span class="n">missing_classes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">cls</span> <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">class_samples</span> <span class="k">if</span> <span class="bp">cls</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">test_classes</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">class_label</span> <span class="ow">in</span> <span class="n">missing_classes</span><span class="p">:</span>
                    <span class="n">candidate_keys</span> <span class="o">=</span> <span class="n">class_samples</span><span class="p">[</span><span class="n">class_label</span><span class="p">]</span>
                    <span class="n">additional_key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">candidate_keys</span><span class="p">))</span>
                    <span class="n">test_sample_keys</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">additional_key</span><span class="p">)</span>

                <span class="c1"># Step 3: Translate keys into train/test indices</span>
                <span class="n">test_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">test_sample_keys</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">unique_samples</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span>
                <span class="n">train_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">sample_keys</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">test_sample_keys</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span>
                                 <span class="n">unique_samples</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Fallback: treat each instance independently</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
                <span class="n">rng</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
                <span class="n">num_test_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">*</span> <span class="n">test_size</span><span class="p">)</span>
                <span class="n">test_indices</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[:</span><span class="n">num_test_samples</span><span class="p">]</span>
                <span class="n">train_indices</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">num_test_samples</span><span class="p">:]</span>

            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">train_indices</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">test_indices</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">extract_category_labels</span><span class="p">(</span><span class="n">composite_labels</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Convert composite labels (e.g., &#39;A1&#39;, &#39;B9&#39;, &#39;C2&#39;) to category labels (&#39;A&#39;, &#39;B&#39;, &#39;C&#39;).</span>

<span class="sd">            Args:</span>
<span class="sd">                composite_labels (array-like): List or array of composite labels.</span>

<span class="sd">            Returns:</span>
<span class="sd">                list: List of category labels.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;([A-C])&#39;</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;([A-C])&#39;</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span> <span class="k">else</span> <span class="n">label</span>
                    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">composite_labels</span><span class="p">]</span>

        <span class="n">category_labels</span> <span class="o">=</span> <span class="n">extract_category_labels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>

        <span class="c1"># Compute Correct Chance Accuracy</span>
        <span class="n">class_counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">category_labels</span><span class="p">)</span>
        <span class="n">total_samples</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">class_counts</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">class_probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">count</span> <span class="o">/</span> <span class="n">total_samples</span> <span class="k">for</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">class_counts</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
        <span class="n">chance_accuracy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">class_probabilities</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Sum of squared class probabilities</span>

        <span class="n">results_by_origin</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Split the dataset into training (80%) and test (20%) without separating duplicates</span>
        <span class="n">train_idx</span><span class="p">,</span> <span class="n">test_idx</span> <span class="o">=</span> <span class="n">shuffle_split_without_splitting_duplicates</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_seed</span><span class="p">,</span> <span class="n">group_duplicates</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="n">X_train_full</span><span class="p">,</span> <span class="n">X_test_full</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">train_idx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">test_idx</span><span class="p">]</span>
        <span class="n">y_train_full</span><span class="p">,</span> <span class="n">y_test_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">category_labels</span><span class="p">)[</span><span class="n">train_idx</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">category_labels</span><span class="p">)[</span><span class="n">test_idx</span><span class="p">]</span>
        <span class="n">dataset_origins_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_origins</span><span class="p">[</span><span class="n">test_idx</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">X_train_full</span><span class="p">,</span> <span class="n">scaler</span> <span class="o">=</span> <span class="n">normalize_data</span><span class="p">(</span><span class="n">X_train_full</span><span class="p">,</span> <span class="n">scaler</span><span class="o">=</span><span class="n">scaler_type</span><span class="p">)</span>
            <span class="n">X_test_full</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test_full</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">use_pca</span><span class="p">:</span>
            <span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">svd_solver</span><span class="o">=</span><span class="s1">&#39;randomized&#39;</span><span class="p">)</span>
            <span class="n">pca</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_full</span><span class="p">)</span>
            <span class="n">X_train_full</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_train_full</span><span class="p">)</span>
            <span class="n">X_test_full</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test_full</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_full</span><span class="p">,</span> <span class="n">y_train_full</span><span class="p">)</span>

        <span class="c1"># if self.dataset_origins is not None:</span>
        <span class="c1">#     unique_origins = np.unique(self.dataset_origins)</span>
        <span class="c1"># else:</span>
        <span class="c1">#     unique_origins = [None]</span>

        <span class="c1"># Use all samples as one group if no origins or if only one origin exists</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_origins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">unique_origins</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
            <span class="n">dataset_origins_test</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># No filtering</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unique_origins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset_origins</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_origins</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Ensure it&#39;s a proper list so the loop runs</span>
                <span class="n">unique_origins</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">unique_origins</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">origin</span> <span class="ow">in</span> <span class="n">unique_origins</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dataset_origins_test</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">origin_mask</span> <span class="o">=</span> <span class="n">dataset_origins_test</span> <span class="o">==</span> <span class="n">origin</span>
                <span class="n">X_test</span> <span class="o">=</span> <span class="n">X_test_full</span><span class="p">[</span><span class="n">origin_mask</span><span class="p">]</span>
                <span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test_full</span><span class="p">[</span><span class="n">origin_mask</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">X_test</span> <span class="o">=</span> <span class="n">X_test_full</span>
                <span class="n">y_test</span> <span class="o">=</span> <span class="n">y_test_full</span>

            <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

            <span class="n">acc</span> <span class="o">=</span> <span class="n">accuracy_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
            <span class="n">bal_acc</span> <span class="o">=</span> <span class="n">balanced_accuracy_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
            <span class="n">weighted_acc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">y_pred</span> <span class="o">==</span> <span class="n">y_test</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">compute_sample_weight</span><span class="p">(</span><span class="s1">&#39;balanced&#39;</span><span class="p">,</span> <span class="n">y_test</span><span class="p">))</span>
            <span class="n">prec</span> <span class="o">=</span> <span class="n">precision_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;weighted&#39;</span><span class="p">,</span> <span class="n">zero_division</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">rec</span> <span class="o">=</span> <span class="n">recall_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;weighted&#39;</span><span class="p">,</span> <span class="n">zero_division</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">f1</span> <span class="o">=</span> <span class="n">f1_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;weighted&#39;</span><span class="p">,</span> <span class="n">zero_division</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">cm</span> <span class="o">=</span> <span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>

            <span class="n">results_by_origin</span><span class="p">[</span><span class="n">origin</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;accuracy&#39;</span><span class="p">:</span> <span class="n">acc</span><span class="p">,</span>
                <span class="s1">&#39;balanced_accuracy&#39;</span><span class="p">:</span> <span class="n">bal_acc</span><span class="p">,</span>
                <span class="s1">&#39;weighted_accuracy&#39;</span><span class="p">:</span> <span class="n">weighted_acc</span><span class="p">,</span>
                <span class="s1">&#39;precision&#39;</span><span class="p">:</span> <span class="n">prec</span><span class="p">,</span>
                <span class="s1">&#39;recall&#39;</span><span class="p">:</span> <span class="n">rec</span><span class="p">,</span>
                <span class="s1">&#39;f1_score&#39;</span><span class="p">:</span> <span class="n">f1</span><span class="p">,</span>
                <span class="s1">&#39;confusion_matrix&#39;</span><span class="p">:</span> <span class="n">cm</span><span class="p">,</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="n">print_results</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Results for </span><span class="si">{</span><span class="n">origin</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="ow">is</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="kc">None</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;All Data&#39;</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Accuracy: </span><span class="si">{</span><span class="n">acc</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Balanced Accuracy: </span><span class="si">{</span><span class="n">bal_acc</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Weighted Accuracy: </span><span class="si">{</span><span class="n">weighted_acc</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Precision: </span><span class="si">{</span><span class="n">prec</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Recall: </span><span class="si">{</span><span class="n">rec</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  F1 Score: </span><span class="si">{</span><span class="n">f1</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Confusion Matrix:</span><span class="se">\n</span><span class="si">{</span><span class="n">cm</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results_by_origin</span></div>


<div class="viewcode-block" id="Classifier.train_and_evaluate_balanced_target_origin">
<a class="viewcode-back" href="../classification.html#classification.Classifier.train_and_evaluate_balanced_target_origin">[docs]</a>
    <span class="k">def</span> <span class="nf">train_and_evaluate_balanced_target_origin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_inner_repeats</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>
                                                 <span class="n">test_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">scaler_type</span><span class="o">=</span><span class="s1">&#39;standard&#39;</span><span class="p">,</span>
                                                 <span class="n">use_pca</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">vthresh</span><span class="o">=</span><span class="mf">0.97</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">print_results</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                 <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                                                 <span class="n">test_on_discarded</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">target_origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                 <span class="n">pre_split_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Train and evaluate the classifier, reporting metrics per dataset origin.</span>
<span class="sd">        Supports both inner CV and test-on-discarded strategies.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target_origin : str or None</span>
<span class="sd">            If specified, restrict evaluation to this dataset origin only.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">balanced_accuracy_score</span><span class="p">,</span> <span class="n">precision_score</span><span class="p">,</span> <span class="n">recall_score</span><span class="p">,</span> <span class="n">f1_score</span><span class="p">,</span> <span class="n">confusion_matrix</span>
        <span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>
        <span class="kn">from</span> <span class="nn">sklearn.utils.class_weight</span> <span class="kn">import</span> <span class="n">compute_sample_weight</span>
        <span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">BaseCrossValidator</span>
        <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">Counter</span>
        <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
        <span class="kn">import</span> <span class="nn">re</span>


        <span class="c1">############# FUNCTIONS #############</span>
        <span class="k">class</span> <span class="nc">RepeatedLeaveOneSamplePerClassCV</span><span class="p">(</span><span class="n">BaseCrossValidator</span><span class="p">):</span>
            <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_repeats</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_groups</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_repeats</span> <span class="o">=</span> <span class="n">n_repeats</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span> <span class="o">=</span> <span class="n">shuffle</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">use_groups</span> <span class="o">=</span> <span class="n">use_groups</span>

            <span class="k">def</span> <span class="nf">get_n_splits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">groups</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_repeats</span>

            <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
                <span class="k">def</span> <span class="nf">get_category</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
                    <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;([A-C])\d+&#39;</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">match</span> <span class="k">else</span> <span class="n">label</span>

                <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_groups</span><span class="p">:</span>
                    <span class="n">indices_by_sample</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
                        <span class="n">indices_by_sample</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

                    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_repeats</span><span class="p">):</span>
                        <span class="n">test_indices</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">get_category</span><span class="p">,</span> <span class="n">y</span><span class="p">)):</span>
                            <span class="n">class_samples</span> <span class="o">=</span> <span class="p">[</span><span class="n">label</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">indices_by_sample</span> <span class="k">if</span> <span class="n">get_category</span><span class="p">(</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="n">category</span><span class="p">]</span>
                            <span class="n">chosen_sample</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">class_samples</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span> <span class="k">else</span> \
                            <span class="n">class_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">test_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">indices_by_sample</span><span class="p">[</span><span class="n">chosen_sample</span><span class="p">])</span>

                        <span class="n">test_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">test_indices</span><span class="p">)</span>
                        <span class="n">train_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span> <span class="n">test_indices</span><span class="p">)</span>
                        <span class="k">yield</span> <span class="n">train_indices</span><span class="p">,</span> <span class="n">test_indices</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">indices_by_category</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
                        <span class="n">category</span> <span class="o">=</span> <span class="n">get_category</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                        <span class="n">indices_by_category</span><span class="p">[</span><span class="n">category</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

                    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_repeats</span><span class="p">):</span>
                        <span class="n">test_indices</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">category</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">indices_by_category</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="n">chosen</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle</span> <span class="k">else</span> <span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                            <span class="n">test_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">chosen</span><span class="p">)</span>

                        <span class="n">test_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">test_indices</span><span class="p">)</span>
                        <span class="n">train_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span> <span class="n">test_indices</span><span class="p">)</span>
                        <span class="k">yield</span> <span class="n">train_indices</span><span class="p">,</span> <span class="n">test_indices</span>


        <span class="k">def</span> <span class="nf">extract_category_labels</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;([A-C])&#39;</span><span class="p">,</span> <span class="n">lbl</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;([A-C])&#39;</span><span class="p">,</span> <span class="n">lbl</span><span class="p">)</span> <span class="k">else</span> <span class="n">lbl</span> <span class="k">for</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">process_fold</span><span class="p">(</span><span class="n">inner_train_idx</span><span class="p">,</span> <span class="n">inner_val_idx</span><span class="p">,</span> <span class="n">X_train_full</span><span class="p">,</span> <span class="n">y_train_full</span><span class="p">,</span> <span class="n">val_origins_full</span><span class="p">):</span>
            <span class="n">X_train</span> <span class="o">=</span> <span class="n">X_train_full</span><span class="p">[</span><span class="n">inner_train_idx</span><span class="p">]</span>
            <span class="n">X_val</span> <span class="o">=</span> <span class="n">X_train_full</span><span class="p">[</span><span class="n">inner_val_idx</span><span class="p">]</span>
            <span class="n">y_train</span> <span class="o">=</span> <span class="n">extract_category_labels</span><span class="p">(</span><span class="n">y_train_full</span><span class="p">[</span><span class="n">inner_train_idx</span><span class="p">])</span>
            <span class="n">y_val</span> <span class="o">=</span> <span class="n">extract_category_labels</span><span class="p">(</span><span class="n">y_train_full</span><span class="p">[</span><span class="n">inner_val_idx</span><span class="p">])</span>
            <span class="n">val_origins</span> <span class="o">=</span> <span class="n">val_origins_full</span><span class="p">[</span><span class="n">inner_val_idx</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">target_origin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">origin_mask</span> <span class="o">=</span> <span class="n">val_origins</span> <span class="o">==</span> <span class="n">target_origin</span>
                <span class="n">X_val</span> <span class="o">=</span> <span class="n">X_val</span><span class="p">[</span><span class="n">origin_mask</span><span class="p">]</span>
                <span class="n">y_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y_val</span><span class="p">)[</span><span class="n">origin_mask</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
                <span class="n">X_train</span><span class="p">,</span> <span class="n">scaler</span> <span class="o">=</span> <span class="n">normalize_data</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">scaler</span><span class="o">=</span><span class="n">scaler_type</span><span class="p">)</span>
                <span class="n">X_val</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_val</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">use_pca</span><span class="p">:</span>
                <span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">svd_solver</span><span class="o">=</span><span class="s1">&#39;randomized&#39;</span><span class="p">)</span>
                <span class="n">pca</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
                <span class="n">cumulative_variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">explained_variance_ratio_</span><span class="p">)</span>
                <span class="n">n_components</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">cumulative_variance</span><span class="p">,</span> <span class="n">vthresh</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">n_components</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_components</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">y_train</span><span class="p">)))</span>
                <span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span> <span class="n">svd_solver</span><span class="o">=</span><span class="s1">&#39;randomized&#39;</span><span class="p">)</span>
                <span class="n">X_train</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
                <span class="n">X_val</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_val</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
            <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_val</span><span class="p">)</span>

            <span class="n">acc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y_pred</span> <span class="o">==</span> <span class="n">y_val</span><span class="p">)</span>
            <span class="n">bal_acc</span> <span class="o">=</span> <span class="n">balanced_accuracy_score</span><span class="p">(</span><span class="n">y_val</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
            <span class="n">w_acc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">y_pred</span> <span class="o">==</span> <span class="n">y_val</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">compute_sample_weight</span><span class="p">(</span><span class="s1">&#39;balanced&#39;</span><span class="p">,</span> <span class="n">y_val</span><span class="p">))</span>
            <span class="n">prec</span> <span class="o">=</span> <span class="n">precision_score</span><span class="p">(</span><span class="n">y_val</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;weighted&#39;</span><span class="p">,</span> <span class="n">zero_division</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">rec</span> <span class="o">=</span> <span class="n">recall_score</span><span class="p">(</span><span class="n">y_val</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;weighted&#39;</span><span class="p">,</span> <span class="n">zero_division</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">f1</span> <span class="o">=</span> <span class="n">f1_score</span><span class="p">(</span><span class="n">y_val</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;weighted&#39;</span><span class="p">,</span> <span class="n">zero_division</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># cm = confusion_matrix(y_val, y_pred)</span>
            <span class="n">cm</span> <span class="o">=</span> <span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_val</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">])</span>  <span class="c1"># adjust to your full class set</span>


            <span class="k">return</span> <span class="p">{</span>
                <span class="n">target_origin</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;accuracy&#39;</span><span class="p">:</span> <span class="n">acc</span><span class="p">,</span>
                    <span class="s1">&#39;balanced_accuracy&#39;</span><span class="p">:</span> <span class="n">bal_acc</span><span class="p">,</span>
                    <span class="s1">&#39;weighted_accuracy&#39;</span><span class="p">:</span> <span class="n">w_acc</span><span class="p">,</span>
                    <span class="s1">&#39;precision&#39;</span><span class="p">:</span> <span class="n">prec</span><span class="p">,</span>
                    <span class="s1">&#39;recall&#39;</span><span class="p">:</span> <span class="n">rec</span><span class="p">,</span>
                    <span class="s1">&#39;f1_score&#39;</span><span class="p">:</span> <span class="n">f1</span><span class="p">,</span>
                    <span class="s1">&#39;confusion_matrix&#39;</span><span class="p">:</span> <span class="n">cm</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="c1">############# END FUNCTIONS #############</span>

        <span class="n">category_labels</span> <span class="o">=</span> <span class="n">extract_category_labels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
        <span class="n">use_groups</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wine_kind</span> <span class="o">==</span> <span class="s2">&quot;press&quot;</span>

        <span class="k">if</span> <span class="n">pre_split_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">train_idx</span><span class="p">,</span> <span class="n">test_idx</span> <span class="o">=</span> <span class="n">pre_split_indices</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">train_idx</span><span class="p">,</span> <span class="n">test_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shuffle_split_without_splitting_duplicates</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_seed</span><span class="p">,</span> <span class="n">group_duplicates</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

        <span class="n">X_train_full</span><span class="p">,</span> <span class="n">X_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">train_idx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">test_idx</span><span class="p">]</span>
        <span class="n">y_train_full</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">train_idx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">test_idx</span><span class="p">]</span>
        <span class="n">origins_train</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_origins</span><span class="p">[</span><span class="n">train_idx</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_origins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">origins_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_origins</span><span class="p">[</span><span class="n">test_idx</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset_origins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">test_on_discarded</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
                <span class="n">X_train_full</span><span class="p">,</span> <span class="n">scaler</span> <span class="o">=</span> <span class="n">normalize_data</span><span class="p">(</span><span class="n">X_train_full</span><span class="p">,</span> <span class="n">scaler</span><span class="o">=</span><span class="n">scaler_type</span><span class="p">)</span>
                <span class="n">X_test</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">use_pca</span><span class="p">:</span>
                <span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">svd_solver</span><span class="o">=</span><span class="s1">&#39;randomized&#39;</span><span class="p">)</span>
                <span class="n">pca</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_full</span><span class="p">)</span>
                <span class="n">X_train_full</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_train_full</span><span class="p">)</span>
                <span class="n">X_test</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_full</span><span class="p">,</span> <span class="n">extract_category_labels</span><span class="p">(</span><span class="n">y_train_full</span><span class="p">))</span>
            <span class="n">y_test_cat</span> <span class="o">=</span> <span class="n">extract_category_labels</span><span class="p">(</span><span class="n">y_test</span><span class="p">)</span>
            <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

            <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">origin</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">origins_test</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">target_origin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">origin</span> <span class="o">!=</span> <span class="n">target_origin</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">origins_test</span> <span class="o">==</span> <span class="n">origin</span>
                <span class="n">y_true</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y_test_cat</span><span class="p">)[</span><span class="n">mask</span><span class="p">]</span>
                <span class="n">y_hat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y_pred</span><span class="p">)[</span><span class="n">mask</span><span class="p">]</span>
                <span class="n">results</span><span class="p">[</span><span class="n">origin</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;accuracy&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y_hat</span> <span class="o">==</span> <span class="n">y_true</span><span class="p">),</span>
                    <span class="s1">&#39;balanced_accuracy&#39;</span><span class="p">:</span> <span class="n">balanced_accuracy_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_hat</span><span class="p">),</span>
                    <span class="s1">&#39;weighted_accuracy&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">y_hat</span> <span class="o">==</span> <span class="n">y_true</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">compute_sample_weight</span><span class="p">(</span><span class="s1">&#39;balanced&#39;</span><span class="p">,</span> <span class="n">y_true</span><span class="p">)),</span>
                    <span class="s1">&#39;precision&#39;</span><span class="p">:</span> <span class="n">precision_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_hat</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;weighted&#39;</span><span class="p">,</span> <span class="n">zero_division</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                    <span class="s1">&#39;recall&#39;</span><span class="p">:</span> <span class="n">recall_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_hat</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;weighted&#39;</span><span class="p">,</span> <span class="n">zero_division</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                    <span class="s1">&#39;f1_score&#39;</span><span class="p">:</span> <span class="n">f1_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_hat</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="s1">&#39;weighted&#39;</span><span class="p">,</span> <span class="n">zero_division</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                    <span class="s1">&#39;confusion_matrix&#39;</span><span class="p">:</span> <span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_hat</span><span class="p">),</span>
                <span class="p">}</span>
            <span class="k">return</span> <span class="n">results</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Initialize the cross-validation strategy</span>
            <span class="n">cv</span> <span class="o">=</span> <span class="n">RepeatedLeaveOneSamplePerClassCV</span><span class="p">(</span>
                <span class="n">n_repeats</span><span class="o">=</span><span class="n">n_inner_repeats</span><span class="p">,</span>
                <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="n">random_seed</span><span class="p">,</span>
                <span class="n">use_groups</span><span class="o">=</span><span class="n">use_groups</span>  <span class="c1"># keep replicates together if applicable</span>
            <span class="p">)</span>

            <span class="c1"># Run CV in parallel: each fold calls `process_fold()` on train/val split</span>
            <span class="n">split_results</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="s1">&#39;loky&#39;</span><span class="p">)(</span>
                <span class="n">delayed</span><span class="p">(</span><span class="n">process_fold</span><span class="p">)(</span><span class="n">train_idx</span><span class="p">,</span> <span class="n">val_idx</span><span class="p">,</span> <span class="n">X_train_full</span><span class="p">,</span> <span class="n">y_train_full</span><span class="p">,</span> <span class="n">origins_train</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">train_idx</span><span class="p">,</span> <span class="n">val_idx</span> <span class="ow">in</span> <span class="n">cv</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">X_train_full</span><span class="p">,</span> <span class="n">y_train_full</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># Merge metrics by origin: structure = {origin: {metric_name: [list of values across folds]}}</span>
            <span class="n">merged</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">split_results</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Some folds may not contain target_origin at all</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">origin</span><span class="p">,</span> <span class="n">metrics</span> <span class="ow">in</span> <span class="n">res</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">target_origin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">origin</span> <span class="o">!=</span> <span class="n">target_origin</span><span class="p">:</span>
                        <span class="k">continue</span>  <span class="c1"># Skip irrelevant origins if a target is specified</span>
                    <span class="k">for</span> <span class="n">metric</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">metrics</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">merged</span><span class="p">[</span><span class="n">origin</span><span class="p">][</span><span class="n">metric</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>  <span class="c1"># Accumulate metric values</span>

            <span class="c1"># Compute averages across folds for each origin</span>
            <span class="n">averaged_results</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">origin</span><span class="p">,</span> <span class="n">metrics</span> <span class="ow">in</span> <span class="n">merged</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">averaged_results</span><span class="p">[</span><span class="n">origin</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">metric</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">metric</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">metrics</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">}</span>

            <span class="c1"># Optionally print results per origin</span>
            <span class="k">if</span> <span class="n">print_results</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">origin</span><span class="p">,</span> <span class="n">metrics</span> <span class="ow">in</span> <span class="n">averaged_results</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Results for </span><span class="si">{</span><span class="n">origin</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">metrics</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">key</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">val</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Return per-origin averaged results</span>
            <span class="k">return</span> <span class="n">averaged_results</span></div>



<div class="viewcode-block" id="Classifier.train_and_evaluate_all_channels">
<a class="viewcode-back" href="../classification.html#classification.Classifier.train_and_evaluate_all_channels">[docs]</a>
    <span class="k">def</span> <span class="nf">train_and_evaluate_all_channels</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">num_repeats</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">num_outer_repeats</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">scaler_type</span><span class="o">=</span><span class="s1">&#39;standard&#39;</span><span class="p">,</span> <span class="n">use_pca</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">vthresh</span><span class="o">=</span><span class="mf">0.97</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">print_results</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">feature_type</span><span class="o">=</span><span class="s2">&quot;concatenated&quot;</span><span class="p">,</span> <span class="n">classifier_type</span><span class="o">=</span><span class="s2">&quot;RGC&quot;</span><span class="p">,</span> <span class="n">LOOPC</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Trains and evaluates a classifier using all available channels in the dataset,</span>
<span class="sd">        repeating the evaluation multiple times to assess performance stability.</span>

<span class="sd">        Feature extraction is flexible, allowing for different representations (e.g., concatenated raw data, TIC, TIS, or both).</span>
<span class="sd">        At each repeat, the data is randomly split into training and testing sets.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        ----------</span>
<span class="sd">        num_repeats : int, optional (default=10)</span>
<span class="sd">            Number of times to repeat the training and evaluation process (with different random seeds).</span>
<span class="sd">        num_outer_repeats : int, optional (default=1)</span>
<span class="sd">            Currently unused. Reserved for compatibility with outer loop evaluations.</span>
<span class="sd">        random_seed : int, optional (default=42)</span>
<span class="sd">            Base random seed for reproducibility. A different seed is used at each repeat.</span>
<span class="sd">        test_size : float, optional (default=0.2)</span>
<span class="sd">            Fraction of the data used for testing in each train/test split.</span>
<span class="sd">        normalize : bool, optional (default=False)</span>
<span class="sd">            Whether to apply feature normalization (e.g., standard scaling) before training.</span>
<span class="sd">        scaler_type : str, optional (default=&#39;standard&#39;)</span>
<span class="sd">            Type of scaler to use if normalization is enabled. Options: &#39;standard&#39;, &#39;minmax&#39;, etc.</span>
<span class="sd">        use_pca : bool, optional (default=False)</span>
<span class="sd">            Whether to apply PCA for dimensionality reduction before training.</span>
<span class="sd">        vthresh : float, optional (default=0.97)</span>
<span class="sd">            Variance threshold to retain during PCA (if use_pca=True).</span>
<span class="sd">        region : str or None, optional (default=None)</span>
<span class="sd">            If specified, restricts training/testing to samples from a given region.</span>
<span class="sd">        print_results : bool, optional (default=True)</span>
<span class="sd">            Whether to print detailed results after evaluation.</span>
<span class="sd">        n_jobs : int, optional (default=-1)</span>
<span class="sd">            Number of CPU cores to use for training (if supported by the classifier).</span>
<span class="sd">        feature_type : str, optional (default=&#39;concatenated&#39;)</span>
<span class="sd">            Feature extraction mode: &#39;concatenated&#39;, &#39;tic&#39;, &#39;tis&#39;, or &#39;tic_tis&#39;.</span>
<span class="sd">        classifier_type : str, optional (default=&#39;RGC&#39;)</span>
<span class="sd">            Type of classifier to use.</span>

<span class="sd">        Returns:</span>
<span class="sd">        -------</span>
<span class="sd">        mean_test_accuracy : float</span>
<span class="sd">            Average balanced accuracy over all repeats.</span>
<span class="sd">        std_test_accuracy : float</span>
<span class="sd">            Standard deviation of balanced accuracy over all repeats.</span>

<span class="sd">        Notes:</span>
<span class="sd">        -----</span>
<span class="sd">        - The method internally computes features according to the selected `feature_type`.</span>
<span class="sd">        - Results are averaged across all repeats to provide a robust estimate of performance.</span>
<span class="sd">        - Normalized confusion matrices are averaged across repeats if dimensions match.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cls_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span>
        <span class="n">num_samples</span><span class="p">,</span> <span class="n">num_timepoints</span><span class="p">,</span> <span class="n">num_channels</span> <span class="o">=</span> <span class="n">cls_data</span><span class="o">.</span><span class="n">shape</span>
        <span class="c1"># Initialize lists</span>
        <span class="n">accuracies</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">confusion_matrices</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Store confusion matrices</span>

        <span class="c1"># --- Feature extraction helper ---</span>
        <span class="k">def</span> <span class="nf">compute_features</span><span class="p">(</span><span class="n">channels</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Compute features based on the chosen feature type.&quot;&quot;&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Computing features for channels: </span><span class="si">{</span><span class="n">channels</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">feature_type</span> <span class="o">==</span> <span class="s2">&quot;concatenated&quot;</span><span class="p">:</span>
                <span class="c1"># Flatten each selected channel across time and concatenate them</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">cls_data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">ch</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">feature_type</span> <span class="o">==</span> <span class="s2">&quot;tic&quot;</span><span class="p">:</span>
                <span class="n">tic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cls_data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">channels</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">tic</span>
            <span class="k">elif</span> <span class="n">feature_type</span> <span class="o">==</span> <span class="s2">&quot;tis&quot;</span><span class="p">:</span>
                <span class="n">tis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cls_data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">channels</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span>  <span class="n">tis</span>
            <span class="k">elif</span> <span class="n">feature_type</span> <span class="o">==</span> <span class="s2">&quot;tic_tis&quot;</span><span class="p">:</span>
                <span class="n">tic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cls_data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">channels</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">tis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cls_data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">channels</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">tic</span><span class="p">,</span> <span class="n">tis</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid feature_type. Use &#39;concatenated&#39; or &#39;tic_tis&#39;.&quot;</span><span class="p">)</span>

         <span class="c1"># --- Use all channels by default ---</span>
        <span class="n">feature_matrix</span> <span class="o">=</span> <span class="n">compute_features</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_channels</span><span class="p">)))</span>

        <span class="k">for</span> <span class="n">repeat_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_repeats</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Repeat </span><span class="si">{</span><span class="n">repeat_idx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">num_repeats</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># classifiers = [&quot;DTC&quot;, &quot;GNB&quot;, &quot;KNN&quot;, &quot;LDA&quot;, &quot;LR&quot;, &quot;PAC&quot;, &quot;PER&quot;, &quot;RFC&quot;, &quot;RGC&quot;, &quot;SGD&quot;, &quot;SVM&quot;]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">cls</span> <span class="o">=</span> <span class="n">Classifier</span><span class="p">(</span><span class="n">feature_matrix</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">classifier_type</span><span class="o">=</span><span class="n">classifier_type</span><span class="p">,</span> <span class="n">wine_kind</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">wine_kind</span><span class="p">,</span>
                                 <span class="n">year_labels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">year_labels</span><span class="p">)</span>
                <span class="n">results</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">train_and_evaluate_balanced</span><span class="p">(</span>
                    <span class="n">random_seed</span><span class="o">=</span><span class="n">random_seed</span> <span class="o">+</span> <span class="n">repeat_idx</span><span class="p">,</span>
                    <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">,</span>
                    <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span>
                    <span class="n">scaler_type</span><span class="o">=</span><span class="n">scaler_type</span><span class="p">,</span>
                    <span class="n">use_pca</span><span class="o">=</span><span class="n">use_pca</span><span class="p">,</span>
                    <span class="n">vthresh</span><span class="o">=</span><span class="n">vthresh</span><span class="p">,</span>
                    <span class="n">region</span><span class="o">=</span><span class="n">region</span><span class="p">,</span>
                    <span class="n">print_results</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span>
                    <span class="n">test_on_discarded</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">LOOPC</span><span class="o">=</span><span class="n">LOOPC</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="s1">&#39;overall_balanced_accuracy&#39;</span> <span class="ow">in</span> <span class="n">results</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;overall_balanced_accuracy&#39;</span><span class="p">]):</span>
                    <span class="n">accuracies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;overall_balanced_accuracy&#39;</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; No valid accuracy returned in repeat </span><span class="si">{</span><span class="n">repeat_idx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="s1">&#39;overall_confusion_matrix_normalized&#39;</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">confusion_matrices</span> <span class="ow">and</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;overall_confusion_matrix_normalized&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">confusion_matrices</span><span class="p">[</span>
                        <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; Skipping confusion matrix with different shape.&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">confusion_matrices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;overall_confusion_matrix_normalized&#39;</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; Skipping confusion matrix due to missing key.&quot;</span><span class="p">)</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; Skipping repeat </span><span class="si">{</span><span class="n">repeat_idx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2"> due to error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Compute average performance across repeats</span>
        <span class="n">mean_test_accuracy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">accuracies</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">std_test_accuracy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">accuracies</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">mean_confusion_matrix</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">average_confusion_matrices_ignore_empty_rows</span><span class="p">(</span><span class="n">confusion_matrices</span><span class="p">)</span>
        <span class="c1"># mean_confusion_matrix = np.mean(confusion_matrices, axis=0)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">##################################&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mean Accuracy: </span><span class="si">{</span><span class="n">mean_test_accuracy</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="n">std_test_accuracy</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Final Averaged Normalized Confusion Matrix:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">mean_confusion_matrix</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;##################################&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mean_test_accuracy</span><span class="p">,</span> <span class="n">std_test_accuracy</span></div>



    <span class="k">def</span> <span class="nf">_process_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vintage</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process the labels to extract relevant parts based on whether the data is vintage or not.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vintage : bool</span>
<span class="sd">            If True, the function processes labels to extract a substring starting from the first digit</span>
<span class="sd">            found in the label (assuming vintage data formatting). If False, it processes labels to</span>
<span class="sd">            extract a single character or digit before the first digit found.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            An array of processed labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wine_kind</span> <span class="o">==</span> <span class="s1">&#39;pinot_noir&#39;</span><span class="p">:</span>
            <span class="n">processed_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">wine_kind</span> <span class="o">==</span> <span class="s1">&#39;bordeaux&#39;</span><span class="p">:</span>
            <span class="n">processed_labels</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Iterate over each label in the labels list</span>
            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">:</span>
                <span class="c1"># Search for the first digit in the label</span>
                <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\d+&#39;</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">vintage</span><span class="p">:</span>
                    <span class="c1"># If processing vintage data, extract the substring starting from the first digit</span>
                    <span class="n">processed_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">[</span><span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">():])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># If not vintage, extract the character before the first digit</span>
                    <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;_&#39;</span><span class="p">:</span>
                        <span class="c1"># If the character before the digit is an underscore, take the character before the underscore</span>
                        <span class="n">lb</span> <span class="o">=</span> <span class="n">label</span><span class="p">[</span><span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Otherwise, take the character directly before the first digit</span>
                        <span class="n">lb</span> <span class="o">=</span> <span class="n">label</span><span class="p">[</span><span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">processed_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lb</span><span class="p">)</span>

        <span class="c1"># Return the processed labels as a numpy array</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">processed_labels</span><span class="p">)</span></div>



<div class="viewcode-block" id="process_labels">
<a class="viewcode-back" href="../classification.html#classification.process_labels">[docs]</a>
<span class="k">def</span> <span class="nf">process_labels</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">vintage</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Process a list of labels to extract relevant parts based on whether the data is vintage or not.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    labels : list of str</span>
<span class="sd">        A list of label strings to be processed.</span>
<span class="sd">    vintage : bool</span>
<span class="sd">        If True, the function processes labels to extract a substring starting from the first digit</span>
<span class="sd">        found in each label (assuming vintage data formatting). If False, it processes labels to</span>
<span class="sd">        extract a single character or digit before the first digit found.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        An array of processed labels.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function is similar to the `_process_labels` method within the `Classifier` class, but</span>
<span class="sd">    it operates on an external list of labels rather than an instance attribute.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">processed_labels</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Iterate over each label in the provided list of labels</span>
    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
        <span class="c1"># Search for the first digit in the label</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\d+&#39;</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">vintage</span><span class="p">:</span>
            <span class="c1"># If processing vintage data, extract the substring starting from the first digit</span>
            <span class="n">processed_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">[</span><span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">():])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If not vintage, extract the character before the first digit</span>
            <span class="k">if</span> <span class="n">label</span><span class="p">[</span><span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;_&#39;</span><span class="p">:</span>
                <span class="c1"># If the character before the digit is an underscore, take the character before the underscore</span>
                <span class="n">lb</span> <span class="o">=</span> <span class="n">label</span><span class="p">[</span><span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Otherwise, take the character directly before the first digit</span>
                <span class="n">lb</span> <span class="o">=</span> <span class="n">label</span><span class="p">[</span><span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">processed_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lb</span><span class="p">)</span>

    <span class="c1"># Return the processed labels as a numpy array</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">processed_labels</span><span class="p">)</span></div>



<div class="viewcode-block" id="assign_country_to_pinot_noir">
<a class="viewcode-back" href="../classification.html#classification.assign_country_to_pinot_noir">[docs]</a>
<span class="k">def</span> <span class="nf">assign_country_to_pinot_noir</span><span class="p">(</span><span class="n">original_keys</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map wine sample keys to their corresponding country .</span>

<span class="sd">        This function takes a list of wine sample keys, where the first letter of each key represents</span>
<span class="sd">        the Chateau and returns a list of corresponding countries (Switzerland, US, or France).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        original_keys : list of str</span>
<span class="sd">            A list of strings where each string is a wine sample key. The first letter of each key</span>
<span class="sd">            corresponds to a Chateau(e.g., &#39;C14&#39;, &#39;M08&#39;).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        origine_keys : list of str</span>
<span class="sd">            A list of strings where each string is the corresponding country (&#39;Switzerland&#39;,</span>
<span class="sd">            &#39;US&#39;, &#39;France&#39;) of the wine sample based on the first letter of the key.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; original_keys = [&#39;C14&#39;, &#39;M08&#39;, &#39;U08&#39;, &#39;D10&#39;, &#39;X13&#39;]</span>
<span class="sd">        &gt;&gt;&gt; assign_country_to_pinot_noir(original_keys)</span>
<span class="sd">        [&#39;France&#39;, &#39;Switzerland&#39;, &#39;US&#39;, &#39;France&#39;, &#39;US&#39;]</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The first letter of the key is used to determine the country:</span>
<span class="sd">            - &#39;M&#39;, &#39;N&#39;, &#39;J&#39;, &#39;L&#39;, &#39;H&#39; =&gt; Switzerland</span>
<span class="sd">            - &#39;U&#39;, &#39;X&#39; =&gt; US</span>
<span class="sd">            - &#39;D&#39;, &#39;E&#39;, &#39;Q&#39;, &#39;P&#39;, &#39;R&#39;, &#39;Z&#39;, &#39;C&#39;, &#39;K&#39;, &#39;W&#39;, &#39;Y&#39; =&gt; France</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="c1"># Dictionary to map letters to their origins</span>
    <span class="n">letter_to_country</span> <span class="o">=</span> <span class="p">{</span>
        <span class="c1"># Switzerland</span>
        <span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="s1">&#39;Switzerland&#39;</span><span class="p">,</span>
        <span class="s1">&#39;N&#39;</span><span class="p">:</span> <span class="s1">&#39;Switzerland&#39;</span><span class="p">,</span>
        <span class="s1">&#39;J&#39;</span><span class="p">:</span> <span class="s1">&#39;Switzerland&#39;</span><span class="p">,</span>
        <span class="s1">&#39;L&#39;</span><span class="p">:</span> <span class="s1">&#39;Switzerland&#39;</span><span class="p">,</span>
        <span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="s1">&#39;Switzerland&#39;</span><span class="p">,</span>

        <span class="c1"># US</span>
        <span class="s1">&#39;U&#39;</span><span class="p">:</span> <span class="s1">&#39;US&#39;</span><span class="p">,</span>
        <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="s1">&#39;US&#39;</span><span class="p">,</span>

        <span class="c1"># France</span>
        <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="s1">&#39;France&#39;</span><span class="p">,</span>
        <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="s1">&#39;France&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Q&#39;</span><span class="p">:</span> <span class="s1">&#39;France&#39;</span><span class="p">,</span>
        <span class="s1">&#39;P&#39;</span><span class="p">:</span> <span class="s1">&#39;France&#39;</span><span class="p">,</span>
        <span class="s1">&#39;R&#39;</span><span class="p">:</span> <span class="s1">&#39;France&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="s1">&#39;France&#39;</span><span class="p">,</span>
        <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="s1">&#39;France&#39;</span><span class="p">,</span>
        <span class="s1">&#39;K&#39;</span><span class="p">:</span> <span class="s1">&#39;France&#39;</span><span class="p">,</span>
        <span class="s1">&#39;W&#39;</span><span class="p">:</span> <span class="s1">&#39;France&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="s1">&#39;France&#39;</span>
    <span class="p">}</span>

    <span class="c1"># Create a new list by mapping the first letter of each key to its &quot;Origine&quot;</span>
    <span class="n">country_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">letter_to_country</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">original_keys</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">country_keys</span></div>



<div class="viewcode-block" id="assign_origin_to_pinot_noir">
<a class="viewcode-back" href="../classification.html#classification.assign_origin_to_pinot_noir">[docs]</a>
<span class="k">def</span> <span class="nf">assign_origin_to_pinot_noir</span><span class="p">(</span><span class="n">original_keys</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Map wine sample keys to their corresponding region of origin (Origine).</span>

<span class="sd">    This function takes a list of wine sample keys, where the first letter of each key represents</span>
<span class="sd">    a region of origin, and returns a list of corresponding regions (&quot;Origine&quot;) for each key.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    original_keys : list of str</span>
<span class="sd">        A list of strings where each string is a wine sample key. The first letter of each key</span>
<span class="sd">        corresponds to a specific region of origin (e.g., &#39;C14&#39;, &#39;M08&#39;).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    origine_keys : list of str</span>
<span class="sd">        A list of strings where each string is the corresponding region of origin based on the</span>
<span class="sd">        first letter of the key.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; original_keys = [&#39;C14&#39;, &#39;M08&#39;, &#39;U08&#39;, &#39;D10&#39;, &#39;X13&#39;]</span>
<span class="sd">    &gt;&gt;&gt; assign_origin_to_pinot_noir(original_keys)</span>
<span class="sd">    [&#39;Alsace&#39;, &#39;Neuchatel&#39;, &#39;Californie&#39;, &#39;Beaune&#39;, &#39;Oregon&#39;]</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The first letter of the key is used to determine the specific region of origin:</span>
<span class="sd">        - &#39;M&#39;, &#39;N&#39; =&gt; Neuchatel (Switzerland)</span>
<span class="sd">        - &#39;J&#39;, &#39;L&#39; =&gt; Genve (Switzerland)</span>
<span class="sd">        - &#39;H&#39; =&gt; Valais (Switzerland)</span>
<span class="sd">        - &#39;U&#39; =&gt; Californie (US)</span>
<span class="sd">        - &#39;X&#39; =&gt; Oregon (US)</span>
<span class="sd">        - &#39;D&#39;, &#39;E&#39;, &#39;Q&#39;, &#39;P&#39;, &#39;R&#39;, &#39;Z&#39; =&gt; Beaune (France)</span>
<span class="sd">        - &#39;C&#39;, &#39;K&#39;, &#39;W&#39;, &#39;Y&#39; =&gt; Alsace (France)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Dictionary to map letters to their specific regions (Origine)</span>
    <span class="n">letter_to_origine</span> <span class="o">=</span> <span class="p">{</span>
        <span class="c1"># Switzerland</span>
        <span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="s1">&#39;Neuchatel&#39;</span><span class="p">,</span>
        <span class="s1">&#39;N&#39;</span><span class="p">:</span> <span class="s1">&#39;Neuchatel&#39;</span><span class="p">,</span>
        <span class="s1">&#39;J&#39;</span><span class="p">:</span> <span class="s1">&#39;Genve&#39;</span><span class="p">,</span>
        <span class="s1">&#39;L&#39;</span><span class="p">:</span> <span class="s1">&#39;Genve&#39;</span><span class="p">,</span>
        <span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="s1">&#39;Valais&#39;</span><span class="p">,</span>

        <span class="c1"># US</span>
        <span class="s1">&#39;U&#39;</span><span class="p">:</span> <span class="s1">&#39;Californie&#39;</span><span class="p">,</span>
        <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="s1">&#39;Oregon&#39;</span><span class="p">,</span>

        <span class="c1"># France</span>
        <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="s1">&#39;Beaune&#39;</span><span class="p">,</span>
        <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="s1">&#39;Beaune&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Q&#39;</span><span class="p">:</span> <span class="s1">&#39;Beaune&#39;</span><span class="p">,</span>
        <span class="s1">&#39;P&#39;</span><span class="p">:</span> <span class="s1">&#39;Beaune&#39;</span><span class="p">,</span>
        <span class="s1">&#39;R&#39;</span><span class="p">:</span> <span class="s1">&#39;Beaune&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="s1">&#39;Beaune&#39;</span><span class="p">,</span>
        <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="s1">&#39;Alsace&#39;</span><span class="p">,</span>
        <span class="s1">&#39;K&#39;</span><span class="p">:</span> <span class="s1">&#39;Alsace&#39;</span><span class="p">,</span>
        <span class="s1">&#39;W&#39;</span><span class="p">:</span> <span class="s1">&#39;Alsace&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="s1">&#39;Alsace&#39;</span>
    <span class="p">}</span>

    <span class="c1"># Create a new list by mapping the first letter of each key to its specific &quot;Origine&quot;</span>
    <span class="n">origin_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">letter_to_origine</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">original_keys</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">origin_keys</span></div>



<div class="viewcode-block" id="assign_continent_to_pinot_noir">
<a class="viewcode-back" href="../classification.html#classification.assign_continent_to_pinot_noir">[docs]</a>
<span class="k">def</span> <span class="nf">assign_continent_to_pinot_noir</span><span class="p">(</span><span class="n">original_keys</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Map wine sample keys to their corresponding continent.</span>

<span class="sd">    This function takes a list of wine sample keys, where the first letter of each key represents</span>
<span class="sd">    a region of origin, and returns a list of corresponding continents for each key.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    original_keys : list of str</span>
<span class="sd">        A list of strings where each string is a wine sample key. The first letter of each key</span>
<span class="sd">        corresponds to a specific region of origin.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    continent_keys : list of str</span>
<span class="sd">        A list of strings where each string is the corresponding continent based on the</span>
<span class="sd">        first letter of the key.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; original_keys = [&#39;C14&#39;, &#39;M08&#39;, &#39;U08&#39;, &#39;D10&#39;, &#39;X13&#39;]</span>
<span class="sd">    &gt;&gt;&gt; assign_continent_to_pinot_noir(original_keys)</span>
<span class="sd">    [&#39;Europe&#39;, &#39;Europe&#39;, &#39;North America&#39;, &#39;Europe&#39;, &#39;North America&#39;]</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The first letter of the key is used to determine the continent:</span>
<span class="sd">        - &#39;M&#39;, &#39;N&#39;, &#39;J&#39;, &#39;L&#39;, &#39;H&#39; =&gt; Europe (Switzerland)</span>
<span class="sd">        - &#39;U&#39;, &#39;X&#39; =&gt; North America (US)</span>
<span class="sd">        - &#39;D&#39;, &#39;E&#39;, &#39;Q&#39;, &#39;P&#39;, &#39;R&#39;, &#39;Z&#39;, &#39;C&#39;, &#39;K&#39;, &#39;W&#39;, &#39;Y&#39; =&gt; Europe (France)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Dictionary to map letters to their continents</span>
    <span class="n">letter_to_continent</span> <span class="o">=</span> <span class="p">{</span>
        <span class="c1"># Switzerland (Europe)</span>
        <span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="s1">&#39;Europe&#39;</span><span class="p">,</span>
        <span class="s1">&#39;N&#39;</span><span class="p">:</span> <span class="s1">&#39;Europe&#39;</span><span class="p">,</span>
        <span class="s1">&#39;J&#39;</span><span class="p">:</span> <span class="s1">&#39;Europe&#39;</span><span class="p">,</span>
        <span class="s1">&#39;L&#39;</span><span class="p">:</span> <span class="s1">&#39;Europe&#39;</span><span class="p">,</span>
        <span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="s1">&#39;Europe&#39;</span><span class="p">,</span>

        <span class="c1"># US (North America)</span>
        <span class="s1">&#39;U&#39;</span><span class="p">:</span> <span class="s1">&#39;North America&#39;</span><span class="p">,</span>
        <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="s1">&#39;North America&#39;</span><span class="p">,</span>

        <span class="c1"># France (Europe)</span>
        <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="s1">&#39;Europe&#39;</span><span class="p">,</span>
        <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="s1">&#39;Europe&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Q&#39;</span><span class="p">:</span> <span class="s1">&#39;Europe&#39;</span><span class="p">,</span>
        <span class="s1">&#39;P&#39;</span><span class="p">:</span> <span class="s1">&#39;Europe&#39;</span><span class="p">,</span>
        <span class="s1">&#39;R&#39;</span><span class="p">:</span> <span class="s1">&#39;Europe&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="s1">&#39;Europe&#39;</span><span class="p">,</span>
        <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="s1">&#39;Europe&#39;</span><span class="p">,</span>
        <span class="s1">&#39;K&#39;</span><span class="p">:</span> <span class="s1">&#39;Europe&#39;</span><span class="p">,</span>
        <span class="s1">&#39;W&#39;</span><span class="p">:</span> <span class="s1">&#39;Europe&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="s1">&#39;Europe&#39;</span>
    <span class="p">}</span>

    <span class="c1"># Create a new list by mapping the first letter of each key to its continent</span>
    <span class="n">continent_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">letter_to_continent</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">original_keys</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">continent_keys</span></div>



<div class="viewcode-block" id="assign_north_south_to_beaune">
<a class="viewcode-back" href="../classification.html#classification.assign_north_south_to_beaune">[docs]</a>
<span class="k">def</span> <span class="nf">assign_north_south_to_beaune</span><span class="p">(</span><span class="n">original_keys</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Map wine sample keys to either &#39;North Beaune (NB)&#39; or &#39;South Beaune (SB)&#39;.</span>

<span class="sd">    This function takes a list of wine sample keys, where the first letter of each key represents</span>
<span class="sd">    a region of origin, and returns a list of corresponding regions (&#39;North Beaune&#39; or &#39;South Beaune&#39;) for each key.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    original_keys : list of str</span>
<span class="sd">        A list of strings where each string is a wine sample key. The first letter of each key</span>
<span class="sd">        corresponds to a specific region of origin.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    beaune_region_keys : list of str</span>
<span class="sd">        A list of strings where each string is either &#39;North Beaune&#39; or &#39;South Beaune&#39; based on the</span>
<span class="sd">        first letter of the key.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">original_keys</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">61</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Incorrect wines passed. Input should be Beaume wines only&quot;</span><span class="p">)</span>

    <span class="c1"># Dictionary to map letters to North or South Beaune</span>
    <span class="n">letter_to_beaune_region</span> <span class="o">=</span> <span class="p">{</span>
        <span class="c1"># North Beaune (NB) or Cte de Nuits</span>
        <span class="s1">&#39;Q&#39;</span><span class="p">:</span> <span class="s1">&#39;NB&#39;</span><span class="p">,</span>
        <span class="s1">&#39;R&#39;</span><span class="p">:</span> <span class="s1">&#39;NB&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="s1">&#39;NB&#39;</span><span class="p">,</span>

        <span class="c1"># South Beaune (SB) or Cte de Beaune</span>
        <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="s1">&#39;SB&#39;</span><span class="p">,</span>
        <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="s1">&#39;SB&#39;</span><span class="p">,</span>
        <span class="s1">&#39;P&#39;</span><span class="p">:</span> <span class="s1">&#39;SB&#39;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1"># Create a new list by mapping the first letter of each key to North or South Beaune</span>
    <span class="n">beaune_region_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">letter_to_beaune_region</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">original_keys</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">beaune_region_keys</span></div>



<div class="viewcode-block" id="assign_winery_to_pinot_noir">
<a class="viewcode-back" href="../classification.html#classification.assign_winery_to_pinot_noir">[docs]</a>
<span class="k">def</span> <span class="nf">assign_winery_to_pinot_noir</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assign the first letter of each label, which corresponds to the winery (Chateau)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    labels : list of str</span>
<span class="sd">        A list of label strings.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    first_letters : list of str</span>
<span class="sd">        A list of the first letters of each label.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create a list of the first letters of each label</span>
    <span class="n">first_letters</span> <span class="o">=</span> <span class="p">[</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">first_letters</span></div>



<div class="viewcode-block" id="assign_year_to_pinot_noir">
<a class="viewcode-back" href="../classification.html#classification.assign_year_to_pinot_noir">[docs]</a>
<span class="k">def</span> <span class="nf">assign_year_to_pinot_noir</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assign the last two letters  of each label, which corresponds to the year.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    labels : list of str</span>
<span class="sd">        A list of label strings.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    year : list of str</span>
<span class="sd">        A list of the years from each label.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create a list of the first letters of each label</span>
    <span class="n">first_letters</span> <span class="o">=</span> <span class="p">[</span><span class="n">label</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">first_letters</span></div>


<div class="viewcode-block" id="assign_category_to_press_wine">
<a class="viewcode-back" href="../classification.html#classification.assign_category_to_press_wine">[docs]</a>
<span class="k">def</span> <span class="nf">assign_category_to_press_wine</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assigns categories (A, B, or C) to each wine label based on whether the letters</span>
<span class="sd">    &#39;A&#39;, &#39;B&#39;, or &#39;C&#39; appear immediately before a number in the label.</span>

<span class="sd">    Args:</span>
<span class="sd">        labels (dict_keys or list of str):</span>
<span class="sd">            A list of wine sample labels (or dictionary keys).</span>

<span class="sd">    Returns:</span>
<span class="sd">        list of str:</span>
<span class="sd">            A list of categories (&#39;A&#39;, &#39;B&#39;, or &#39;C&#39;) corresponding to each label.</span>

<span class="sd">    Example:</span>
<span class="sd">        labels = [&#39;Est22CSA1-1&#39;, &#39;Est22CSB1-1&#39;, &#39;Est22CSC1-1&#39;]</span>
<span class="sd">        assign_category_to_press_wine(labels)</span>
<span class="sd">        &gt;&gt;&gt; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Regex pattern to find &#39;A&#39;, &#39;B&#39;, or &#39;C&#39; followed by a number</span>
    <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(A|B|C)(?=\d)&#39;</span><span class="p">)</span>

    <span class="c1"># Loop through each label, extract category, and store in the list</span>
    <span class="n">categories</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="n">categories</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>  <span class="c1"># Append &#39;A&#39;, &#39;B&#39;, or &#39;C&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">categories</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>  <span class="c1"># If no match, append None or custom label</span>

    <span class="k">return</span> <span class="n">categories</span></div>


<div class="viewcode-block" id="assign_composite_label_to_press_wine">
<a class="viewcode-back" href="../classification.html#classification.assign_composite_label_to_press_wine">[docs]</a>
<span class="k">def</span> <span class="nf">assign_composite_label_to_press_wine</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assigns composite labels (e.g., &#39;A1&#39;, &#39;B9&#39;, &#39;C2&#39;) to each wine label based on the</span>
<span class="sd">    letter &#39;A&#39;, &#39;B&#39;, or &#39;C&#39; followed by a number in the label.</span>

<span class="sd">    Args:</span>
<span class="sd">        labels (dict_keys or list of str):</span>
<span class="sd">            A list of wine sample labels (or dictionary keys).</span>

<span class="sd">    Returns:</span>
<span class="sd">        list of str:</span>
<span class="sd">            A list of composite labels (e.g., &#39;A1&#39;, &#39;B9&#39;, &#39;C2&#39;) corresponding to each label.</span>

<span class="sd">    Example:</span>
<span class="sd">        labels = [&#39;Est22CSA1-1&#39;, &#39;Est22CSB9-2&#39;, &#39;Est22CSC3-1&#39;]</span>
<span class="sd">        assign_composite_label_to_press_wine(labels)</span>
<span class="sd">        &gt;&gt;&gt; [&#39;A1&#39;, &#39;B9&#39;, &#39;C3&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Regex pattern to find &#39;A&#39;, &#39;B&#39;, or &#39;C&#39; followed by a number (e.g., &#39;A1&#39;, &#39;B9&#39;, &#39;C3&#39;)</span>
    <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;([A-C])(\d+)&#39;</span><span class="p">)</span>

    <span class="c1"># Loop through each label, extract composite label, and store in the list</span>
    <span class="n">composite_labels</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="c1"># Combine category and number (e.g., &#39;A&#39; + &#39;1&#39; = &#39;A1&#39;)</span>
            <span class="n">composite_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">composite_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>  <span class="c1"># If no match, append None or custom label</span>

    <span class="k">return</span> <span class="n">composite_labels</span></div>



<div class="viewcode-block" id="extract_year_from_samples">
<a class="viewcode-back" href="../classification.html#classification.extract_year_from_samples">[docs]</a>
<span class="k">def</span> <span class="nf">extract_year_from_samples</span><span class="p">(</span><span class="n">sample_names</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts the year from a list of sample names.</span>
<span class="sd">    Assumes the first two-digit number after &#39;Est&#39; represents the year (e.g., &#39;23&#39;  2023).</span>

<span class="sd">    Parameters:</span>
<span class="sd">        sample_names (list of str): List of sample names.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list of int or None: A list of extracted years (e.g., [2023, 2022, None]) corresponding to each sample.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">re</span>
    <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Est(\d</span><span class="si">{2}</span><span class="s1">)&#39;</span><span class="p">)</span>

    <span class="n">years</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">sample_names</span><span class="p">:</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="n">year</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">years</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="mi">2000</span> <span class="o">+</span> <span class="n">year</span> <span class="k">if</span> <span class="n">year</span> <span class="o">&gt;=</span> <span class="mi">20</span> <span class="k">else</span> <span class="mi">1900</span> <span class="o">+</span> <span class="n">year</span><span class="p">))</span>  <span class="c1"># Adjust century if needed</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">years</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>  <span class="c1"># Append None if no match is found</span>

    <span class="k">return</span> <span class="n">years</span></div>



</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Wine Analysis Library</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2025, Luis Gomez Camara.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>