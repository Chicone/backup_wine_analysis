<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>wine_analysis &#8212; Wine Analysis Library 0.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=4f649999" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=cb25574f" />
    <script src="../_static/documentation_options.js?v=01f34227"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for wine_analysis</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Wine Analysis Overview</span>
<span class="sd">====================</span>

<span class="sd">This module provides tools and methods for analyzing wine-related data, particularly focusing on chromatogram analysis and dimensionality reduction techniques.</span>

<span class="sd">Key Features:</span>
<span class="sd">-------------</span>
<span class="sd">- **WineAnalysis Class**: Facilitates the analysis of wine datasets, including the ability to run dimensionality reduction techniques such as t-SNE and UMAP, as well as train classifiers.</span>
<span class="sd">- **ChromatogramAnalysis Class**: Handles the loading, normalization, and merging of chromatogram data, as well as synchronization and scaling of chromatograms.</span>
<span class="sd">- **SyncChromatograms Class**: Provides advanced techniques for aligning chromatograms, including methods for adjusting retention times and synchronizing chromatograms based on peak alignment.</span>

<span class="sd">Usage:</span>
<span class="sd">------</span>
<span class="sd">This module is intended for wine researchers and data scientists who need to analyze complex chromatographic data. The classes and methods provided can be used to preprocess, analyze, and visualize data, making it easier to identify patterns and trends in wine samples.</span>

<span class="sd">Dependencies:</span>
<span class="sd">-------------</span>
<span class="sd">The module relies on several third-party libraries, including:</span>
<span class="sd">- `numpy` for numerical operations</span>
<span class="sd">- `pandas` for data manipulation</span>
<span class="sd">- `scikit-learn` for machine learning and dimensionality reduction</span>
<span class="sd">- `matplotlib` for plotting and visualization</span>
<span class="sd">- `scipy` for signal processing and interpolation</span>

<span class="sd">Example:</span>
<span class="sd">--------</span>
<span class="sd">An example of using the `WineAnalysis` class to run a t-SNE analysis:</span>

<span class="sd">```</span>
<span class="sd">python from wine_analysis import WineAnalysis</span>

<span class="sd"># Initialize the WineAnalysis class with a data file</span>
<span class="sd">analysis = WineAnalysis(file_path=&#39;wine_data.npy&#39;, normalize=True)</span>

<span class="sd"># Run t-SNE on the dataset and plot the results</span>
<span class="sd">analysis.run_tsne(perplexity=30, random_state=42, plot=True)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">gcmswine.data_loader</span> <span class="kn">import</span> <span class="n">DataLoader</span>
<span class="kn">from</span> <span class="nn">gcmswine.visualizer</span> <span class="kn">import</span> <span class="n">Visualizer</span>
<span class="kn">from</span> <span class="nn">gcmswine.dimensionality_reduction</span> <span class="kn">import</span> <span class="n">run_umap_and_evaluate</span><span class="p">,</span> <span class="n">run_tsne_and_evaluate</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">UnivariateSpline</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">correlate</span><span class="p">,</span> <span class="n">find_peaks</span><span class="p">,</span> <span class="n">peak_prominences</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">pearsonr</span>
<span class="kn">from</span> <span class="nn">gcmswine.utils</span> <span class="kn">import</span> <span class="n">normalize_dict</span><span class="p">,</span> <span class="n">remove_peak</span><span class="p">,</span> <span class="n">min_max_normalize</span><span class="p">,</span> <span class="n">normalize_data</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">gaussian_filter</span>
<span class="c1"># from config import *</span>

<span class="kn">from</span> <span class="nn">gcmswine.classification</span> <span class="kn">import</span> <span class="o">*</span>

<div class="viewcode-block" id="WineAnalysis">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.WineAnalysis">[docs]</a>
<span class="k">class</span> <span class="nc">WineAnalysis</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        WineAnalysis Class</span>
<span class="sd">        ==================</span>

<span class="sd">        The `WineAnalysis` class is designed to facilitate the analysis of wine-related chromatographic data.</span>
<span class="sd">        It provides methods for loading data from various sources, performing dimensionality reduction, and running</span>
<span class="sd">        classification algorithms to extract meaningful insights from the data.</span>

<span class="sd">        Key Features:</span>
<span class="sd">        -------------</span>
<span class="sd">        - **Data Loading**: Load wine chromatographic data from .npy or .xlsx files, or directly from a dictionary.</span>
<span class="sd">        - **Dimensionality Reduction**: Apply techniques like PCA, t-SNE, and UMAP to reduce the dimensionality of the data.</span>
<span class="sd">        - **Classification**: Train classifiers such as LDA on the data to evaluate and compare different wine samples.</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">file_path</span><span class="p">:</span>
            <span class="n">script_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">script_dir</span><span class="p">,</span> <span class="n">file_path</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The file </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="si">}</span><span class="s2"> does not exist.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_loader</span> <span class="o">=</span> <span class="n">DataLoader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_loader</span><span class="o">.</span><span class="n">df</span><span class="p">)</span>
            <span class="c1"># self.data = self.data_loader.get_standardized_data()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_loader</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chem_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_path</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">data_dict</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_loader</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data_dict</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data_dict</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">data_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chem_name</span> <span class="o">=</span> <span class="s2">&quot;Not available&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Either file_path or data_dict must be provided.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="WineAnalysis.train_classifier">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.WineAnalysis.train_classifier">[docs]</a>
    <span class="k">def</span> <span class="nf">train_classifier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">classifier_type</span><span class="o">=</span><span class="s1">&#39;LDA&#39;</span><span class="p">,</span> <span class="n">vintage</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_splits</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="n">clf</span> <span class="o">=</span> <span class="n">Classifier</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span> <span class="n">classifier_type</span><span class="o">=</span><span class="n">classifier_type</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">clf</span><span class="o">.</span><span class="n">train_and_evaluate</span><span class="p">(</span><span class="n">n_splits</span><span class="p">,</span> <span class="n">vintage</span><span class="o">=</span><span class="n">vintage</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="n">test_size</span><span class="p">)</span></div>


<div class="viewcode-block" id="WineAnalysis.run_tsne">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.WineAnalysis.run_tsne">[docs]</a>
    <span class="k">def</span> <span class="nf">run_tsne</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perplexity</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">best_score</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Runs t-Distributed Stochastic Neighbor Embedding (t-SNE) on the data and plots the results.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reducer</span> <span class="o">=</span> <span class="n">DimensionalityReducer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">tsne_result</span> <span class="o">=</span> <span class="n">reducer</span><span class="o">.</span><span class="n">tsne</span><span class="p">(</span><span class="n">components</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">perplexity</span><span class="o">=</span><span class="n">perplexity</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>
        <span class="c1"># tsne_result = reducer.tsne(components=2, perplexity=15, random_state=10)</span>
        <span class="n">tsne_result</span> <span class="o">=</span> <span class="o">-</span><span class="n">tsne_result</span>  <span class="c1"># change the sign of the axes to show data like in the paper</span>
        <span class="n">tsne_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">tsne_result</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;t-SNE Component 1&#39;</span><span class="p">,</span> <span class="s1">&#39;t-SNE Component 2&#39;</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span>
        <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">title</span><span class="si">}</span><span class="s1">; </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s1"> wines</span><span class="se">\n</span><span class="s1"> Score: </span><span class="si">{</span><span class="n">best_score</span><span class="si">}</span><span class="s1"> &#39;</span>
        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">Visualizer</span><span class="o">.</span><span class="n">plot_2d_results</span><span class="p">(</span><span class="n">tsne_df</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="s1">&#39;t-SNE Component 1&#39;</span><span class="p">,</span> <span class="s1">&#39;t-SNE Component 2&#39;</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mf">0.02</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tsne_df</span></div>


<div class="viewcode-block" id="WineAnalysis.run_umap">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.WineAnalysis.run_umap">[docs]</a>
    <span class="k">def</span> <span class="nf">run_umap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">best_score</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Runs Uniform Manifold Approximation and Projection (UMAP) on the data and plots the results.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">reducer</span> <span class="o">=</span> <span class="n">DimensionalityReducer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">umap_result</span> <span class="o">=</span> <span class="n">reducer</span><span class="o">.</span><span class="n">umap</span><span class="p">(</span><span class="n">components</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>  <span class="c1"># for concat</span>
        <span class="c1"># umap_result = reducer.umap(components=2, n_neighbors=60, random_state=20)  # for oak</span>
        <span class="c1"># umap_result = reducer.umap(components=2, n_neighbors=50, random_state=0)  # for 7 estates 2018+2022</span>
        <span class="c1"># umap_result = reducer.umap(components=2, n_neighbors=75, random_state=70)  # from searchgrid</span>
        <span class="n">umap_result</span> <span class="o">=</span> <span class="o">-</span><span class="n">umap_result</span>
        <span class="n">umap_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">umap_result</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;UMAP Component 1&#39;</span><span class="p">,</span> <span class="s1">&#39;UMAP Component 2&#39;</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span>
        <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">title</span><span class="si">}</span><span class="s1">; </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s1"> wines</span><span class="se">\n</span><span class="s1"> Score: </span><span class="si">{</span><span class="n">best_score</span><span class="si">}</span><span class="s1"> &#39;</span>
        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">Visualizer</span><span class="o">.</span><span class="n">plot_2d_results</span><span class="p">(</span><span class="n">umap_df</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="s1">&#39;UMAP Component 1&#39;</span><span class="p">,</span> <span class="s1">&#39;UMAP Component 2&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">umap_df</span></div>
</div>



<div class="viewcode-block" id="ChromatogramAnalysis">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.ChromatogramAnalysis">[docs]</a>
<span class="k">class</span> <span class="nc">ChromatogramAnalysis</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ChromatogramAnalysis Class</span>
<span class="sd">        ==========================</span>

<span class="sd">        The `ChromatogramAnalysis` class is responsible for managing chromatogram data in wine analysis. It provides methods to load, resample, synchronize, and merge chromatograms from different datasets, making it a vital tool for comparative analysis of wine samples.</span>

<span class="sd">        Key Features:</span>
<span class="sd">        -------------</span>
<span class="sd">        - **Data Loading**: Load chromatograms from various file formats.</span>
<span class="sd">        - **Resampling and Merging**: Resample chromatograms to a common time axis and merge data from different sources.</span>
<span class="sd">        - **Synchronization**: Synchronize chromatograms by aligning peaks and adjusting retention times.</span>

<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">file_path2</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file_path1</span> <span class="o">=</span> <span class="n">file_path1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file_path2</span> <span class="o">=</span> <span class="n">file_path2</span>

<div class="viewcode-block" id="ChromatogramAnalysis.align_tics">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.ChromatogramAnalysis.align_tics">[docs]</a>
    <span class="k">def</span> <span class="nf">align_tics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dict</span><span class="p">,</span> <span class="n">gcms</span><span class="p">,</span> <span class="n">chrom_cap</span><span class="o">=</span><span class="mi">25000</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Align TIC chromatograms using MS data. It also returns the aligned MS data</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data_dict : dict</span>
<span class="sd">            Dictionary of chromatographic data.</span>
<span class="sd">        chrom_cap : int, optional</span>
<span class="sd">            Maximum size of chromatograms to process, by default 25000.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        norm_tics : dict</span>
<span class="sd">            Normalized TIC chromatograms.</span>
<span class="sd">        synced_gcms : dict</span>
<span class="sd">            Synchronized GC-MS data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tics</span> <span class="o">=</span> <span class="n">gcms</span><span class="o">.</span><span class="n">compute_tics</span><span class="p">()</span>
        <span class="n">mean_tic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_mean_chromatogram</span><span class="p">(</span><span class="n">tics</span><span class="p">)</span>
        <span class="n">closest_to_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">closest_to_mean_chromatogram</span><span class="p">(</span><span class="n">tics</span><span class="p">,</span> <span class="n">mean_tic</span><span class="p">)</span>
        <span class="c1"># synced_tics, synced_gcms = self.sync_individual_chromatograms(</span>
        <span class="c1">#     closest_to_mean[1], data_dict[closest_to_mean[0]], tics, data_dict,</span>
        <span class="c1">#     np.linspace(0.980, 1.020, 80), initial_lag=25</span>
        <span class="c1"># )</span>
        <span class="n">synced_tics</span><span class="p">,</span> <span class="n">synced_gcms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sync_individual_chromatograms</span><span class="p">(</span>
            <span class="n">closest_to_mean</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">gcms</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">closest_to_mean</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">tics</span><span class="p">,</span> <span class="n">gcms</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.980</span><span class="p">,</span> <span class="mf">1.020</span><span class="p">,</span> <span class="mi">80</span><span class="p">),</span> <span class="n">initial_lag</span><span class="o">=</span><span class="mi">25</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">chrom_cap</span><span class="p">:</span>
            <span class="n">synced_tics</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span><span class="p">[:</span><span class="n">chrom_cap</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">synced_tics</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">synced_tics</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">synced_tics</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="c1"># norm_tics = utils.normalize_dict(synced_tics, scaler=&#39;standard&#39;)</span>

        <span class="k">return</span> <span class="n">synced_tics</span><span class="p">,</span> <span class="n">synced_gcms</span></div>


<div class="viewcode-block" id="ChromatogramAnalysis.load_chromatogram">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.ChromatogramAnalysis.load_chromatogram">[docs]</a>
    <span class="k">def</span> <span class="nf">load_chromatogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span></div>


<div class="viewcode-block" id="ChromatogramAnalysis.load_chromatograms">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.ChromatogramAnalysis.load_chromatograms">[docs]</a>
    <span class="k">def</span> <span class="nf">load_chromatograms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">chromatograms</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">file_path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_paths</span><span class="p">:</span>
            <span class="n">chrom_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_chromatogram</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
            <span class="n">chromatograms</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">chrom_data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">chromatograms</span></div>



<div class="viewcode-block" id="ChromatogramAnalysis.normalize_chromatogram">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.ChromatogramAnalysis.normalize_chromatogram">[docs]</a>
    <span class="k">def</span> <span class="nf">normalize_chromatogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chromatogram</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normalizes the chromatogram data using StandardScaler.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        chromatogram (np.ndarray): The input chromatogram data.</span>

<span class="sd">        Returns:</span>
<span class="sd">        np.ndarray: The normalized chromatogram.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
        <span class="n">chromatogram</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">chromatogram</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Reshape for StandardScaler</span>
        <span class="n">normalized_chromatogram</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">chromatogram</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>  <span class="c1"># Fit and transform, then flatten back</span>
        <span class="k">return</span> <span class="n">normalized_chromatogram</span></div>



<div class="viewcode-block" id="ChromatogramAnalysis.calculate_mean_chromatogram">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.ChromatogramAnalysis.calculate_mean_chromatogram">[docs]</a>
    <span class="k">def</span> <span class="nf">calculate_mean_chromatogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chromatograms</span><span class="p">):</span>
        <span class="n">all_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">chromatograms</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="n">mean_chromatogram</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">all_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mean_chromatogram</span></div>


<div class="viewcode-block" id="ChromatogramAnalysis.closest_to_mean_chromatogram">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.ChromatogramAnalysis.closest_to_mean_chromatogram">[docs]</a>
    <span class="k">def</span> <span class="nf">closest_to_mean_chromatogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chromatograms</span><span class="p">,</span> <span class="n">mean_chromatogram</span><span class="p">):</span>
        <span class="n">closest_sample</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">highest_correlation</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">for</span> <span class="n">sample</span><span class="p">,</span> <span class="n">tic</span> <span class="ow">in</span> <span class="n">chromatograms</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">correlation</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">pearsonr</span><span class="p">(</span><span class="n">tic</span><span class="p">,</span> <span class="n">mean_chromatogram</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">correlation</span> <span class="o">&gt;</span> <span class="n">highest_correlation</span><span class="p">:</span>
                <span class="n">highest_correlation</span> <span class="o">=</span> <span class="n">correlation</span>
                <span class="n">closest_sample</span> <span class="o">=</span> <span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">tic</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">closest_sample</span></div>



<div class="viewcode-block" id="ChromatogramAnalysis.merge_chromatograms">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.ChromatogramAnalysis.merge_chromatograms">[docs]</a>
    <span class="k">def</span> <span class="nf">merge_chromatograms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chrom1</span><span class="p">,</span> <span class="n">chrom2</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merges two chromatogram dictionaries, normalizes them, and handles duplicate sample names.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        chrom1 (dict): The first chromatogram dictionary.</span>
<span class="sd">        chrom2 (dict): The second chromatogram dictionary.</span>

<span class="sd">        Returns:</span>
<span class="sd">        dict: The merged and normalized chromatogram data.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">merged_chromatograms</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">chrom1</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># # remove extra peak from standard</span>
            <span class="c1"># value = sc_inst.remove_peak(self, value, peak_idx=8910, window_size=30)</span>
            <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
                <span class="n">merged_chromatograms</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize_chromatogram</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">merged_chromatograms</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">chrom2</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">merged_chromatograms</span> <span class="ow">or</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="ow">in</span> <span class="n">merged_chromatograms</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">b&quot;</span>
            <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
                <span class="n">merged_chromatograms</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize_chromatogram</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">merged_chromatograms</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">return</span> <span class="n">merged_chromatograms</span></div>


<div class="viewcode-block" id="ChromatogramAnalysis.resample_chromatogram">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.ChromatogramAnalysis.resample_chromatogram">[docs]</a>
    <span class="k">def</span> <span class="nf">resample_chromatogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">new_length</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resamples a chromatogram to a new length using interpolation.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        chrom (np.ndarray): The chromatogram to be resampled.</span>
<span class="sd">        new_length (int): The new length for the chromatogram.</span>

<span class="sd">        Returns:</span>
<span class="sd">        np.ndarray: The resampled chromatogram.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x_old</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">chrom</span><span class="p">))</span>
        <span class="n">x_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">new_length</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">x_old</span><span class="p">,</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">x_new</span><span class="p">)</span></div>


<div class="viewcode-block" id="ChromatogramAnalysis.tsne_analysis">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.ChromatogramAnalysis.tsne_analysis">[docs]</a>
    <span class="k">def</span> <span class="nf">tsne_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dict</span><span class="p">,</span> <span class="n">vintage</span><span class="p">,</span> <span class="n">chem_name</span><span class="p">,</span> <span class="n">perplexity_range</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
            <span class="n">random_states</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">96</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="n">wk</span><span class="o">=</span><span class="s1">&#39;bordeaux&#39;</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="s1">&#39;winery&#39;</span><span class="p">):</span>
        <span class="n">analysis</span> <span class="o">=</span> <span class="n">WineAnalysis</span><span class="p">(</span><span class="n">data_dict</span><span class="o">=</span><span class="n">data_dict</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="n">Classifier</span><span class="p">(</span><span class="n">analysis</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">analysis</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span> <span class="n">wine_kind</span><span class="o">=</span><span class="n">wk</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">wk</span> <span class="o">==</span> <span class="s1">&#39;bordeaux&#39;</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_process_labels</span><span class="p">(</span><span class="n">vintage</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">region</span> <span class="o">==</span> <span class="s1">&#39;continent&#39;</span><span class="p">:</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="n">assign_continent_to_pinot_noir</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">region</span> <span class="o">==</span> <span class="s1">&#39;country&#39;</span><span class="p">:</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="n">assign_country_to_pinot_noir</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">region</span> <span class="o">==</span> <span class="s1">&#39;origin&#39;</span><span class="p">:</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="n">assign_origin_to_pinot_noir</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">region</span> <span class="o">==</span> <span class="s1">&#39;winery&#39;</span><span class="p">:</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="n">assign_winery_to_pinot_noir</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">region</span> <span class="o">==</span> <span class="s1">&#39;year&#39;</span><span class="p">:</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="n">assign_year_to_pinot_noir</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">region</span> <span class="o">==</span> <span class="s1">&#39;beaume&#39;</span><span class="p">:</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="n">assign_north_south_to_beaune</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Incorrect region entered: &#39;</span><span class="si">{</span><span class="n">region</span><span class="si">}</span><span class="s2">&#39;. Valid options are &#39;continent&#39;, &#39;country&#39;, &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;&#39;origin&#39;, &#39;winery&#39;, or &#39;year&#39;.&quot;</span><span class="p">)</span>
        <span class="n">perplexity</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">best_score</span> <span class="o">=</span> <span class="n">run_tsne_and_evaluate</span><span class="p">(</span>
            <span class="n">analysis</span><span class="p">,</span>
            <span class="n">labels</span><span class="p">,</span>
            <span class="n">chem_name</span><span class="p">,</span>
            <span class="n">perplexity_range</span><span class="o">=</span><span class="n">perplexity_range</span><span class="p">,</span>
            <span class="n">random_states</span><span class="o">=</span><span class="n">random_states</span>
        <span class="p">)</span>
        <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;t_SNE on </span><span class="si">{</span><span class="n">chem_name</span><span class="si">}</span><span class="s1">; perpl=</span><span class="si">{</span><span class="n">perplexity</span><span class="si">}</span><span class="s1">, random state=</span><span class="si">{</span><span class="n">random_state</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">analysis</span><span class="o">.</span><span class="n">run_tsne</span><span class="p">(</span><span class="n">perplexity</span><span class="o">=</span><span class="n">perplexity</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="n">best_score</span><span class="o">=</span><span class="n">best_score</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span></div>



<div class="viewcode-block" id="ChromatogramAnalysis.umap_analysis">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.ChromatogramAnalysis.umap_analysis">[docs]</a>
    <span class="k">def</span> <span class="nf">umap_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dict</span><span class="p">,</span> <span class="n">vintage</span><span class="p">,</span> <span class="n">chem_name</span><span class="p">,</span> <span class="n">neigh_range</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
                      <span class="n">random_states</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">96</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="n">wk</span><span class="o">=</span><span class="s1">&#39;bordeaux&#39;</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="s1">&#39;winery&#39;</span>
                      <span class="p">):</span>
        <span class="n">analysis</span> <span class="o">=</span> <span class="n">WineAnalysis</span><span class="p">(</span><span class="n">data_dict</span><span class="o">=</span><span class="n">data_dict</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="n">Classifier</span><span class="p">(</span><span class="n">analysis</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">analysis</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span> <span class="n">wine_kind</span><span class="o">=</span><span class="n">wk</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">wk</span> <span class="o">==</span> <span class="s1">&#39;bordeaux&#39;</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_process_labels</span><span class="p">(</span><span class="n">vintage</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">region</span> <span class="o">==</span> <span class="s1">&#39;continent&#39;</span><span class="p">:</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="n">assign_continent_to_pinot_noir</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">region</span> <span class="o">==</span> <span class="s1">&#39;country&#39;</span><span class="p">:</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="n">assign_country_to_pinot_noir</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">region</span> <span class="o">==</span> <span class="s1">&#39;origin&#39;</span><span class="p">:</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="n">assign_origin_to_pinot_noir</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">region</span> <span class="o">==</span> <span class="s1">&#39;winery&#39;</span><span class="p">:</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="n">assign_winery_to_pinot_noir</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">region</span> <span class="o">==</span> <span class="s1">&#39;year&#39;</span><span class="p">:</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="n">assign_year_to_pinot_noir</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">region</span> <span class="o">==</span> <span class="s1">&#39;beaume&#39;</span><span class="p">:</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="n">assign_north_south_to_beaune</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">labels</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Incorrect region entered: &#39;</span><span class="si">{</span><span class="n">region</span><span class="si">}</span><span class="s2">&#39;. Valid options are &#39;continent&#39;, &#39;country&#39;, &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;&#39;origin&#39;, &#39;winery&#39;, or &#39;year&#39;.&quot;</span><span class="p">)</span>


        <span class="n">n_neighbors</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">best_score</span> <span class="o">=</span> <span class="n">run_umap_and_evaluate</span><span class="p">(</span>
            <span class="n">analysis</span><span class="p">,</span>
            <span class="n">labels</span><span class="p">,</span>
            <span class="n">chem_name</span><span class="p">,</span>
            <span class="n">neigh_range</span><span class="o">=</span><span class="n">neigh_range</span><span class="p">,</span>
            <span class="n">random_states</span><span class="o">=</span><span class="n">random_states</span>
        <span class="p">)</span>
        <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;UMAP on </span><span class="si">{</span><span class="n">chem_name</span><span class="si">}</span><span class="s1">; neigh=</span><span class="si">{</span><span class="n">n_neighbors</span><span class="si">}</span><span class="s1">, random state=</span><span class="si">{</span><span class="n">random_state</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">analysis</span><span class="o">.</span><span class="n">run_umap</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="n">best_score</span><span class="o">=</span><span class="n">best_score</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span></div>

        <span class="c1"># analysis.run_umap(n_neighbors=10, random_state=10, best_score=10)</span>
<span class="c1">#</span>

<div class="viewcode-block" id="ChromatogramAnalysis.sync_individual_chromatograms">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.ChromatogramAnalysis.sync_individual_chromatograms">[docs]</a>
    <span class="k">def</span> <span class="nf">sync_individual_chromatograms</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">reference_chromatogram</span><span class="p">,</span> <span class="n">reference_ms</span><span class="p">,</span> <span class="n">input_chromatograms</span><span class="p">,</span> <span class="n">all_ms</span><span class="p">,</span> <span class="n">scales</span><span class="p">,</span> <span class="n">initial_lag</span><span class="o">=</span><span class="mi">300</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Synchronize individual chromatograms with a reference chromatogram.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reference_chromatogram : array-like</span>
<span class="sd">            The reference chromatogram to which the individual chromatograms will be synchronized.</span>
<span class="sd">        input_chromatograms : dict</span>
<span class="sd">            A dictionary where keys are labels for each chromatogram, and values are the chromatograms to be synchronized.</span>
<span class="sd">        scales : array-like</span>
<span class="sd">            Scaling factors to be applied during synchronization.</span>
<span class="sd">        initial_lag : int, optional</span>
<span class="sd">            The initial lag to be considered for synchronization, by default 300.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            A dictionary with the same keys as `input_chromatograms`, where each value is the synchronized chromatogram.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function uses the `SyncChromatograms` class from the `wine_analysis` module to perform the synchronization.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; synced_chromatograms = obj.sync_individual_chromatograms(reference_chromatogram, input_chromatograms, scales)</span>
<span class="sd">        &gt;&gt;&gt; print(synced_chromatograms[&#39;label1&#39;])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">wine_analysis</span> <span class="kn">import</span> <span class="n">SyncChromatograms</span>
        <span class="k">def</span> <span class="nf">plot_average_profile_with_std</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">num_points</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Average Profile with Standard Deviation&#39;</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Plots the average profile with standard deviation for a list of (x, y) tuples.</span>

<span class="sd">            Parameters:</span>
<span class="sd">            - data: list of tuples, where each tuple contains two numpy arrays (x, y).</span>
<span class="sd">            - num_points: int, the number of points in the common x grid for interpolation (default is 500).</span>

<span class="sd">            Returns:</span>
<span class="sd">            - None</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># Define a common x grid based on the min and max x values across all profiles</span>
            <span class="n">x_common</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="nb">min</span><span class="p">([</span><span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]),</span> <span class="nb">max</span><span class="p">([</span><span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]),</span> <span class="n">num_points</span><span class="p">)</span>

            <span class="c1"># Interpolate the y values to the common x grid</span>
            <span class="n">interpolated_y_values</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="c1"># Create an interpolation function</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s2">&quot;extrapolate&quot;</span><span class="p">)</span>
                <span class="c1"># Interpolate y values to the common x grid</span>
                <span class="n">y_interp</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x_common</span><span class="p">)</span>
                <span class="n">interpolated_y_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_interp</span><span class="p">)</span>

            <span class="c1"># Convert the list to a numpy array for easier computation</span>
            <span class="n">interpolated_y_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">interpolated_y_values</span><span class="p">)</span>

            <span class="c1"># Calculate the mean and standard deviation across the y values</span>
            <span class="n">y_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">interpolated_y_values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">y_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">interpolated_y_values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Plot the mean profile with the standard deviation as a shaded region</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_common</span><span class="p">,</span> <span class="n">y_mean</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Average Profile&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">x_common</span><span class="p">,</span> <span class="n">y_mean</span> <span class="o">-</span> <span class="n">y_std</span><span class="p">,</span> <span class="n">y_mean</span> <span class="o">+</span> <span class="n">y_std</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                             <span class="n">label</span><span class="o">=</span><span class="s1">&#39;1 Standard Deviation&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Retention time&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Local retention time correction&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="n">lag_profiles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">synced_chromatograms</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">synced_gcms</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">input_chromatograms</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="n">chrom</span> <span class="o">=</span> <span class="n">input_chromatograms</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

            <span class="n">target_ms</span> <span class="o">=</span>  <span class="n">all_ms</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">sync_chrom</span> <span class="o">=</span> <span class="n">SyncChromatograms</span><span class="p">(</span>
                <span class="n">reference_chromatogram</span><span class="p">,</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">input_chromatograms</span><span class="p">,</span> <span class="n">reference_ms</span><span class="p">,</span> <span class="n">target_ms</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">scales</span><span class="p">,</span>
                <span class="mf">1E6</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.00</span><span class="p">,</span> <span class="n">max_sep_threshold</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">peak_prominence</span><span class="o">=</span><span class="mf">0.00</span><span class="p">,</span> <span class="n">ndec</span><span class="o">=</span><span class="n">N_DECIMATION</span>
            <span class="p">)</span>
            <span class="n">optimized_chrom</span> <span class="o">=</span> <span class="n">sync_chrom</span><span class="o">.</span><span class="n">adjust_chromatogram</span><span class="p">()</span>
            <span class="n">lag_profiles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sync_chrom</span><span class="o">.</span><span class="n">lag_res</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">synced_chromatograms</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">optimized_chrom</span>
            <span class="n">synced_gcms</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">sync_chrom</span><span class="o">.</span><span class="n">target_ms</span>

        <span class="c1"># plot_average_profile_with_std(lag_profiles, title=&#39;Lag distribution 2018 dataset&#39;)</span>
        <span class="k">return</span> <span class="n">synced_chromatograms</span><span class="p">,</span> <span class="n">synced_gcms</span></div>


<div class="viewcode-block" id="ChromatogramAnalysis.stacked_2D_plots_3D">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.ChromatogramAnalysis.stacked_2D_plots_3D">[docs]</a>
    <span class="k">def</span> <span class="nf">stacked_2D_plots_3D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates stacked 2D plots in a 3D space for the given dictionary of data.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        data_dict (dict): A dictionary with labels as keys and lists of values as values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>

        <span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="n">num_plots</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c1"># Offset between plots in the z direction</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">values</span><span class="p">)):</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="n">offset</span><span class="p">)</span>  <span class="c1"># Set the z value to stack plots</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">zs</span><span class="o">=</span><span class="n">z</span><span class="p">,</span> <span class="n">zdir</span><span class="o">=</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>

            <span class="c1"># Show legend for the first and last plots</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="n">num_plots</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;X-axis&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Y-axis&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;Plot index&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Stacked 2D Plots in 3D&#39;</span><span class="p">)</span>

        <span class="c1"># Set the initial view to make y-axis vertical</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="n">elev</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">azim</span><span class="o">=-</span><span class="mi">90</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">15000</span><span class="p">])</span>
        <span class="c1"># ax.set_ylim([0, 0.2])</span>

        <span class="k">def</span> <span class="nf">on_key</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;r&#39;</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="n">elev</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">azim</span><span class="o">=-</span><span class="mi">90</span><span class="p">)</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>

        <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span><span class="s1">&#39;key_press_event&#39;</span><span class="p">,</span> <span class="n">on_key</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="ChromatogramAnalysis.stacked_plot">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.ChromatogramAnalysis.stacked_plot">[docs]</a>
    <span class="k">def</span> <span class="nf">stacked_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a stacked plot for the given dictionary of data.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        data_dict (dict): A dictionary with labels as keys and lists of values as values.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="c1"># Ensure all lists have the same length</span>
        <span class="n">max_length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="k">for</span> <span class="n">lst</span> <span class="ow">in</span> <span class="n">values</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_length</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">lst</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>

        <span class="c1"># Create the stack plot</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>

        <span class="c1"># ax.stackplot(range(max_length), *values, labels=labels)</span>

        <span class="c1"># Customize the plot</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Stacked Plot&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;X-axis&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Values&#39;</span><span class="p">)</span>

        <span class="c1"># Show the plot</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="ChromatogramAnalysis.resample_chromatograms">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.ChromatogramAnalysis.resample_chromatograms">[docs]</a>
    <span class="k">def</span> <span class="nf">resample_chromatograms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chrom1</span><span class="p">,</span> <span class="n">chrom2</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resamples two chromatograms to the same length using interpolation.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        chrom1 (dict or np.ndarray): The first chromatogram dictionary or array to be resampled.</span>
<span class="sd">        chrom2 (dict or np.ndarray): The second chromatogram dictionary or array to be resampled.</span>

<span class="sd">        Returns:</span>
<span class="sd">        tuple: The resampled chromatograms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chrom1</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chrom2</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="c1"># Use the minimum number of chromatogram values in any sample</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">length</span><span class="p">:</span>
                <span class="n">length</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">chrom1</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">chrom2</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
            <span class="n">resampled_chrom1</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">resample_chromatogram</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="n">start</span><span class="p">:],</span> <span class="n">length</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">chrom1</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="n">resampled_chrom2</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">resample_chromatogram</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="n">start</span><span class="p">:],</span> <span class="n">length</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">chrom2</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chrom1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">chrom2</span><span class="p">))</span>  <span class="c1"># Use the minimum length if chrom1 and chrom2 are arrays</span>
            <span class="n">resampled_chrom1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resample_chromatogram</span><span class="p">(</span><span class="n">chrom1</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>
            <span class="n">resampled_chrom2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resample_chromatogram</span><span class="p">(</span><span class="n">chrom2</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">resampled_chrom1</span><span class="p">,</span> <span class="n">resampled_chrom2</span></div>
</div>



<div class="viewcode-block" id="SyncChromatograms">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.SyncChromatograms">[docs]</a>
<span class="k">class</span> <span class="nc">SyncChromatograms</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SyncChromatograms Class</span>
<span class="sd">        =======================</span>

<span class="sd">        The `SyncChromatograms` class provides methods for synchronizing chromatographic data, focusing on aligning peaks and adjusting retention times across different chromatograms. This is essential for comparing chromatographic profiles from different wine samples.</span>

<span class="sd">        Key Features:</span>
<span class="sd">        -------------</span>
<span class="sd">        - **Peak Alignment**: Automatically detects and aligns peaks across chromatograms.</span>
<span class="sd">        - **Retention Time Adjustment**: Corrects differences in retention times to synchronize chromatograms.</span>
<span class="sd">        - **Segmented Analysis**: Allows for synchronization across multiple segments for greater accuracy.</span>

<span class="sd">        Usage:</span>
<span class="sd">        ------</span>
<span class="sd">        This class is ideal for researchers who need to compare chromatographic data across multiple wine samples, ensuring that peaks and retention times are aligned for accurate analysis.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">c2s</span><span class="p">,</span> <span class="n">ref_ms</span><span class="p">,</span> <span class="n">target_ms</span><span class="p">,</span> <span class="n">n_segments</span><span class="p">,</span> <span class="n">scales</span><span class="p">,</span> <span class="n">min_peaks</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">max_iterations</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                 <span class="n">threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">max_sep_threshold</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">peak_prominence</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">ndec</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c1</span> <span class="o">=</span> <span class="n">c1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c2</span> <span class="o">=</span> <span class="n">c2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c2s</span> <span class="o">=</span> <span class="n">c2s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref_ms</span> <span class="o">=</span> <span class="n">ref_ms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_ms</span> <span class="o">=</span> <span class="n">target_ms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_segments</span> <span class="o">=</span> <span class="n">n_segments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scales</span> <span class="o">=</span> <span class="n">scales</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_peaks</span> <span class="o">=</span> <span class="n">min_peaks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iterations</span> <span class="o">=</span> <span class="n">max_iterations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_sep_threshold</span> <span class="o">=</span> <span class="n">max_sep_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peak_prominence</span> <span class="o">=</span> <span class="n">peak_prominence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lag_res</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ndec</span> <span class="o">=</span> <span class="n">ndec</span>

<div class="viewcode-block" id="SyncChromatograms.scale_chromatogram">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.SyncChromatograms.scale_chromatogram">[docs]</a>
    <span class="k">def</span> <span class="nf">scale_chromatogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chrom</span><span class="p">))</span>
        <span class="n">scaled_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chrom</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale</span><span class="p">)</span>
        <span class="n">scaled_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">chrom</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">scaled_length</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s2">&quot;extrapolate&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">scaled_x</span><span class="p">)</span></div>


<div class="viewcode-block" id="SyncChromatograms.correct_segment">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.SyncChromatograms.correct_segment">[docs]</a>
    <span class="k">def</span> <span class="nf">correct_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segment</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">lag</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">lag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">segment</span>

        <span class="n">scaled_segment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_chromatogram</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lag</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">corrected_segment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">scaled_segment</span><span class="p">,</span> <span class="n">lag</span><span class="p">)</span>
            <span class="n">corrected_segment</span><span class="p">[:</span><span class="n">lag</span><span class="p">]</span> <span class="o">=</span> <span class="n">scaled_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">lag</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">corrected_segment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">scaled_segment</span><span class="p">,</span> <span class="n">lag</span><span class="p">)</span>
            <span class="n">corrected_segment</span><span class="p">[</span><span class="n">lag</span><span class="p">:]</span> <span class="o">=</span> <span class="n">scaled_segment</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">corrected_segment</span> <span class="o">=</span> <span class="n">scaled_segment</span>

        <span class="k">return</span> <span class="n">corrected_segment</span></div>


<div class="viewcode-block" id="SyncChromatograms.correct_matrix_lag">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.SyncChromatograms.correct_matrix_lag">[docs]</a>
    <span class="k">def</span> <span class="nf">correct_matrix_lag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">lag</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shifts the rows of a matrix by a specified lag, keeping the row content intact.</span>
<span class="sd">        New positions are padded with zeros.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        matrix : 2D array-like</span>
<span class="sd">            The matrix where each row contains data that should be shifted as a whole.</span>
<span class="sd">        lag : int</span>
<span class="sd">            The number of rows to shift. Positive values shift down, negative values shift up.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        shifted_matrix : numpy.ndarray</span>
<span class="sd">            The matrix with rows shifted by the specified lag, with padding for empty rows.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize a zero matrix with the same shape as the input matrix</span>
        <span class="n">shifted_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">lag</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Shift rows down, filling top rows with zeros</span>
            <span class="n">shifted_matrix</span><span class="p">[</span><span class="n">lag</span><span class="p">:]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[:</span><span class="o">-</span><span class="n">lag</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">lag</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Shift rows up, filling bottom rows with zeros</span>
            <span class="n">shifted_matrix</span><span class="p">[:</span><span class="n">lag</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="o">-</span><span class="n">lag</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># No shift, return the original matrix</span>
            <span class="n">shifted_matrix</span> <span class="o">=</span> <span class="n">matrix</span>

        <span class="k">return</span> <span class="n">shifted_matrix</span></div>


<div class="viewcode-block" id="SyncChromatograms.find_best_scale_and_lag_corr">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.SyncChromatograms.find_best_scale_and_lag_corr">[docs]</a>
    <span class="k">def</span> <span class="nf">find_best_scale_and_lag_corr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chrom1</span><span class="p">,</span> <span class="n">chrom2</span><span class="p">,</span> <span class="n">scales</span><span class="p">,</span> <span class="n">max_lag</span><span class="o">=</span><span class="mi">300</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the best scale and lag for cross-correlation between two chromatograms.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        chrom1 (np.array): The first chromatogram.</span>
<span class="sd">        chrom2 (np.array): The second chromatogram.</span>
<span class="sd">        scales (list of float): The list of scaling factors to try.</span>
<span class="sd">        max_lag (int): The maximum lag to consider for cross-correlation.</span>

<span class="sd">        Returns:</span>
<span class="sd">        float: The best scaling factor.</span>
<span class="sd">        int: The best lag.</span>
<span class="sd">        float: The highest cross-correlation value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">best_scale</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">best_lag</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">best_corr</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>

        <span class="k">for</span> <span class="n">scale</span> <span class="ow">in</span> <span class="n">scales</span><span class="p">:</span>

            <span class="c1"># Scale the first chromatogram</span>
            <span class="n">scaled_chrom2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_chromatogram</span><span class="p">(</span><span class="n">chrom2</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>

            <span class="c1"># Compute the cross-correlation</span>
            <span class="n">corr</span> <span class="o">=</span> <span class="n">correlate</span><span class="p">(</span><span class="n">chrom1</span><span class="p">,</span> <span class="n">scaled_chrom2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
            <span class="n">center</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">corr</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">corr</span> <span class="o">=</span> <span class="n">corr</span><span class="p">[</span><span class="n">center</span> <span class="o">-</span> <span class="n">max_lag</span><span class="p">:</span><span class="n">center</span> <span class="o">+</span> <span class="n">max_lag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="c1"># lags = np.arange(-len(chrom1) + 1, len(scaled_chrom2))</span>
            <span class="n">lags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">max_lag</span><span class="p">,</span> <span class="n">max_lag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Find the lag with the highest correlation within the specified range</span>
            <span class="n">max_lag_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">corr</span><span class="p">)</span>
            <span class="n">lag</span> <span class="o">=</span> <span class="n">lags</span><span class="p">[</span><span class="n">max_lag_idx</span><span class="p">]</span>
            <span class="n">corr_value</span> <span class="o">=</span> <span class="n">corr</span><span class="p">[</span><span class="n">max_lag_idx</span><span class="p">]</span>

            <span class="c1"># Update the best scale and lag if the correlation is higher</span>
            <span class="k">if</span> <span class="n">corr_value</span> <span class="o">&gt;</span> <span class="n">best_corr</span><span class="p">:</span>
                <span class="n">best_corr</span> <span class="o">=</span> <span class="n">corr_value</span>
                <span class="n">best_scale</span> <span class="o">=</span> <span class="n">scale</span>
                <span class="n">best_lag</span> <span class="o">=</span> <span class="n">lag</span>

        <span class="k">return</span> <span class="n">best_scale</span><span class="p">,</span> <span class="n">best_lag</span><span class="p">,</span> <span class="n">best_corr</span></div>


<div class="viewcode-block" id="SyncChromatograms.calculate_lag_profile">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.SyncChromatograms.calculate_lag_profile">[docs]</a>
    <span class="k">def</span> <span class="nf">calculate_lag_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">segment_length</span><span class="p">,</span> <span class="n">hop</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">lag_range</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">distance_metric</span><span class="o">=</span><span class="s1">&#39;l2&#39;</span><span class="p">,</span>
                              <span class="n">init_min_dist</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the lag of a segment ahead for each datapoint in c2 against c1 using L1 or L2 distance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c1 : numpy.ndarray</span>
<span class="sd">            Reference signal.</span>
<span class="sd">        c2 : numpy.ndarray</span>
<span class="sd">            Signal to be compared.</span>
<span class="sd">        segment_length : int</span>
<span class="sd">            Length of the segment ahead.</span>
<span class="sd">        hop : int, optional</span>
<span class="sd">            Step size for sliding the window. Default is 1.</span>
<span class="sd">        sigma : float, optional</span>
<span class="sd">            Standard deviation for Gaussian filter. Default is 20.</span>
<span class="sd">        lag_range : int, optional</span>
<span class="sd">            The range of lags to test on both sides. Default is 10.</span>
<span class="sd">        distance_metric : str, optional</span>
<span class="sd">            The distance metric to use for lag calculation (&#39;L1&#39; or &#39;L2&#39;). Default is &#39;L2&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Lags for each datapoint in c2.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">initial_global_alignment</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Compute initial global alignment using cross-correlation.&quot;&quot;&quot;</span>
            <span class="n">corr</span> <span class="o">=</span> <span class="n">correlate</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span>
            <span class="n">lag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">corr</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">lag</span>

        <span class="c1"># Initial global alignment</span>
        <span class="n">initial_lag</span> <span class="o">=</span> <span class="n">initial_global_alignment</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">c2</span><span class="p">,</span> <span class="n">initial_lag</span><span class="p">)</span>  <span class="c1"># Apply the global shift</span>

        <span class="n">lags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lags_location</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span> <span class="o">-</span> <span class="n">segment_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">hop</span><span class="p">):</span>
            <span class="n">segment_c2</span> <span class="o">=</span> <span class="n">c2</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">segment_length</span><span class="p">]</span>
            <span class="n">start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c1</span><span class="p">),</span> <span class="n">i</span> <span class="o">+</span> <span class="n">segment_length</span><span class="p">)</span>
            <span class="n">segment_c1</span> <span class="o">=</span> <span class="n">c1</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>

            <span class="c1"># Normalize and apply Gaussian filter</span>
            <span class="n">segment_c1_filtered</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">normalize_amplitude_zscore</span><span class="p">(</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">segment_c1</span><span class="p">,</span> <span class="n">sigma</span><span class="p">))</span>
            <span class="n">segment_c2_filtered</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">normalize_amplitude_zscore</span><span class="p">(</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">segment_c2</span><span class="p">,</span> <span class="n">sigma</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">distance_metric</span> <span class="o">==</span> <span class="s1">&#39;corr&#39;</span><span class="p">:</span>
                <span class="c1"># Calculate cross-correlation between the segments</span>
                <span class="n">corr</span> <span class="o">=</span> <span class="n">correlate</span><span class="p">(</span><span class="n">segment_c1_filtered</span><span class="p">,</span> <span class="n">segment_c2_filtered</span><span class="p">)</span>
                <span class="n">best_lag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">corr</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">segment_c2_filtered</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">best_lag</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">lag_range</span><span class="p">:</span>
                    <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Initialize the minimum distance and best lag</span>
                <span class="n">min_distance</span> <span class="o">=</span> <span class="n">init_min_dist</span>
                <span class="n">best_lag</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># Calculate distance for each possible lag within the specified range</span>
                <span class="k">for</span> <span class="n">lag</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">lag_range</span><span class="p">,</span> <span class="n">lag_range</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">shifted_segment_c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">segment_c2_filtered</span><span class="p">,</span> <span class="n">lag</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">distance_metric</span> <span class="o">==</span> <span class="s1">&#39;l2&#39;</span><span class="p">:</span>
                        <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">segment_c1_filtered</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">shifted_segment_c2</span><span class="p">)]</span> <span class="o">-</span> <span class="n">shifted_segment_c2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">distance_metric</span> <span class="o">==</span> <span class="s1">&#39;l1&#39;</span><span class="p">:</span>
                        <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">segment_c1_filtered</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">shifted_segment_c2</span><span class="p">)]</span> <span class="o">-</span> <span class="n">shifted_segment_c2</span><span class="p">))</span>
                    <span class="k">elif</span> <span class="n">distance_metric</span> <span class="o">==</span> <span class="s1">&#39;mse&#39;</span><span class="p">:</span>
                        <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">segment_c1_filtered</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">shifted_segment_c2</span><span class="p">)]</span> <span class="o">-</span> <span class="n">shifted_segment_c2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid distance metric. Use &#39;l1&#39; or &#39;l2&#39; or &#39;mse&#39;.&quot;</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">min_distance</span><span class="p">:</span>
                        <span class="n">best_shifted</span> <span class="o">=</span> <span class="n">shifted_segment_c2</span>
                        <span class="n">min_distance</span> <span class="o">=</span> <span class="n">distance</span>
                        <span class="n">best_lag</span> <span class="o">=</span> <span class="n">lag</span>

            <span class="n">lags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">best_lag</span> <span class="o">+</span> <span class="n">initial_lag</span><span class="p">)</span>
            <span class="n">lags_location</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="c1"># print(min_distance)</span>

        <span class="c1"># # Add one last point equal to the last one at 30000</span>
        <span class="n">lags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lags</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">lags_location</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">30000</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lags_location</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lags</span><span class="p">)</span></div>



<div class="viewcode-block" id="SyncChromatograms.lag_profile_from_correlation">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.SyncChromatograms.lag_profile_from_correlation">[docs]</a>
    <span class="k">def</span> <span class="nf">lag_profile_from_correlation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference_chromatogram</span><span class="p">,</span> <span class="n">target_chromatogram</span><span class="p">,</span> <span class="n">initial_slice_length</span><span class="p">,</span>
                                     <span class="n">hop_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">scan_range</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">apply_global_alignment</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                     <span class="n">max_slice_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">score</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes a lag (offset) profile between a reference and a target chromatogram by sliding a window</span>
<span class="sd">        along the target and finding the offset that maximizes the correlation with the corresponding region</span>
<span class="sd">        in the reference chromatogram.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reference_chromatogram : array-like</span>
<span class="sd">            The reference signal (chromatogram) used as the baseline.</span>
<span class="sd">        target_chromatogram : array-like</span>
<span class="sd">            The target signal (chromatogram) which will be aligned to the reference.</span>
<span class="sd">        initial_slice_length : int</span>
<span class="sd">            The starting window size (number of data points) used for correlation estimation.</span>
<span class="sd">        hop_size : int, optional</span>
<span class="sd">            The step size for sliding the window along the target chromatogram. Default is 1.</span>
<span class="sd">        scan_range : int, optional</span>
<span class="sd">            The maximum lag (in data points) to scan (in both positive and negative directions) for the best alignment.</span>
<span class="sd">            Default is 10.</span>
<span class="sd">        apply_global_alignment : bool, optional</span>
<span class="sd">            If True, performs a global alignment on the target chromatogram using a pre-computed best scale and lag.</span>
<span class="sd">            Default is True.</span>
<span class="sd">        max_slice_length : int or None, optional</span>
<span class="sd">            If provided and greater than initial_slice_length, allows dynamic adjustment of the slice length up to this value.</span>
<span class="sd">            Default is None.</span>
<span class="sd">        score : float, optional</span>
<span class="sd">            The initial correlation score baseline. Default is 0.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lags_location : ndarray</span>
<span class="sd">            An array of indices along the target chromatogram where the lag was computed.</span>
<span class="sd">        lags : ndarray</span>
<span class="sd">            An array of lag values (offsets) computed for each corresponding location in lags_location.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For TIC data, the x-axis is typically time. The function first (optionally) applies a global alignment</span>
<span class="sd">        to the target chromatogram, normalizes both signals, and then iterates over the target signal in steps.</span>
<span class="sd">        At each step, a window (or slice) is extracted and the correlation with the reference (shifted by various offsets)</span>
<span class="sd">        is computed. The offset that maximizes the correlation is recorded, and a lag profile is built along the target.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If global alignment is enabled, compute the best scale and lag on the first part of the signals</span>
        <span class="k">if</span> <span class="n">apply_global_alignment</span><span class="p">:</span>
            <span class="c1"># Apply a heavy Gaussian smoothing (sigma=50) to the first 10,000 points of both signals,</span>
            <span class="c1"># then find the best scale and lag (here scale is fixed since linspace(1.0, 1.0, 1) produces only 1 value)</span>
            <span class="n">best_scale</span><span class="p">,</span> <span class="n">best_lag</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_best_scale_and_lag_corr</span><span class="p">(</span>
                <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">reference_chromatogram</span><span class="p">[:</span><span class="mi">10000</span><span class="p">],</span> <span class="mi">50</span><span class="p">),</span>
                <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">target_chromatogram</span><span class="p">[:</span><span class="mi">10000</span><span class="p">],</span> <span class="mi">50</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                <span class="n">max_lag</span><span class="o">=</span><span class="mi">1000</span>
            <span class="p">)</span>
            <span class="c1"># Correct the target chromatogram using the found best scale and lag, then smooth lightly (sigma=5)</span>
            <span class="n">target_chromatogram_aligned</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">correct_segment</span><span class="p">(</span><span class="n">target_chromatogram</span><span class="p">,</span> <span class="n">best_scale</span><span class="p">,</span> <span class="n">best_lag</span><span class="p">),</span> <span class="mi">5</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">target_chromatogram_aligned</span> <span class="o">=</span> <span class="n">target_chromatogram</span>
            <span class="n">best_lag</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Normalize both signals to a [0,1] range (or similar) for consistent correlation measurement</span>
        <span class="n">reference_chromatogram</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">normalize_amplitude_minmax</span><span class="p">(</span><span class="n">reference_chromatogram</span><span class="p">)</span>
        <span class="n">target_chromatogram_aligned</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">normalize_amplitude_minmax</span><span class="p">(</span><span class="n">target_chromatogram_aligned</span><span class="p">)</span>

        <span class="c1"># Define a safe boundary to ensure the window is fully contained within the signal</span>
        <span class="n">safe_boundary</span> <span class="o">=</span> <span class="n">initial_slice_length</span> <span class="o">+</span> <span class="n">scan_range</span>

        <span class="n">lags</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># List to store computed lag values at each window location</span>
        <span class="n">lags_location</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># List to store the corresponding locations (indices)</span>

        <span class="c1"># Slide through the target chromatogram starting from &#39;safe_boundary&#39; until &#39;len - safe_boundary&#39;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">safe_boundary</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_chromatogram_aligned</span><span class="p">)</span> <span class="o">-</span> <span class="n">safe_boundary</span><span class="p">,</span> <span class="n">hop_size</span><span class="p">):</span>
            <span class="c1"># Determine the slice length: if max_slice_length is provided and larger than initial_slice_length,</span>
            <span class="c1"># adjust the slice length dynamically (but not exceeding max_slice_length).</span>
            <span class="k">if</span> <span class="n">max_slice_length</span> <span class="ow">and</span> <span class="n">max_slice_length</span> <span class="o">&gt;</span> <span class="n">initial_slice_length</span><span class="p">:</span>
                <span class="n">available_slice_length</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">target_chromatogram_aligned</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">slice_length</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">available_slice_length</span><span class="p">,</span> <span class="n">max_slice_length</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">slice_length</span> <span class="o">=</span> <span class="n">initial_slice_length</span>

            <span class="n">half_slice</span> <span class="o">=</span> <span class="n">slice_length</span> <span class="o">//</span> <span class="mi">2</span>

            <span class="n">best_curr_lag</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Best offset found at this position (relative to current index)</span>
            <span class="n">best_score</span> <span class="o">=</span> <span class="n">score</span>  <span class="c1"># Best correlation score observed at this position</span>

            <span class="c1"># Test offsets within the defined scan_range</span>
            <span class="k">for</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">scan_range</span><span class="p">,</span> <span class="n">scan_range</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">reference_center</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">offset</span>
                <span class="n">start_ref_idx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">reference_center</span> <span class="o">-</span> <span class="n">half_slice</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">end_ref_idx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">reference_center</span> <span class="o">+</span> <span class="n">half_slice</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">reference_chromatogram</span><span class="p">))</span>
                <span class="n">reference_slice</span> <span class="o">=</span> <span class="n">reference_chromatogram</span><span class="p">[</span><span class="n">start_ref_idx</span><span class="p">:</span><span class="n">end_ref_idx</span><span class="p">]</span>

                <span class="n">start_idx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">half_slice</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">end_idx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">half_slice</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_chromatogram_aligned</span><span class="p">))</span>
                <span class="n">target_slice</span> <span class="o">=</span> <span class="n">target_chromatogram_aligned</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">]</span>

                <span class="c1"># Ensure both slices are trimmed to the same length</span>
                <span class="n">min_length</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reference_slice</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_slice</span><span class="p">))</span>
                <span class="n">reference_slice</span> <span class="o">=</span> <span class="n">reference_slice</span><span class="p">[:</span><span class="n">min_length</span><span class="p">]</span>
                <span class="n">target_slice</span> <span class="o">=</span> <span class="n">target_slice</span><span class="p">[:</span><span class="n">min_length</span><span class="p">]</span>

                <span class="c1"># Compute the Pearson correlation coefficient between the two slices</span>
                <span class="n">correlation_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">reference_slice</span><span class="p">,</span> <span class="n">target_slice</span><span class="p">)</span>
                <span class="n">normalized_correlation</span> <span class="o">=</span> <span class="n">correlation_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="c1"># If this correlation is better than any previously observed, update the best score and lag</span>
                <span class="k">if</span> <span class="n">normalized_correlation</span> <span class="o">&gt;</span> <span class="n">best_score</span><span class="p">:</span>
                    <span class="n">best_score</span> <span class="o">=</span> <span class="n">normalized_correlation</span>
                    <span class="n">best_curr_lag</span> <span class="o">=</span> <span class="n">offset</span>

            <span class="c1"># Append the cumulative lag (global best lag plus the current best offset) and the position</span>
            <span class="n">lags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">best_lag</span> <span class="o">+</span> <span class="n">best_curr_lag</span><span class="p">)</span>
            <span class="n">lags_location</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="c1"># Ensure the lag profile spans the full length by repeating the first and last values at the boundaries.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lags</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lags</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">lags</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">lags_location</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">lags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lags</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">lags_location</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">target_chromatogram_aligned</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lags_location</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lags</span><span class="p">)</span></div>



<div class="viewcode-block" id="SyncChromatograms.lag_profile_from_ms_data">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.SyncChromatograms.lag_profile_from_ms_data">[docs]</a>
    <span class="k">def</span> <span class="nf">lag_profile_from_ms_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference_chromatogram</span><span class="p">,</span> <span class="n">target_chromatogram</span><span class="p">,</span>
                                 <span class="n">reference_matrix</span><span class="p">,</span> <span class="n">target_matrix</span><span class="p">,</span> <span class="n">num_segments</span><span class="p">,</span> <span class="n">sep_thresh</span><span class="p">,</span> <span class="n">show_corrections</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                 <span class="n">min_corr</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the lag profile between two chromatograms using MS data.</span>

<span class="sd">        This function divides the reference chromatogram into segments, identifies maximum peaks within each segment,</span>
<span class="sd">        and finds the best-matching peak in the target chromatogram within a specified retention time window.</span>
<span class="sd">        Matching is based on the Pearson correlation coefficient of the corresponding rows from the reference and</span>
<span class="sd">        target MS data matrices. The function returns the indices of matched peaks in the target chromatogram</span>
<span class="sd">        and the index differences (lags) between matched peaks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reference_chromatogram : array-like</span>
<span class="sd">            The reference chromatogram used as a baseline for alignment.</span>
<span class="sd">        target_chromatogram : array-like</span>
<span class="sd">            The target chromatogram to be aligned with the reference.</span>
<span class="sd">        reference_matrix : 2D array-like</span>
<span class="sd">            The mass spectrometry (MS) data matrix corresponding to the reference chromatogram.</span>
<span class="sd">            Each row corresponds to a retention time, and each column corresponds to an m/z channel.</span>
<span class="sd">        target_matrix : 2D array-like</span>
<span class="sd">            The MS data matrix corresponding to the target chromatogram.</span>
<span class="sd">        num_segments : int</span>
<span class="sd">            The number of segments to divide the chromatogram into for peak detection.</span>
<span class="sd">        sep_thresh : int</span>
<span class="sd">            The maximum allowed retention time difference (in indices) between a reference peak</span>
<span class="sd">            and its matching peak in the target chromatogram.</span>
<span class="sd">        show_corrections : bool, optional (default=False)</span>
<span class="sd">            If True, prints information about each peak match, including the reference peak index,</span>
<span class="sd">            target peak index, and the index difference.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        locations : numpy.ndarray</span>
<span class="sd">            An array of indices representing the locations of matched peaks in the target chromatogram.</span>
<span class="sd">        index_differences : numpy.ndarray</span>
<span class="sd">            An array of index differences between each reference peak and its best match in the target chromatogram.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            - If any segment of the reference chromatogram does not contain a peak.</span>
<span class="sd">            - If any segment of the target chromatogram does not contain a peak.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The chromatograms are divided into segments using `self.ensure_peaks_in_segments()`.</span>
<span class="sd">        - The maximum peak in each segment is selected as the reference peak.</span>
<span class="sd">        - For each reference peak, the function searches within a window defined by `sep_thresh` in the target chromatogram.</span>
<span class="sd">        - The Pearson correlation coefficient is calculated between the MS rows at each candidate peak index.</span>
<span class="sd">        - The best match is chosen based on the highest Pearson correlation (&gt; 0.98) that also exceeds previous matches.</span>
<span class="sd">        - Matching peaks must have increasing indices to avoid backward shifts in retention time.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; locations, index_differences = obj.lag_profile_from_ms_data(</span>
<span class="sd">        ...     reference_chromatogram, target_chromatogram, reference_matrix, target_matrix,</span>
<span class="sd">        ...     num_segments=50, sep_thresh=100, show_corrections=True</span>
<span class="sd">        ... )</span>
<span class="sd">        Reference peak at index 1200 best matches target at index 1195 (difference: 5)</span>
<span class="sd">        Reference peak at index 3400 best matches target at index 3398 (difference: 2)</span>
<span class="sd">        &gt;&gt;&gt; print(locations)</span>
<span class="sd">        [1195, 3398, 4500, 6200]</span>
<span class="sd">        &gt;&gt;&gt; print(index_differences)</span>
<span class="sd">        [5, 2, -3, 1]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">is_larger_than_last</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">lst</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Check if the value is larger than the last element of the list.</span>
<span class="sd">            If the list is empty, return True.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            value : int or float</span>
<span class="sd">                The value to compare.</span>
<span class="sd">            lst : list of int or float</span>
<span class="sd">                The list whose last element is compared against the value.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            bool</span>
<span class="sd">                True if the value is larger than the last element of the list or if the list is empty, False otherwise.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">lst</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">lst</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Ensure peaks in segments of the reference chromatogram</span>
        <span class="n">reference_peaks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">reference_chromatogram</span><span class="p">)</span>
        <span class="n">reference_peaks</span><span class="p">,</span> <span class="n">valid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensure_peaks_in_segments</span><span class="p">(</span>
            <span class="n">reference_chromatogram</span><span class="p">,</span> <span class="n">reference_peaks</span><span class="p">,</span> <span class="n">num_segments</span><span class="o">=</span><span class="n">num_segments</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Some segments in the reference chromatogram do not have peaks. Adjust segmentation parameters.&quot;</span><span class="p">)</span>

        <span class="c1"># Ensure peaks in segments of the target chromatogram (3x more segments for finer resolution)</span>
        <span class="n">target_peaks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">target_chromatogram</span><span class="p">)</span>
        <span class="n">target_peaks</span><span class="p">,</span> <span class="n">valid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensure_peaks_in_segments</span><span class="p">(</span>
            <span class="n">target_chromatogram</span><span class="p">,</span> <span class="n">target_peaks</span><span class="p">,</span> <span class="n">num_segments</span><span class="o">=</span><span class="mi">3</span> <span class="o">*</span> <span class="n">num_segments</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Some segments in the target chromatogram do not have peaks. Adjust segmentation parameters.&quot;</span><span class="p">)</span>

        <span class="n">index_differences</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">locations</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Iterate over each reference peak and find the best match in the target</span>
        <span class="k">for</span> <span class="n">peak_index</span> <span class="ow">in</span> <span class="n">reference_peaks</span><span class="p">:</span>
            <span class="c1"># Extract and normalize the corresponding row from the reference MS matrix</span>
            <span class="n">reference_row</span> <span class="o">=</span> <span class="n">reference_matrix</span><span class="p">[</span><span class="n">peak_index</span><span class="p">]</span>
            <span class="n">reference_row</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">normalize_amplitude_zscore</span><span class="p">(</span><span class="n">reference_row</span><span class="p">)</span>

            <span class="c1"># Initialize maximum correlation and best match index</span>
            <span class="n">max_correlation</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">best_match_index</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># Search within the target peaks within the retention time window</span>
            <span class="k">for</span> <span class="n">target_index</span> <span class="ow">in</span> <span class="n">target_peaks</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">peak_index</span> <span class="o">-</span> <span class="n">target_index</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sep_thresh</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">target_row</span> <span class="o">=</span> <span class="n">target_matrix</span><span class="p">[</span><span class="n">target_index</span><span class="p">]</span>
                <span class="n">target_row</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">normalize_amplitude_zscore</span><span class="p">(</span><span class="n">target_row</span><span class="p">)</span>

                <span class="c1"># Calculate Pearson correlation</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">reference_row</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">target_row</span><span class="p">))</span> \
                        <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">reference_row</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">target_row</span><span class="p">)):</span>
                    <span class="k">continue</span>  <span class="c1"># Skip invalid rows</span>
                <span class="n">correlation</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">pearsonr</span><span class="p">(</span><span class="n">reference_row</span><span class="p">,</span> <span class="n">target_row</span><span class="p">)</span>

                <span class="c1"># Choose the best match with correlation &gt; 0.98 and increasing index order</span>
                <span class="k">if</span> <span class="p">(</span>
                        <span class="n">correlation</span> <span class="o">&gt;</span> <span class="n">min_corr</span>
                        <span class="ow">and</span> <span class="n">correlation</span> <span class="o">&gt;</span> <span class="n">max_correlation</span>
                        <span class="ow">and</span> <span class="n">is_larger_than_last</span><span class="p">(</span><span class="n">target_index</span><span class="p">,</span> <span class="n">locations</span><span class="p">)):</span>
                    <span class="n">max_correlation</span> <span class="o">=</span> <span class="n">correlation</span>
                    <span class="n">best_match_index</span> <span class="o">=</span> <span class="n">target_index</span>

            <span class="c1"># Store the index difference if a match was found</span>
            <span class="k">if</span> <span class="n">best_match_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">index_difference</span> <span class="o">=</span> <span class="n">peak_index</span> <span class="o">-</span> <span class="n">best_match_index</span>
                <span class="n">index_differences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index_difference</span><span class="p">)</span>
                <span class="n">locations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">best_match_index</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">show_corrections</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Reference peak at index </span><span class="si">{</span><span class="n">peak_index</span><span class="si">}</span><span class="s2"> best matches target at index </span><span class="si">{</span><span class="n">best_match_index</span><span class="si">}</span><span class="s2"> &quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;(difference: </span><span class="si">{</span><span class="n">index_difference</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">locations</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">index_differences</span><span class="p">)</span></div>




<div class="viewcode-block" id="SyncChromatograms.lag_profile_from_peaks">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.SyncChromatograms.lag_profile_from_peaks">[docs]</a>
    <span class="k">def</span> <span class="nf">lag_profile_from_peaks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference_chromatogram</span><span class="p">,</span> <span class="n">target_chromatogram</span><span class="p">,</span> <span class="n">alignment_tolerance</span><span class="p">,</span> <span class="n">num_segments</span><span class="p">,</span>
                               <span class="n">apply_global_alignment</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">only_shift</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a lag profile from peaks in two chromatograms by aligning segments.</span>

<span class="sd">        This function aligns peaks in `target_chromatogram` to peaks in `reference_chromatogram` and adjusts the chromatogram</span>
<span class="sd">        `target_chromatogram` accordingly. It then computes the lag profile based on the difference in peak positions between</span>
<span class="sd">        the two chromatograms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reference_chromatogram : array-like</span>
<span class="sd">            The reference chromatogram (e.g. the mean chromatogram of a given dataset).</span>
<span class="sd">        target_chromatogram : array-like</span>
<span class="sd">            The chromatogram to be aligned with `reference_chromatogram`.</span>
<span class="sd">        alignment_tolerance : float</span>
<span class="sd">            The maximum allowed distance between aligned peaks in `reference_chromatogram` and `target_chromatogram`. Peaks in</span>
<span class="sd">            `target_chromatogram` that are too far from the corresponding peak in `reference_chromatogram` will be skipped.</span>
<span class="sd">        num_segments : int</span>
<span class="sd">            The number of segments to divide the chromatograms into for peak alignment. The highest peak from each segment</span>
<span class="sd">            is typically selected.</span>
<span class="sd">        apply_global_alignment : bool, optional</span>
<span class="sd">            If True, apply a global time shift to align the chromatograms before local adjustments. Default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lags_location : numpy.ndarray</span>
<span class="sd">            The locations of the lags in `target_chromatogram` after alignment.</span>
<span class="sd">        lags : numpy.ndarray</span>
<span class="sd">            The lag values corresponding to each peak after alignment.</span>
<span class="sd">        target_chromatogram_aligned : numpy.ndarray</span>
<span class="sd">            The aligned chromatogram `target_chromatogram` after applying the per-section adjustments.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If some segments in `target_chromatogram` do not have peaks.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method uses a combination of global and local alignment to synchronize the chromatograms. The global alignment</span>
<span class="sd">        is applied first (if `apply_global_alignment` is True), followed by local adjustments in each segment.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; lags_location, lags, target_chromatogram_aligned = obj.lag_profile_from_peaks(reference_chromatogram, target_chromatogram, alignment_tolerance=50, num_segments=50)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">apply_global_alignment</span><span class="p">:</span>
            <span class="c1"># Apply global alignment by finding the best scale (currently turned off) and lag</span>
            <span class="n">best_scale</span><span class="p">,</span> <span class="n">best_lag</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_best_scale_and_lag_corr</span><span class="p">(</span>
                <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">reference_chromatogram</span><span class="p">[:(</span><span class="nb">len</span><span class="p">(</span><span class="n">reference_chromatogram</span><span class="p">)</span> <span class="o">//</span> <span class="mi">3</span><span class="p">)],</span> <span class="mi">50</span><span class="p">),</span>
                <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">target_chromatogram</span><span class="p">[:(</span><span class="nb">len</span><span class="p">(</span><span class="n">target_chromatogram</span><span class="p">)</span> <span class="o">//</span> <span class="mi">3</span><span class="p">)],</span> <span class="mi">50</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                <span class="n">max_lag</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">100</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndec</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">target_chromatogram_aligned</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">correct_segment</span><span class="p">(</span><span class="n">target_chromatogram</span><span class="p">,</span> <span class="n">best_scale</span><span class="p">,</span> <span class="n">best_lag</span><span class="p">),</span> <span class="mi">5</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">only_shift</span><span class="p">:</span>
                <span class="c1"># return np.linspace(0, 30000, num=num_segments + 2), np.full(num_segments + 2, best_lag), target_chromatogram_aligned</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_chromatogram_aligned</span><span class="p">),</span> <span class="n">num</span><span class="o">=</span><span class="n">num_segments</span> <span class="o">+</span> <span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">num_segments</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span>
                                                                                                   <span class="n">best_lag</span><span class="p">)</span>

            <span class="n">accum_lag</span> <span class="o">=</span> <span class="n">best_lag</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">target_chromatogram_aligned</span> <span class="o">=</span> <span class="n">target_chromatogram</span>
            <span class="n">accum_lag</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Find peaks in the reference chromatogram</span>
        <span class="n">reference_peaks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">reference_chromatogram</span><span class="p">)</span>

        <span class="c1"># Remove peak at a known standard position in the reference chromatogram</span>
        <span class="n">reference_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">reference_peaks</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">reference_peaks</span> <span class="o">==</span> <span class="mi">8918</span><span class="p">))</span>

        <span class="c1"># Find peaks in the aligned target chromatogram</span>
        <span class="n">target_peaks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">target_chromatogram_aligned</span><span class="p">)</span>

        <span class="c1"># Ensure there is a maximum of one peak per segment (the highest) in both chromatograms</span>
        <span class="n">reference_peaks</span><span class="p">,</span> <span class="n">valid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensure_peaks_in_segments</span><span class="p">(</span>
            <span class="n">reference_chromatogram</span><span class="p">,</span> <span class="n">reference_peaks</span><span class="p">,</span> <span class="n">num_segments</span><span class="o">=</span><span class="n">num_segments</span>
        <span class="p">)</span>
        <span class="n">target_peaks</span><span class="p">,</span> <span class="n">valid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensure_peaks_in_segments</span><span class="p">(</span>
            <span class="n">target_chromatogram_aligned</span><span class="p">,</span> <span class="n">target_peaks</span><span class="p">,</span> <span class="n">num_segments</span><span class="o">=</span><span class="n">num_segments</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please change parameters, some segments in chromatograms do not have peaks.&quot;</span><span class="p">)</span>

        <span class="c1"># Add zero to scale the first part of the chromatogram up to the first peak</span>
        <span class="n">reference_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="n">reference_peaks</span><span class="p">])</span>
        <span class="n">target_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="n">target_peaks</span><span class="p">])</span>
        <span class="n">num_initial_peaks</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">target_peaks</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">reference_peaks</span><span class="p">))</span>

        <span class="n">lags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lags_location</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_initial_peaks</span><span class="p">):</span>
            <span class="c1"># Select the previous and current peaks from the target chromatogram</span>
            <span class="n">target_peak_prev</span> <span class="o">=</span> <span class="n">target_peaks</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">target_peak</span> <span class="o">=</span> <span class="n">target_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># Initialize the corresponding previous peak in the reference chromatogram</span>
            <span class="n">reference_peak_prev</span> <span class="o">=</span> <span class="n">target_peak_prev</span>

            <span class="c1"># Find the closest peak in the reference chromatogram to the current target peak</span>
            <span class="n">reference_peak</span> <span class="o">=</span> <span class="n">reference_peaks</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">reference_peaks</span> <span class="o">-</span> <span class="n">target_peak</span><span class="p">))]</span>

            <span class="c1"># Skip if the current peak in target is too far from the reference or in the wrong order</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">reference_peak</span> <span class="o">-</span> <span class="n">target_peak</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">alignment_tolerance</span> <span class="ow">or</span> <span class="n">reference_peak</span> <span class="o">&lt;=</span> <span class="n">reference_peak_prev</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_peaks</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">continue</span>

            <span class="c1"># Accumulate the lag</span>
            <span class="n">accum_lag</span> <span class="o">+=</span> <span class="n">reference_peak</span> <span class="o">-</span> <span class="n">target_peak</span>

            <span class="c1"># Calculate the scaling factor and adjust the target segment</span>
            <span class="n">interval_target</span> <span class="o">=</span> <span class="n">target_peak</span> <span class="o">-</span> <span class="n">target_peak_prev</span>
            <span class="n">interval_reference</span> <span class="o">=</span> <span class="n">reference_peak</span> <span class="o">-</span> <span class="n">reference_peak_prev</span>
            <span class="k">if</span> <span class="n">interval_target</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">interval_reference</span> <span class="o">/</span> <span class="n">interval_target</span>
            <span class="n">start</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">target_peak_prev</span><span class="p">,</span> <span class="n">target_peak</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">target_peak_prev</span><span class="p">,</span> <span class="n">target_peak</span><span class="p">)</span>
            <span class="n">target_segment</span> <span class="o">=</span> <span class="n">target_chromatogram_aligned</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
            <span class="n">scaled_segment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_chromatogram</span><span class="p">(</span><span class="n">target_segment</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>

            <span class="c1"># Update the aligned target chromatogram with the scaled segment</span>
            <span class="n">target_chromatogram_aligned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span>
                <span class="n">target_chromatogram_aligned</span><span class="p">[:</span><span class="n">start</span><span class="p">],</span> <span class="n">scaled_segment</span><span class="p">,</span> <span class="n">target_chromatogram_aligned</span><span class="p">[</span><span class="n">end</span><span class="p">:]</span>
            <span class="p">])</span>

            <span class="c1"># Recalculate peaks in the updated target chromatogram</span>
            <span class="n">target_peaks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">target_chromatogram_aligned</span><span class="p">)</span>
            <span class="n">target_peaks</span><span class="p">,</span> <span class="n">valid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensure_peaks_in_segments</span><span class="p">(</span>
                <span class="n">target_chromatogram_aligned</span><span class="p">,</span> <span class="n">target_peaks</span><span class="p">,</span> <span class="n">num_segments</span><span class="o">=</span><span class="n">num_segments</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please change parameters, some segments do not have peaks.&quot;</span><span class="p">)</span>
            <span class="n">target_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="n">target_peaks</span><span class="p">])</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_peaks</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_initial_peaks</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_peaks</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="c1"># Skip peaks that would move backwards in retention time</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lags_location</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">target_peak</span> <span class="o">+</span> <span class="n">accum_lag</span> <span class="o">&lt;=</span> <span class="n">loc</span> <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">lags_location</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># Append the accumulated lag and its location</span>
            <span class="n">lags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">accum_lag</span><span class="p">)</span>
            <span class="n">lags_location</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target_peak</span> <span class="o">+</span> <span class="n">accum_lag</span><span class="p">)</span>

        <span class="c1"># Ensure the first lag is consistent with the rest</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lags</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lags</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">lags</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">lags_location</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">lags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lags</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">lags_location</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">30000</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lags_location</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lags</span><span class="p">),</span> <span class="n">target_chromatogram_aligned</span></div>


<div class="viewcode-block" id="SyncChromatograms.lag_profile_moving_peaks_individually">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.SyncChromatograms.lag_profile_moving_peaks_individually">[docs]</a>
    <span class="k">def</span> <span class="nf">lag_profile_moving_peaks_individually</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">reference_chromatogram</span><span class="p">,</span> <span class="n">target_chromatogram</span><span class="p">,</span> <span class="n">alignment_tolerance</span><span class="p">,</span> <span class="n">num_segments</span><span class="p">,</span> <span class="n">apply_global_alignment</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">scan_range</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">peak_order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">interval_after</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">min_avg_peak_distance</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Align peaks between a reference signal and a target signal by moving target peaks independently,</span>
<span class="sd">        and calculate the lag profile. The peaks are moved by rescaling the intervals with their adjacent peaks to both</span>
<span class="sd">         left and right of each peak.</span>
<span class="sd">        .</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reference_chromatogram : array-like</span>
<span class="sd">            The reference chromatogram used for peak alignment.</span>
<span class="sd">        target_chromatogram : array-like</span>
<span class="sd">            The target chromatogram to be aligned with the reference signal.</span>
<span class="sd">        alignment_tolerance : float</span>
<span class="sd">            The maximum allowed distance between aligned peaks.</span>
<span class="sd">        num_segments : int</span>
<span class="sd">            Number of segments to divide the signal into.</span>
<span class="sd">        apply_global_alignment : bool, optional</span>
<span class="sd">            If True, apply a global time shift before peak alignment. Default is True.</span>
<span class="sd">        scan_range : int, optional</span>
<span class="sd">            The range within which to scan for matching peaks. Default is 1.</span>
<span class="sd">        peak_order : int, optional</span>
<span class="sd">            The rank of the peak to select within each segment. Default is 0 (highest peak).</span>
<span class="sd">        interval_after : int, optional</span>
<span class="sd">            Interval length after the peak to improve similarity measure. Default is 500.</span>
<span class="sd">        min_avg_peak_distance : float, optional</span>
<span class="sd">            Minimum average peak distance required for accepting the scaling. Default is 50.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Locations of the lags in the target signal after alignment.</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The lag values corresponding to each peak after alignment.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#### Local functions ####</span>
        <span class="k">def</span> <span class="nf">calculate_average_peak_distance</span><span class="p">(</span><span class="n">signal1</span><span class="p">,</span> <span class="n">signal2</span><span class="p">,</span> <span class="n">prominence</span><span class="o">=</span><span class="mf">1E-6</span><span class="p">,</span> <span class="n">distance_type</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Calculate the average distance between peaks in two signals.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            signal1, signal2 : array-like</span>
<span class="sd">                The signals for which peak distances are calculated.</span>
<span class="sd">            prominence : float, optional</span>
<span class="sd">                The prominence of peaks to consider. Default is 1E-6.</span>
<span class="sd">            distance_type : str, optional</span>
<span class="sd">                Type of distance to calculate (&#39;mean&#39; or &#39;mean_square&#39;). Default is &#39;mean&#39;.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            float</span>
<span class="sd">                The average distance between peaks.</span>
<span class="sd">            list</span>
<span class="sd">                List of distances between matched peaks.</span>
<span class="sd">            numpy.ndarray</span>
<span class="sd">                Peaks in the first signal.</span>
<span class="sd">            numpy.ndarray</span>
<span class="sd">                Peaks in the second signal.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">peaks1</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">signal1</span><span class="p">,</span> <span class="n">prominence</span><span class="o">=</span><span class="n">prominence</span><span class="p">)</span>
            <span class="n">peaks2</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">signal2</span><span class="p">,</span> <span class="n">prominence</span><span class="o">=</span><span class="n">prominence</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No peaks found in one of the signals&quot;</span><span class="p">)</span>

            <span class="n">distances</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">peak1</span> <span class="ow">in</span> <span class="n">peaks1</span><span class="p">:</span>
                <span class="n">closest_peak2</span> <span class="o">=</span> <span class="n">peaks2</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">peaks2</span> <span class="o">-</span> <span class="n">peak1</span><span class="p">))]</span>
                <span class="n">distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">peak1</span> <span class="o">-</span> <span class="n">closest_peak2</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">distance_type</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
                <span class="n">average_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">distance_type</span> <span class="o">==</span> <span class="s1">&#39;mean_square&#39;</span><span class="p">:</span>
                <span class="n">average_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">distances</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid distance_type. Choose &#39;mean&#39; or &#39;mean_square&#39;.&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">average_distance</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">peaks1</span><span class="p">,</span> <span class="n">peaks2</span>

        <span class="k">def</span> <span class="nf">calculate_weighted_average_peak_distance</span><span class="p">(</span><span class="n">signal1</span><span class="p">,</span> <span class="n">signal2</span><span class="p">,</span> <span class="n">prominence</span><span class="o">=</span><span class="mf">1E-6</span><span class="p">,</span> <span class="n">distance_type</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span>
                                                     <span class="n">weight_power</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Calculate the weighted average distance between peaks in two signals, with weights based on the relative heights of both peaks.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            signal1, signal2 : array-like</span>
<span class="sd">                The signals for which peak distances are calculated.</span>
<span class="sd">            prominence : float, optional</span>
<span class="sd">                The prominence of peaks to consider. Default is 1E-6.</span>
<span class="sd">            distance_type : str, optional</span>
<span class="sd">                Type of distance to calculate (&#39;mean&#39; or &#39;mean_square&#39;). Default is &#39;mean&#39;.</span>
<span class="sd">            weight_power : float, optional</span>
<span class="sd">                The power to raise the relative height ratio, allowing for non-linearity in the weighting. Default is 1 (linear).</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            float</span>
<span class="sd">                The weighted average distance between peaks.</span>
<span class="sd">            list</span>
<span class="sd">                List of distances between matched peaks.</span>
<span class="sd">            numpy.ndarray</span>
<span class="sd">                Peaks in the first signal.</span>
<span class="sd">            numpy.ndarray</span>
<span class="sd">                Peaks in the second signal.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">peaks1</span><span class="p">,</span> <span class="n">properties1</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">signal1</span><span class="p">,</span> <span class="n">prominence</span><span class="o">=</span><span class="n">prominence</span><span class="p">)</span>
            <span class="n">peaks2</span><span class="p">,</span> <span class="n">properties2</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">signal2</span><span class="p">,</span> <span class="n">prominence</span><span class="o">=</span><span class="n">prominence</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No peaks found in one of the signals&quot;</span><span class="p">)</span>

            <span class="n">distances</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Store weights based on relative peak heights</span>
            <span class="k">for</span> <span class="n">peak1</span><span class="p">,</span> <span class="n">height1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">peaks1</span><span class="p">,</span> <span class="n">properties1</span><span class="p">[</span><span class="s2">&quot;prominences&quot;</span><span class="p">]):</span>
                <span class="c1"># Find the closest peak in signal2 to peak1</span>
                <span class="n">closest_peak2_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">peaks2</span> <span class="o">-</span> <span class="n">peak1</span><span class="p">))</span>
                <span class="n">closest_peak2</span> <span class="o">=</span> <span class="n">peaks2</span><span class="p">[</span><span class="n">closest_peak2_idx</span><span class="p">]</span>
                <span class="n">height2</span> <span class="o">=</span> <span class="n">properties2</span><span class="p">[</span><span class="s2">&quot;prominences&quot;</span><span class="p">][</span><span class="n">closest_peak2_idx</span><span class="p">]</span>  <span class="c1"># Get height of the closest peak2</span>

                <span class="c1"># Calculate the distance between the two peaks</span>
                <span class="n">distance</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">peak1</span> <span class="o">-</span> <span class="n">closest_peak2</span><span class="p">)</span>
                <span class="n">distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span>

                <span class="c1"># Calculate the relative weight based on peak heights</span>
                <span class="n">relative_height_ratio</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">height1</span><span class="p">,</span> <span class="n">height2</span><span class="p">)</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">height1</span><span class="p">,</span> <span class="n">height2</span><span class="p">)</span>

                <span class="c1"># Apply the weight_power to introduce non-linearity</span>
                <span class="n">weight</span> <span class="o">=</span> <span class="n">relative_height_ratio</span> <span class="o">**</span> <span class="n">weight_power</span>
                <span class="n">weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>

            <span class="c1"># Normalize the weights so they sum to 1</span>
            <span class="n">normalized_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>

            <span class="c1"># Compute the weighted average distance</span>
            <span class="k">if</span> <span class="n">distance_type</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
                <span class="n">weighted_average_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">normalized_weights</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">distance_type</span> <span class="o">==</span> <span class="s1">&#39;mean_square&#39;</span><span class="p">:</span>
                <span class="n">weighted_average_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">distances</span><span class="p">),</span> <span class="n">weights</span><span class="o">=</span><span class="n">normalized_weights</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid distance_type. Choose &#39;mean&#39; or &#39;mean_square&#39;.&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">weighted_average_distance</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">peaks1</span><span class="p">,</span> <span class="n">peaks2</span>

        <span class="c1">#### End local functions ####</span>

        <span class="k">if</span> <span class="n">apply_global_alignment</span><span class="p">:</span>
            <span class="c1"># Apply a global time shift using the best scale and lag</span>
            <span class="n">best_scale</span><span class="p">,</span> <span class="n">best_lag</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_best_scale_and_lag_corr</span><span class="p">(</span>
                <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">reference_chromatogram</span><span class="p">[:</span><span class="mi">10000</span><span class="p">],</span> <span class="mi">50</span><span class="p">),</span>
                <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">target_chromatogram</span><span class="p">[:</span><span class="mi">10000</span><span class="p">],</span> <span class="mi">50</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">target_chromatogram_aligned</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">correct_segment</span><span class="p">(</span><span class="n">target_chromatogram</span><span class="p">,</span> <span class="n">best_scale</span><span class="p">,</span> <span class="n">best_lag</span><span class="p">)</span>
            <span class="n">accumulated_lag</span> <span class="o">=</span> <span class="n">best_lag</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">target_chromatogram_aligned</span> <span class="o">=</span> <span class="n">target_chromatogram</span>
            <span class="n">accumulated_lag</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">reference_peaks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">reference_chromatogram</span><span class="p">)</span>
        <span class="n">all_target_peaks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">target_chromatogram_aligned</span><span class="p">)</span>

        <span class="c1"># Ensure peaks are within segments in the target signal</span>
        <span class="n">target_peaks</span><span class="p">,</span> <span class="n">valid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensure_peaks_in_segments</span><span class="p">(</span>
            <span class="n">target_chromatogram_aligned</span><span class="p">,</span> <span class="n">all_target_peaks</span><span class="p">,</span> <span class="n">num_segments</span><span class="o">=</span><span class="n">num_segments</span><span class="p">,</span> <span class="n">peak_ord</span><span class="o">=</span><span class="n">peak_order</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please change parameters, peaks found in target.&quot;</span><span class="p">)</span>

        <span class="c1"># Add zero to scale the first part of the chromatogram</span>
        <span class="n">reference_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="n">reference_peaks</span><span class="p">])</span>
        <span class="n">target_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="n">target_peaks</span><span class="p">])</span>

        <span class="c1"># Initialize lists to store the calculated lags and their corresponding locations</span>
        <span class="n">lags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lags_location</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">num_initial_peaks</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">target_peaks</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">reference_peaks</span><span class="p">))</span>

        <span class="c1"># Loop over each peak, starting from the second peak (index 1) to the last peak</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_initial_peaks</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Find the previous peak in the target signal (this is to scale interval on the left of target)</span>
                <span class="n">target_peak_prev</span> <span class="o">=</span> <span class="n">all_target_peaks</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">all_target_peaks</span> <span class="o">==</span> <span class="n">target_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error finding previous peak in target signal.&#39;</span><span class="p">)</span>
                <span class="k">continue</span>  <span class="c1"># If the previous peak cannot be found, skip this iteration</span>

            <span class="c1"># Get the current target peak</span>
            <span class="n">target_peak</span> <span class="o">=</span> <span class="n">target_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">reference_peak_prev</span> <span class="o">=</span> <span class="n">target_peak_prev</span>  <span class="c1"># INitialize the previous reference peak to the previous target peak</span>

            <span class="c1"># Find the closest peak in the reference signal to the current target peak</span>
            <span class="n">closest_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">reference_peaks</span> <span class="o">-</span> <span class="n">target_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">start_index</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">closest_index</span> <span class="o">-</span> <span class="n">scan_range</span><span class="p">)</span>  <span class="c1"># Start of scanning from a range around the closest peak</span>
            <span class="n">end_index</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reference_peaks</span><span class="p">),</span> <span class="n">closest_index</span> <span class="o">+</span> <span class="n">scan_range</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># End of scanning</span>

            <span class="c1"># Initialize minimum distance to the parameter-passed minimum average peak distance</span>
            <span class="n">min_distance</span> <span class="o">=</span> <span class="n">min_avg_peak_distance</span>

            <span class="c1"># Define the start and end retention times of the segment in the target signal that will be adjusted</span>
            <span class="n">start</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">target_peak_prev</span><span class="p">,</span> <span class="n">target_peak</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">target_peak_prev</span><span class="p">,</span> <span class="n">target_peak</span><span class="p">)</span>

            <span class="c1"># Explore the surroundings of the reference peak within the specified range</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_index</span><span class="p">,</span> <span class="n">end_index</span><span class="p">):</span>
                <span class="n">reference_peak</span> <span class="o">=</span> <span class="n">reference_peaks</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>  <span class="c1"># Get the current reference peak within the scan range</span>

                <span class="c1"># Check if the current peaks fall within the valid range of the chromatogram</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">reference_peak</span> <span class="o">+</span> <span class="n">interval_after</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">reference_chromatogram</span><span class="p">))</span> <span class="ow">or</span>
                        <span class="p">(</span><span class="n">target_peak</span> <span class="o">+</span> <span class="n">interval_after</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_chromatogram_aligned</span><span class="p">))):</span>
                    <span class="k">continue</span>

                <span class="c1"># Calculate the intervals between the current and previous peaks for both signals</span>
                <span class="n">interval_target</span> <span class="o">=</span> <span class="n">target_peak</span> <span class="o">-</span> <span class="n">target_peak_prev</span>
                <span class="n">interval_reference</span> <span class="o">=</span> <span class="n">reference_peak</span> <span class="o">-</span> <span class="n">reference_peak_prev</span>

                <span class="c1"># Ensure the intervals are valid and within the allowed alignment tolerance</span>
                <span class="k">if</span> <span class="p">(</span>
                        <span class="nb">abs</span><span class="p">(</span><span class="n">reference_peak</span> <span class="o">-</span> <span class="n">target_peak</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">alignment_tolerance</span> <span class="ow">or</span>
                        <span class="n">interval_target</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span>
                        <span class="n">interval_reference</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span>
                        <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span>
                <span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># Calculate the scaling factor based on the ratio of intervals</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="n">interval_reference</span> <span class="o">/</span> <span class="n">interval_target</span>

                <span class="c1"># Extract the segment from the target signal and apply the scaling</span>
                <span class="n">target_segment</span> <span class="o">=</span> <span class="n">target_chromatogram_aligned</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
                <span class="n">scaled_segment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_chromatogram</span><span class="p">(</span><span class="n">target_segment</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">scaled_segment</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>  <span class="c1"># Skip if the scaled segment is empty</span>

                <span class="c1"># Normalize the segments of both reference and target signals for comparison</span>
                <span class="n">norm_reference_segment</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">normalize_amplitude_minmax</span><span class="p">(</span>
                    <span class="n">reference_chromatogram</span><span class="p">[</span><span class="n">reference_peak_prev</span><span class="p">:</span><span class="n">reference_peak</span> <span class="o">+</span> <span class="n">interval_after</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">norm_target_segment</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">normalize_amplitude_minmax</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">scaled_segment</span><span class="p">,</span> <span class="n">target_chromatogram</span><span class="p">[</span><span class="n">end</span><span class="p">:</span><span class="n">end</span> <span class="o">+</span> <span class="n">interval_after</span><span class="p">]])</span>
                <span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Calculate the average peak distance between the normalized segments of target and reference</span>
                    <span class="c1"># avg_peak_dist = calculate_average_peak_distance(</span>
                    <span class="c1">#     norm_reference_segment, norm_target_segment, prominence=1E-6, distance_type=&#39;mean&#39;</span>
                    <span class="c1"># )[0]</span>
                    <span class="n">avg_peak_dist</span> <span class="o">=</span> <span class="n">calculate_weighted_average_peak_distance</span><span class="p">(</span>
                        <span class="n">norm_reference_segment</span><span class="p">,</span> <span class="n">norm_target_segment</span><span class="p">,</span> <span class="n">prominence</span><span class="o">=</span><span class="mf">1E-6</span><span class="p">,</span> <span class="n">distance_type</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span>
                    <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error calculating average peak distance.&#39;</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="c1"># If the calculated average peak distance is less than the current minimum, update the best segment</span>
                <span class="k">if</span> <span class="n">avg_peak_dist</span> <span class="o">&lt;</span> <span class="n">min_distance</span><span class="p">:</span>
                    <span class="n">min_distance</span> <span class="o">=</span> <span class="n">avg_peak_dist</span>
                    <span class="n">best_scaled_segment</span> <span class="o">=</span> <span class="n">scaled_segment</span>
                    <span class="n">best_end</span> <span class="o">=</span> <span class="n">end</span>
                    <span class="n">best_reference_peak</span> <span class="o">=</span> <span class="n">reference_peak</span>

            <span class="c1"># Ensure a best segment was found; otherwise, default to the original segment</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">best_scaled_segment</span>
            <span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
                <span class="n">best_end</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">target_peak_prev</span><span class="p">,</span> <span class="n">target_peak</span><span class="p">)</span>
                <span class="n">best_reference_peak</span> <span class="o">=</span> <span class="n">reference_peak</span>
                <span class="n">best_scaled_segment</span> <span class="o">=</span> <span class="n">target_chromatogram_aligned</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>

            <span class="c1"># Check if the best reference peak is within the allowable alignment tolerance</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                    <span class="n">best_reference_peak</span> <span class="o">-</span> <span class="n">target_peak</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">alignment_tolerance</span> <span class="ow">or</span> <span class="n">best_reference_peak</span> <span class="o">&lt;=</span> <span class="n">reference_peak_prev</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_peaks</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">break</span>  <span class="c1"># If the last peak is reached and conditions are not met, break the loop</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">continue</span>  <span class="c1"># Skip to the next peak</span>

            <span class="c1"># Calculate the stretch required to align the peaks</span>
            <span class="n">stretch</span> <span class="o">=</span> <span class="n">best_reference_peak</span> <span class="o">-</span> <span class="n">target_peak</span>

            <span class="c1"># Identify the next peak in the target signal (this is to scale interval on the right of target)</span>
            <span class="n">next_peak</span> <span class="o">=</span> <span class="n">all_target_peaks</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">all_target_peaks</span> <span class="o">==</span> <span class="n">target_peaks</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># If there is another peak after and sufficient space after the peak to apply the stretch</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_peaks</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_chromatogram_aligned</span><span class="p">[</span><span class="n">best_end</span><span class="p">:</span><span class="n">next_peak</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">stretch</span><span class="p">):</span>
                <span class="n">next_segment</span> <span class="o">=</span> <span class="n">target_chromatogram_aligned</span><span class="p">[</span><span class="n">best_end</span><span class="p">:</span><span class="n">next_peak</span><span class="p">]</span>  <span class="c1"># Extract the section to be scaled</span>
                <span class="n">compensate_factor</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">next_segment</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">next_segment</span><span class="p">)</span> <span class="o">+</span> <span class="n">stretch</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Scale the section using the compensating factor</span>
                    <span class="n">next_segment_corrected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_chromatogram</span><span class="p">(</span><span class="n">next_segment</span><span class="p">,</span> <span class="n">compensate_factor</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error scaling next segment.&#39;</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="c1"># Update the aligned target signal with the corrected segment</span>
                <span class="n">temp_target_chromatogram_aligned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">target_chromatogram_aligned</span><span class="p">[:</span><span class="n">start</span><span class="p">],</span>
                        <span class="n">best_scaled_segment</span><span class="p">,</span>
                        <span class="n">next_segment_corrected</span><span class="p">,</span>
                        <span class="n">target_chromatogram_aligned</span><span class="p">[</span><span class="n">next_peak</span><span class="p">:]</span>
                     <span class="p">]</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If compensation is not needed or possible, just update the aligned target signal with the best segment</span>
                <span class="n">temp_target_chromatogram_aligned</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">target_chromatogram_aligned</span><span class="p">[:</span><span class="n">start</span><span class="p">],</span> <span class="n">best_scaled_segment</span><span class="p">,</span> <span class="n">target_chromatogram_aligned</span><span class="p">[</span><span class="n">best_end</span><span class="p">:]]</span>
                <span class="p">)</span>

            <span class="c1"># Update peaks after realignment and ensure they remain in their respective segments</span>
            <span class="n">temp_target_peaks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">temp_target_chromatogram_aligned</span><span class="p">)</span>
            <span class="n">all_target_peaks</span> <span class="o">=</span> <span class="n">temp_target_peaks</span>
            <span class="n">target_peaks</span><span class="p">,</span> <span class="n">valid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensure_peaks_in_segments</span><span class="p">(</span>
                <span class="n">temp_target_chromatogram_aligned</span><span class="p">,</span> <span class="n">temp_target_peaks</span><span class="p">,</span> <span class="n">num_segments</span><span class="o">=</span><span class="n">num_segments</span><span class="p">,</span> <span class="n">peak_ord</span><span class="o">=</span><span class="n">peak_order</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please change parameters, no peaks found.&quot;</span><span class="p">)</span>

            <span class="n">target_peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span> <span class="n">target_peaks</span><span class="p">])</span>

            <span class="c1"># If not enough peaks are left after alignment, break the loop</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_peaks</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_initial_peaks</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_peaks</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="c1"># Update the aligned target signal</span>
            <span class="n">target_chromatogram_aligned</span> <span class="o">=</span> <span class="n">temp_target_chromatogram_aligned</span>

            <span class="c1"># Avoid the adjusted peak position (target_peak + stretch) ending up at or before any of the existing lag</span>
            <span class="c1"># locations</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lags_location</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">target_peak</span> <span class="o">+</span> <span class="n">stretch</span> <span class="o">&lt;=</span> <span class="n">loc</span> <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">lags_location</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># Append the calculated stretch and its location to the lags list</span>
            <span class="n">lags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stretch</span><span class="p">)</span>
            <span class="n">lags_location</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target_peak</span> <span class="o">+</span> <span class="n">stretch</span><span class="p">)</span>

        <span class="c1"># Add one last point equal to the last one at a specific position (e.g., 30000) to avoid spline growing too large</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lags</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lags</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">lags_location</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">30000</span><span class="p">)</span>

        <span class="c1"># Return the arrays of lag locations and lag values</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lags_location</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lags</span><span class="p">),</span> <span class="n">target_chromatogram_aligned</span></div>


<div class="viewcode-block" id="SyncChromatograms.ensure_peaks_in_segments">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.SyncChromatograms.ensure_peaks_in_segments">[docs]</a>
    <span class="k">def</span> <span class="nf">ensure_peaks_in_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span> <span class="n">peaks_in_signal</span><span class="p">,</span> <span class="n">num_segments</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">last_segment</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">peak_ord</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ensure that each segment of the signal has at least one peak by selecting the most prominent peaks.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        signal : array-like</span>
<span class="sd">            The signal data from which peaks have been identified.</span>
<span class="sd">        peaks_in_signal : array-like</span>
<span class="sd">            Indices of the peaks identified in the signal.</span>
<span class="sd">        num_segments : int, optional</span>
<span class="sd">            The number of segments to divide the signal into. Default is 10.</span>
<span class="sd">        last_segment : int or None, optional</span>
<span class="sd">            The index of the last segment to process. If None, all segments are processed. Default is None.</span>
<span class="sd">        peak_ord : int, optional</span>
<span class="sd">            The ordinal rank of the peak to select in each segment when sorted by prominence. Default is 0 (highest peak).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The indices of the selected peaks across all segments.</span>
<span class="sd">        bool</span>
<span class="sd">            True if peaks were successfully found in all segments, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">segment_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span> <span class="o">//</span> <span class="n">num_segments</span>

        <span class="c1"># Initialize an empty list to store the selected peaks from each segment</span>
        <span class="n">new_peaks</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Iterate through each segment</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_segments</span><span class="p">):</span>
            <span class="c1"># Calculate the start and end indices for the current segment</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">segment_length</span>
            <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">segment_length</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_segments</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>

            <span class="c1"># Find peaks that fall within the current segment</span>
            <span class="n">segment_peaks</span> <span class="o">=</span> <span class="p">[</span><span class="n">peak</span> <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">peaks_in_signal</span> <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">peak</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">]</span>

            <span class="c1"># If no peaks are found in this segment, skip to the next segment</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">segment_peaks</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Sort the peaks in the segment based on their prominence (or signal value at the peak) in descending order</span>
            <span class="n">sorted_peaks</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">segment_peaks</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">signal</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Select the peak based on the specified ordinal rank (e.g., highest, second highest, etc.)</span>
                <span class="n">selected_peak</span> <span class="o">=</span> <span class="n">sorted_peaks</span><span class="p">[</span><span class="n">peak_ord</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>  <span class="c1"># Catch exception if peak_ord is out of range</span>
                <span class="k">continue</span>  <span class="c1"># If the peak_ord is invalid, skip to the next segment</span>

            <span class="c1"># Add the selected peak to the list of new peaks</span>
            <span class="n">new_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">selected_peak</span><span class="p">)</span>

            <span class="c1"># If a specific last segment is defined and reached, break out of the loop</span>
            <span class="k">if</span> <span class="n">last_segment</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">==</span> <span class="n">last_segment</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="c1"># If no peaks were added to the new_peaks list, return an empty array and False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">new_peaks</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_peaks</span><span class="p">),</span> <span class="kc">False</span>

        <span class="c1"># Return the array of selected peaks and True, indicating successful peak selection</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_peaks</span><span class="p">),</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="SyncChromatograms.adjust_chromatogram">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.SyncChromatograms.adjust_chromatogram">[docs]</a>
    <span class="k">def</span> <span class="nf">adjust_chromatogram</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adjusts the chromatogram to match a reference chromatogram.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The adjusted chromatogram after applying the synchronization algorithm.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#### Local functions ####</span>
        <span class="k">def</span> <span class="nf">apply_shift_spline</span><span class="p">(</span><span class="n">c2</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">spline</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Apply a spline-based retention time shift to a chromatogram signal.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            c2 : array-like</span>
<span class="sd">                The chromatogram to be adjusted.</span>
<span class="sd">            t : array-like</span>
<span class="sd">                The time indices in the chromatogram.</span>
<span class="sd">            spline : UnivariateSpline</span>
<span class="sd">                The spline function representing the time shift to be applied.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            numpy.ndarray</span>
<span class="sd">                The chromatogram after the shift has been applied.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">shifted_t</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="n">spline</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">interpolator</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s2">&quot;extrapolate&quot;</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">interpolator</span><span class="p">(</span><span class="n">shifted_t</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">objective_function_spline</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">spline</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;l2&#39;</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Objective function to minimize the difference between the reference and adjusted chromatograms.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            params : array-like</span>
<span class="sd">                Parameters to optimize, typically the smoothing factor for the spline.</span>
<span class="sd">            c1 : array-like</span>
<span class="sd">                The reference chromatogram.</span>
<span class="sd">            c2 : array-like</span>
<span class="sd">                The chromatogram to be adjusted.</span>
<span class="sd">            t : array-like</span>
<span class="sd">                The time points corresponding to the chromatograms.</span>
<span class="sd">            spline : UnivariateSpline</span>
<span class="sd">                The spline function representing the shift to be applied.</span>
<span class="sd">            loss : str, optional</span>
<span class="sd">                The loss function to be used in the optimization. Options are:</span>
<span class="sd">                - &#39;l1&#39;: Mean absolute error</span>
<span class="sd">                - &#39;l2&#39;: Mean squared error (default)</span>
<span class="sd">                - &#39;corr&#39;: Negative maximum cross-correlation</span>
<span class="sd">                - &#39;mse&#39;: Mean squared error</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            float</span>
<span class="sd">                The value of the loss function for the given parameters.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">spline</span><span class="o">.</span><span class="n">set_smoothing_factor</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error in spline.set_smoothing_factor(params[0])&#39;</span><span class="p">)</span>
            <span class="n">c2_shifted</span> <span class="o">=</span> <span class="n">apply_shift_spline</span><span class="p">(</span><span class="n">c2</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">spline</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">loss</span> <span class="o">==</span> <span class="s1">&#39;l1&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">c1</span> <span class="o">-</span> <span class="n">c2_shifted</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">loss</span> <span class="o">==</span> <span class="s1">&#39;l2&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">c2_shifted</span> <span class="o">-</span> <span class="n">c1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">loss</span> <span class="o">==</span> <span class="s1">&#39;corr&#39;</span><span class="p">:</span>
                <span class="n">cross_corr</span> <span class="o">=</span> <span class="n">correlate</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2_shifted</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cross_corr</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">loss</span> <span class="o">==</span> <span class="s1">&#39;mse&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">c2_shifted</span> <span class="o">-</span> <span class="n">c1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">correct_with_spline</span><span class="p">(</span><span class="n">corrected_c2</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Correct the chromatogram using a spline-based shift.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            corrected_c2 : array-like</span>
<span class="sd">                The chromatogram to be corrected.</span>
<span class="sd">            s : float</span>
<span class="sd">                Smoothing factor for the spline.</span>
<span class="sd">            k : int</span>
<span class="sd">                Degree of the spline.</span>
<span class="sd">            normalize : bool, optional</span>
<span class="sd">                Whether to normalize the chromatograms before correction. Default is True.</span>
<span class="sd">            plot : bool, optional</span>
<span class="sd">                Whether to plot the results. Default is False.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            numpy.ndarray</span>
<span class="sd">                The corrected chromatogram after applying the spline-based shift.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">min_len</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">corrected_c2</span><span class="p">))</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">min_max_normalize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[:</span><span class="n">min_len</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
                <span class="n">chrom</span> <span class="o">=</span> <span class="n">min_max_normalize</span><span class="p">(</span><span class="n">corrected_c2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[:</span><span class="n">min_len</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">chrom</span> <span class="o">=</span> <span class="n">corrected_c2</span><span class="p">[:</span><span class="n">min_len</span><span class="p">]</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">spline</span> <span class="o">=</span> <span class="n">UnivariateSpline</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lag_res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">lag_res</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error creating spline&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">chrom</span>

            <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="p">))</span>

            <span class="n">initial_guess</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span>
                <span class="n">objective_function_spline</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">spline</span><span class="p">,</span> <span class="s1">&#39;mse&#39;</span><span class="p">),</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span>
            <span class="p">)</span>

            <span class="n">optimized_smoothing_factor</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">spline</span><span class="o">.</span><span class="n">set_smoothing_factor</span><span class="p">(</span><span class="n">optimized_smoothing_factor</span><span class="p">)</span>
            <span class="n">corrected_c2</span> <span class="o">=</span> <span class="n">apply_shift_spline</span><span class="p">(</span><span class="n">chrom</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">spline</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plot_signal_and_fit</span><span class="p">(</span>
                    <span class="n">t</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">corrected_c2</span><span class="p">,</span> <span class="n">fit_type</span><span class="o">=</span><span class="s1">&#39;spline&#39;</span><span class="p">,</span> <span class="n">fit_params</span><span class="o">=</span><span class="n">spline</span><span class="p">,</span> <span class="n">data_points</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lag_res</span>
                <span class="p">)</span>

            <span class="k">return</span> <span class="n">corrected_c2</span>

        <span class="k">def</span> <span class="nf">correct_with_spline_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">spline</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Correct each column of a matrix using a spline-based shift.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            matrix : np.ndarray</span>
<span class="sd">                The MS matrix where each column corresponds to an m/z channel.</span>
<span class="sd">            t : array-like</span>
<span class="sd">                The time indices in the chromatogram (retention times).</span>
<span class="sd">            spline : UnivariateSpline</span>
<span class="sd">                The spline function representing the time shift to be applied.</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            np.ndarray</span>
<span class="sd">                The corrected MS matrix.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">corrected_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>  <span class="c1"># Iterate over columns (m/z channels)</span>
                <span class="n">corrected_matrix</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">apply_shift_spline</span><span class="p">(</span><span class="n">matrix</span><span class="p">[:,</span> <span class="n">j</span><span class="p">],</span> <span class="n">t</span><span class="p">,</span> <span class="n">spline</span><span class="p">)</span>  <span class="c1"># Correct along retention times</span>
            <span class="k">return</span> <span class="n">corrected_matrix</span>

        <span class="c1">##### End of local functions #####</span>


        <span class="n">corrected_c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c2</span>
        <span class="n">mean_c2s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c2s</span><span class="o">.</span><span class="n">values</span><span class="p">())),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Start first adjustment based on scaling of retention times between main peaks</span>
        <span class="k">for</span> <span class="n">prox</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">40</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndec</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lag_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lag_profile_from_peaks</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c1</span><span class="p">,</span> <span class="n">corrected_c2</span><span class="p">,</span> <span class="n">alignment_tolerance</span><span class="o">=</span><span class="n">prox</span><span class="p">,</span> <span class="n">num_segments</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">apply_global_alignment</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">only_shift</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="c1"># corrected_c2 = correct_with_spline(corrected_c2, 0, 1, normalize=False, plot=False)[:25000]</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lag_res</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Update the TIC and the rows of the MS matrix to account for the global shift</span>
            <span class="n">offset_corrected_c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">correct_segment</span><span class="p">(</span><span class="n">corrected_c2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">target_ms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">correct_matrix_lag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_ms</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lag_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lag_profile_from_ms_data</span><span class="p">(</span>
            <span class="n">gaussian_filter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c1</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">offset_corrected_c2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_ms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_ms</span><span class="p">,</span>
            <span class="c1"># 50 // self.ndec, 150 // self.ndec, show_corrections=False, min_corr=0.80</span>
            <span class="mi">5</span><span class="p">,</span> <span class="mi">150</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndec</span><span class="p">,</span> <span class="n">show_corrections</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">min_corr</span><span class="o">=</span><span class="mf">0.80</span>
        <span class="p">)</span>
        <span class="c1"># Ensure the first and last lags are consistent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lag_res</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lag_res</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lag_res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lag_res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">lag_res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">offset_corrected_c2</span><span class="p">)]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lag_res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="bp">self</span><span class="o">.</span><span class="n">lag_res</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">lag_res</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lag_res</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lag_res</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lag_res</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lag_res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; Not enough points to fit a spline. Skipping sample: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">lag_res</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">c2</span>  <span class="c1"># Or return offset_corrected_c2, or np.copy(self.c2)</span>
        <span class="n">spline</span> <span class="o">=</span> <span class="n">UnivariateSpline</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lag_res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">lag_res</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Correct the MS matrix using the spline</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_ms</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_ms</span> <span class="o">=</span> <span class="n">correct_with_spline_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_ms</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">spline</span><span class="p">)</span>


        <span class="c1"># self.lag_res = list(self.lag_res)</span>
        <span class="c1"># self.lag_res[1] = self.lag_res[1] + offset</span>
        <span class="c1"># self.lag_res[0] = self.lag_res[0] - offset</span>
        <span class="c1"># self.lag_res = tuple(self.lag_res)</span>
        <span class="c1"># corrected_c2 = correct_with_spline(corrected_c2, 0, 1, normalize=False, plot=False)</span>

        <span class="c1"># Correct the TIC using the spline</span>
        <span class="n">corrected_c2</span> <span class="o">=</span> <span class="n">correct_with_spline</span><span class="p">(</span><span class="n">offset_corrected_c2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># # for sl in [8000, 4000, 8000, 4000, 8000, 4000, 8000, 4000, 8000, 4000, 8000, 4000]:</span>
        <span class="c1"># lengths = [8000, 4000, 2000, 8000, 4000, 2000, 8000, 4000, 2000, 8000, 4000, 2000, 8000, 4000, 2000,</span>
        <span class="c1">#            8000, 4000, 2000, 8000, 4000, 2000]</span>
        <span class="c1"># # lengths = [8000, 4000, 2000]</span>
        <span class="c1"># # step_size = (100 - 25) / len(lengths)</span>
        <span class="c1"># for i, sl in enumerate(lengths):</span>
        <span class="c1"># # for sl in [8000, 4000, 2000, 1000, 8000, 4000, 2000, 1000, 8000, 4000, 2000, 1000,]:</span>
        <span class="c1">#     # Fine round</span>
        <span class="c1">#     global_align = False</span>
        <span class="c1">#     sync_chrom = SyncChromatograms(</span>
        <span class="c1">#         self.c1, corrected_c2, 1, self.scales, 1E6,</span>
        <span class="c1">#         threshold=0.00, max_sep_threshold=50, peak_prominence=0.00</span>
        <span class="c1">#     )</span>
        <span class="c1">#     lag_res = sync_chrom.lag_profile_from_correlation(</span>
        <span class="c1">#         gaussian_filter(sync_chrom.c1, 50), gaussian_filter(corrected_c2, 50),</span>
        <span class="c1">#         initial_slice_length=max(4000, sl), max_slice_length=max(4000, sl),</span>
        <span class="c1">#         hop_size=sl, scan_range=int(1000) , apply_global_alignment=global_align, score=0</span>
        <span class="c1">#     )</span>
        <span class="c1">#     sync_chrom.lag_res = lag_res</span>
        <span class="c1">#     corrected_c2 = sync_chrom.correct_with_spline(corrected_c2, 4, 1, normalize=False, plot=False)</span>



        <span class="c1"># # Start second adjustment based on moving individual peaks to match the reference&#39;s</span>
        <span class="c1"># c1 = self.c1.copy()</span>
        <span class="c1"># # Apply Gaussian smoothing to the chromatograms (sigma value found experimentally)</span>
        <span class="c1"># c1 = gaussian_filter(c1, 10)</span>
        <span class="c1"># corrected_c2 = gaussian_filter(corrected_c2, 10)</span>
        <span class="c1">#</span>
        <span class="c1"># plot = False</span>
        <span class="c1"># cnt = 0</span>
        <span class="c1">#</span>
        <span class="c1"># # Iterate over the specified peak order sequence to refine the alignment. Iteratively doing it several times for</span>
        <span class="c1"># # each order improves accuracy</span>
        <span class="c1"># for ord in [0, 0, 0, 1, 1, 1, 1, 1]:</span>
        <span class="c1">#     self.lag_res = self.lag_profile_moving_peaks_individually(</span>
        <span class="c1">#         c1, corrected_c2, alignment_tolerance=250, num_segments=10, apply_global_alignment=False, scan_range=3,</span>
        <span class="c1">#         peak_order=ord, interval_after=3000, min_avg_peak_distance=10</span>
        <span class="c1">#     )</span>
        <span class="c1">#     print(self.lag_res[0], self.lag_res[1])</span>
        <span class="c1">#</span>
        <span class="c1">#     # # Apply spline-based correction to the chromatogram based on the current lag profile</span>
        <span class="c1">#     # corrected_c2 = correct_with_spline(corrected_c2, 20, 1, normalize=False, plot=plot)</span>
        <span class="c1">#     # corrected_c2_sharp = correct_with_spline(corrected_c2_sharp, 20, 1, normalize=False, plot=plot)</span>
        <span class="c1">#     corrected_c2 = self.lag_res[2]</span>
        <span class="c1">#     cnt += 1</span>
        <span class="c1"># # corrected_c2 = corrected_c2_sharp</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">corrected_c2</span><span class="p">)</span></div>


<div class="viewcode-block" id="SyncChromatograms.apply_shift_spline">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.SyncChromatograms.apply_shift_spline">[docs]</a>
    <span class="k">def</span> <span class="nf">apply_shift_spline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">spline</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a spline-based retention time shift to a chromatogram signal.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c2 : array-like</span>
<span class="sd">            The chromatogram to be adjusted.</span>
<span class="sd">        t : array-like</span>
<span class="sd">            The time indices in the chromatogram.</span>
<span class="sd">        spline : UnivariateSpline</span>
<span class="sd">            The spline function representing the time shift to be applied.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The chromatogram after the shift has been applied.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shifted_t</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="n">spline</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">interpolator</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s2">&quot;extrapolate&quot;</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">interpolator</span><span class="p">(</span><span class="n">shifted_t</span><span class="p">)</span></div>



<div class="viewcode-block" id="SyncChromatograms.objective_function_spline">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.SyncChromatograms.objective_function_spline">[docs]</a>
    <span class="k">def</span> <span class="nf">objective_function_spline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">spline</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;l2&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Objective function to minimize the difference between the reference and adjusted chromatograms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : array-like</span>
<span class="sd">            Parameters to optimize, typically the smoothing factor for the spline.</span>
<span class="sd">        c1 : array-like</span>
<span class="sd">            The reference chromatogram.</span>
<span class="sd">        c2 : array-like</span>
<span class="sd">            The chromatogram to be adjusted.</span>
<span class="sd">        t : array-like</span>
<span class="sd">            The time points corresponding to the chromatograms.</span>
<span class="sd">        spline : UnivariateSpline</span>
<span class="sd">            The spline function representing the shift to be applied.</span>
<span class="sd">        loss : str, optional</span>
<span class="sd">            The loss function to be used in the optimization. Options are:</span>
<span class="sd">            - &#39;l1&#39;: Mean absolute error</span>
<span class="sd">            - &#39;l2&#39;: Mean squared error (default)</span>
<span class="sd">            - &#39;corr&#39;: Negative maximum cross-correlation</span>
<span class="sd">            - &#39;mse&#39;: Mean squared error</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The value of the loss function for the given parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">spline</span><span class="o">.</span><span class="n">set_smoothing_factor</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error in spline.set_smoothing_factor(params[0])&#39;</span><span class="p">)</span>
        <span class="n">c2_shifted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_shift_spline</span><span class="p">(</span><span class="n">c2</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">spline</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">loss</span> <span class="o">==</span> <span class="s1">&#39;l1&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">c1</span> <span class="o">-</span> <span class="n">c2_shifted</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">loss</span> <span class="o">==</span> <span class="s1">&#39;l2&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">c2_shifted</span> <span class="o">-</span> <span class="n">c1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">loss</span> <span class="o">==</span> <span class="s1">&#39;corr&#39;</span><span class="p">:</span>
            <span class="n">cross_corr</span> <span class="o">=</span> <span class="n">correlate</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2_shifted</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cross_corr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">loss</span> <span class="o">==</span> <span class="s1">&#39;mse&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">c2_shifted</span> <span class="o">-</span> <span class="n">c1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span></div>



<div class="viewcode-block" id="SyncChromatograms.correct_with_spline">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.SyncChromatograms.correct_with_spline">[docs]</a>
    <span class="k">def</span> <span class="nf">correct_with_spline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">corrected_c2</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Correct the chromatogram using a spline-based shift.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        corrected_c2 : array-like</span>
<span class="sd">            The chromatogram to be corrected.</span>
<span class="sd">        s : float</span>
<span class="sd">            Smoothing factor for the spline.</span>
<span class="sd">        k : int</span>
<span class="sd">            Degree of the spline.</span>
<span class="sd">        normalize : bool, optional</span>
<span class="sd">            Whether to normalize the chromatograms before correction. Default is True.</span>
<span class="sd">        plot : bool, optional</span>
<span class="sd">            Whether to plot the results. Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The corrected chromatogram after applying the spline-based shift.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">min_len</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">corrected_c2</span><span class="p">))</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="n">min_max_normalize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[:</span><span class="n">min_len</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">chrom</span> <span class="o">=</span> <span class="n">min_max_normalize</span><span class="p">(</span><span class="n">corrected_c2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[:</span><span class="n">min_len</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">chrom</span> <span class="o">=</span> <span class="n">corrected_c2</span><span class="p">[:</span><span class="n">min_len</span><span class="p">]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">spline</span> <span class="o">=</span> <span class="n">UnivariateSpline</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lag_res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">lag_res</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error creating spline&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">chrom</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="p">))</span>

        <span class="n">initial_guess</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">objective_function_spline</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">spline</span><span class="p">,</span> <span class="s1">&#39;mse&#39;</span><span class="p">),</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span>
        <span class="p">)</span>

        <span class="n">optimized_smoothing_factor</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">spline</span><span class="o">.</span><span class="n">set_smoothing_factor</span><span class="p">(</span><span class="n">optimized_smoothing_factor</span><span class="p">)</span>
        <span class="n">corrected_c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_shift_spline</span><span class="p">(</span><span class="n">chrom</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">spline</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_signal_and_fit</span><span class="p">(</span>
                <span class="n">t</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">corrected_c2</span><span class="p">,</span> <span class="n">fit_type</span><span class="o">=</span><span class="s1">&#39;spline&#39;</span><span class="p">,</span> <span class="n">fit_params</span><span class="o">=</span><span class="n">spline</span><span class="p">,</span> <span class="n">data_points</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lag_res</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">corrected_c2</span></div>




    <span class="c1"># Function to plot the results</span>
<div class="viewcode-block" id="SyncChromatograms.plot_signal_and_fit">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.SyncChromatograms.plot_signal_and_fit">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_signal_and_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">corrected_c2</span><span class="p">,</span> <span class="n">fit_type</span><span class="o">=</span><span class="s1">&#39;spline&#39;</span><span class="p">,</span> <span class="n">fit_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data_points</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the original and corrected signals, as well as the fitting curve (spline, quadratic, or linear).</span>

<span class="sd">        Parameters:</span>
<span class="sd">        - t: Time axis or index.</span>
<span class="sd">        - ref: Reference signal.</span>
<span class="sd">        - chrom: Original signal before correction.</span>
<span class="sd">        - corrected_c2: Corrected signal after applying the shift.</span>
<span class="sd">        - fit_type: Type of fitting (&#39;spline&#39;, &#39;quadratic&#39;, or &#39;linear&#39;).</span>
<span class="sd">        - fit_params: Parameters for the fit. Could be the spline object, quadratic coefficients, or linear coefficients.</span>
<span class="sd">        - data_points: Data points related to the lag or shift used for plotting (optional).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>

        <span class="c1"># Plot the original and corrected signals</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Reference Signal c1&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">chrom</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Original Signal c2&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">corrected_c2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Shifted Signal c2&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Signals&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Retention time&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Intensity&#39;</span><span class="p">)</span>

        <span class="c1"># Plot the fitting curve along with the data points</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data_points</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">data_points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data_points</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Time shifts&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fit_type</span> <span class="o">==</span> <span class="s1">&#39;spline&#39;</span> <span class="ow">and</span> <span class="n">fit_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">spline</span> <span class="o">=</span> <span class="n">fit_params</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">spline</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Fitted Spline&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">fit_type</span> <span class="o">==</span> <span class="s1">&#39;quadratic&#39;</span> <span class="ow">and</span> <span class="n">fit_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">fit_params</span>
            <span class="n">quadratic_fit</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">data_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="n">data_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">data_points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">quadratic_fit</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Quadratic Fit&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;orange&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">fit_type</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span> <span class="ow">and</span> <span class="n">fit_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">fit_params</span>
            <span class="n">linear_shift</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="n">b</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">linear_shift</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Linear Fit&#39;</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">fit_type</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span><span class="si">}</span><span class="s1"> Fit&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Retention time&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Lag&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="GCMSDataProcessor">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.GCMSDataProcessor">[docs]</a>
<span class="k">class</span> <span class="nc">GCMSDataProcessor</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the GCMSDataProcessor class.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        - data (dict): A dictionary where keys are sample labels and values are 2D numpy arrays</span>
<span class="sd">                       (rows: retention times, columns: m/z abundance data).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>

<div class="viewcode-block" id="GCMSDataProcessor.compute_tics">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.GCMSDataProcessor.compute_tics">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_tics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the Total Ion Chromatogram (TIC) for each sample by summing all columns (m/z) for each retention time.</span>

<span class="sd">        Returns:</span>
<span class="sd">        - dict: A dictionary where keys are sample labels and values are 1D numpy arrays (TIC profiles).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">matrix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span></div>


<div class="viewcode-block" id="GCMSDataProcessor.compute_tiss">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.GCMSDataProcessor.compute_tiss">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_tiss</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the Total Ion Spectrum (TIS) for each sample by summing all rows (retention times) for each m/z channel.</span>

<span class="sd">        Returns:</span>
<span class="sd">        - dict: A dictionary where keys are sample labels and values are 1D numpy arrays (TIS profiles).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">matrix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span></div>


<div class="viewcode-block" id="GCMSDataProcessor.create_overlapping_windows">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.GCMSDataProcessor.create_overlapping_windows">[docs]</a>
    <span class="k">def</span> <span class="nf">create_overlapping_windows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Divide each sample matrix into overlapping windows along the retention time direction.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        - window_size (int): The size of each window in the retention time direction.</span>
<span class="sd">        - stride (int): The step size to move the window.</span>

<span class="sd">        Returns:</span>
<span class="sd">        - numpy.ndarray: An array containing all the smaller matrices in succession for all samples.</span>
<span class="sd">        - numpy.ndarray: A labels array assigning to each matrix the label of the sample they come from.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_matrices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">all_labels</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">matrix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">num_rows</span><span class="p">,</span> <span class="n">num_cols</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span>

            <span class="c1"># Create overlapping windows</span>
            <span class="k">for</span> <span class="n">start_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_rows</span> <span class="o">-</span> <span class="n">window_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">stride</span><span class="p">):</span>
                <span class="n">window</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">start_idx</span> <span class="o">+</span> <span class="n">window_size</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">all_matrices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
                <span class="n">all_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

        <span class="c1"># Convert lists to numpy arrays</span>
        <span class="n">all_matrices_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_matrices</span><span class="p">)</span>
        <span class="n">all_labels_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_labels</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">all_matrices_array</span><span class="p">,</span> <span class="n">all_labels_array</span></div>


<div class="viewcode-block" id="GCMSDataProcessor.normalize_mz_profiles_amplitude">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.GCMSDataProcessor.normalize_mz_profiles_amplitude">[docs]</a>
    <span class="k">def</span> <span class="nf">normalize_mz_profiles_amplitude</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dict</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;z-score&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normalize the amplitude of each m/z profile (column-wise normalization</span>
<span class="sd">        across retention times) using z-score or min-max normalization.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        data_dict : dict</span>
<span class="sd">            Dictionary where each key is a sample and each value is a 2D matrix</span>
<span class="sd">            (rows: retention times, columns: m/z values).</span>
<span class="sd">        method : str</span>
<span class="sd">            Normalization method, either &quot;z-score&quot; or &quot;min-max&quot;.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary with normalized matrices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;z-score&quot;</span><span class="p">,</span> <span class="s2">&quot;min-max&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid method. Choose &#39;z-score&#39; or &#39;min-max&#39;.&quot;</span><span class="p">)</span>

        <span class="n">normalized_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">matrix</span> <span class="ow">in</span> <span class="n">data_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Convert matrix to NumPy array if not already</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;z-score&quot;</span><span class="p">:</span>
                <span class="c1"># Z-score normalization</span>
                <span class="n">col_mean</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Mean for each column (m/z profile)</span>
                <span class="n">col_std</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Standard deviation for each column (m/z profile)</span>
                <span class="n">normalized_matrix</span> <span class="o">=</span> <span class="p">(</span><span class="n">matrix</span> <span class="o">-</span> <span class="n">col_mean</span><span class="p">)</span> <span class="o">/</span> <span class="n">col_std</span>

                <span class="c1"># Handle columns with zero standard deviation (avoid NaN)</span>
                <span class="n">normalized_matrix</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">normalized_matrix</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Replace NaN with 0</span>

            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;min-max&quot;</span><span class="p">:</span>
                <span class="c1"># Min-max normalization</span>
                <span class="n">col_min</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Min for each column (m/z profile)</span>
                <span class="n">col_max</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Max for each column (m/z profile)</span>
                <span class="n">normalized_matrix</span> <span class="o">=</span> <span class="p">(</span><span class="n">matrix</span> <span class="o">-</span> <span class="n">col_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">col_max</span> <span class="o">-</span> <span class="n">col_min</span><span class="p">)</span>

                <span class="c1"># Handle columns with zero range (avoid division by zero)</span>
                <span class="n">normalized_matrix</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">normalized_matrix</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Replace NaN with 0</span>

            <span class="c1"># Store the normalized matrix in the dictionary</span>
            <span class="n">normalized_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">normalized_matrix</span>

        <span class="k">return</span> <span class="n">normalized_dict</span></div>


<div class="viewcode-block" id="GCMSDataProcessor.generate_crops">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.GCMSDataProcessor.generate_crops">[docs]</a>
    <span class="k">def</span> <span class="nf">generate_crops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crop_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate crops from GC-MS data with specified size and stride.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        crop_size : tuple</span>
<span class="sd">            The size of each crop (height, width).</span>
<span class="sd">        stride : tuple</span>
<span class="sd">            The stride for overlapping crops (vertical, horizontal).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary of cropped data for each sample.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cropped_data_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">sample</span><span class="p">,</span> <span class="n">matrix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">crops</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">num_rows</span><span class="p">,</span> <span class="n">num_cols</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">crop_height</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">crop_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">num_rows</span><span class="p">)</span>
            <span class="n">crop_width</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">crop_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">num_cols</span><span class="p">)</span>
            <span class="n">stride_vertical</span><span class="p">,</span> <span class="n">stride_horizontal</span> <span class="o">=</span> <span class="n">stride</span>

            <span class="k">for</span> <span class="n">row_start</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_rows</span> <span class="o">-</span> <span class="n">crop_height</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">stride_vertical</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">col_start</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_cols</span> <span class="o">-</span> <span class="n">crop_width</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">stride_horizontal</span><span class="p">):</span>
                    <span class="n">crop</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">row_start</span><span class="p">:</span><span class="n">row_start</span> <span class="o">+</span> <span class="n">crop_height</span><span class="p">,</span> <span class="n">col_start</span><span class="p">:</span><span class="n">col_start</span> <span class="o">+</span> <span class="n">crop_width</span><span class="p">]</span>
                    <span class="n">crops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">crop</span><span class="p">)</span>

            <span class="n">cropped_data_dict</span><span class="p">[</span><span class="n">sample</span><span class="p">]</span> <span class="o">=</span> <span class="n">crops</span>
        <span class="k">return</span> <span class="n">cropped_data_dict</span></div>


<div class="viewcode-block" id="GCMSDataProcessor.resample_gcms_pytorch">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.GCMSDataProcessor.resample_gcms_pytorch">[docs]</a>
    <span class="k">def</span> <span class="nf">resample_gcms_pytorch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">original_size</span><span class="p">,</span> <span class="n">new_size</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resample GC-MS data using PyTorch interpolation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        original_size : int</span>
<span class="sd">            Original size of the data (e.g., retention times).</span>
<span class="sd">        new_size : int</span>
<span class="sd">            Target size for resampling.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Resampled data dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">resampled_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">scale_factor</span> <span class="o">=</span> <span class="n">new_size</span> <span class="o">/</span> <span class="n">original_size</span>

        <span class="k">for</span> <span class="n">sample_name</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">tensor_data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;cuda&quot;</span><span class="p">)</span>
            <span class="n">resampled_tensor</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">tensor_data</span><span class="p">,</span> <span class="n">scale_factor</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">scale_factor</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;bicubic&#39;</span><span class="p">,</span>
                                             <span class="n">align_corners</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">resampled_dict</span><span class="p">[</span><span class="n">sample_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">resampled_tensor</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">resampled_dict</span></div>


<div class="viewcode-block" id="GCMSDataProcessor.to_dataframe">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.GCMSDataProcessor.to_dataframe">[docs]</a>
    <span class="k">def</span> <span class="nf">to_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the GC-MS data to a Pandas DataFrame for easier analysis.</span>

<span class="sd">        Returns:</span>
<span class="sd">        - pd.DataFrame: A DataFrame where each sample is a column, indexed by retention times.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
            <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span> <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">matrix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span></div>
</div>


<div class="viewcode-block" id="optimize_bayesian_params">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.optimize_bayesian_params">[docs]</a>
<span class="k">def</span> <span class="nf">optimize_bayesian_params</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">num_splits</span><span class="p">,</span> <span class="n">ch_treat</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform Bayesian optimization to select the best hyperparameters for GCMS channel reduction and classification.</span>

<span class="sd">        This function searches for the optimal number of channel aggregations and regularization strength (alpha)</span>
<span class="sd">        using Bayesian optimization. It returns the best alpha and the resulting total number of channels.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray): Input GCMS data of shape (n_samples, n_timepoints, n_channels).</span>
<span class="sd">            labels (list or np.ndarray): Corresponding class labels for each sample.</span>
<span class="sd">            num_splits (int): Number of splits to use in cross-validation during optimization.</span>
<span class="sd">            ch_treat (str): Channel treatment strategy (&#39;concatenated&#39; or &#39;independent&#39;).</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple:</span>
<span class="sd">                alpha (float): The optimal regularization strength found by the optimizer.</span>
<span class="sd">                num_total_channels (int): The number of channels after optimal aggregation.</span>

<span class="sd">        Prints:</span>
<span class="sd">            - Optimal aggregation factor.</span>
<span class="sd">            - Total resulting channels.</span>
<span class="sd">            - Optimal alpha.</span>
<span class="sd">            - Best (lowest) loss achieved during optimization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="n">n_channels</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">optimizer</span> <span class="o">=</span> <span class="n">BayesianParamOptimizer</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">labels</span><span class="p">),</span> <span class="n">n_channels</span><span class="o">=</span><span class="n">n_channels</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">optimize_gcms</span><span class="p">(</span>
        <span class="n">n_calls</span><span class="o">=</span><span class="n">BAYES_CALLS</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="n">num_splits</span><span class="o">=</span><span class="n">num_splits</span><span class="p">,</span> <span class="n">ch_treat</span><span class="o">=</span><span class="n">ch_treat</span>
    <span class="p">)</span>
    <span class="n">num_total_channels</span> <span class="o">=</span> <span class="n">n_channels</span> <span class="o">//</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Optimal channel aggregation number: </span><span class="si">{</span><span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Optimal number of channels: </span><span class="si">{</span><span class="n">num_total_channels</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Optimal alpha: </span><span class="si">{</span><span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Best score: </span><span class="si">{</span><span class="o">-</span><span class="n">result</span><span class="o">.</span><span class="n">fun</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">num_total_channels</span></div>


<div class="viewcode-block" id="process_labels_by_wine_kind">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.process_labels_by_wine_kind">[docs]</a>
<span class="k">def</span> <span class="nf">process_labels_by_wine_kind</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">wine_kind</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">vintage</span><span class="p">,</span> <span class="n">class_by_year</span><span class="p">,</span> <span class="n">chromatograms</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">       Assign labels based on the type of wine and the desired classification region or scheme.</span>

<span class="sd">       This function handles label processing differently depending on the wine type:</span>
<span class="sd">       - For &#39;bordeaux&#39;: returns processed labels, optionally including vintage year.</span>
<span class="sd">       - For &#39;pinot_noir&#39;: assigns labels based on the specified region (e.g., country, origin, winery, etc.).</span>
<span class="sd">       - For &#39;press&#39; wines: assigns composite labels, and optionally extracts vintage year labels</span>
<span class="sd">         if `class_by_year` is True.</span>

<span class="sd">       Args:</span>
<span class="sd">           labels (list or np.ndarray): Original labels or identifiers of the samples.</span>
<span class="sd">           wine_kind (str): Type of wine. One of: &#39;bordeaux&#39;, &#39;pinot_noir&#39;, or &#39;press&#39;.</span>
<span class="sd">           region (str): Labeling scheme to use for &#39;pinot_noir&#39; (e.g., &#39;origin&#39;, &#39;country&#39;, &#39;winery&#39;, etc.).</span>
<span class="sd">           vintage (bool): Whether to include vintage information (used for &#39;bordeaux&#39;).</span>
<span class="sd">           class_by_year (bool): If True and `wine_kind` is &#39;press&#39;, extract year labels from chromatogram keys.</span>
<span class="sd">           chromatograms (dict): Dictionary of chromatograms with sample keys used to extract years for &#39;press&#39;.</span>

<span class="sd">       Returns:</span>
<span class="sd">           If wine_kind == &#39;press&#39;:</span>
<span class="sd">               tuple: (processed_labels, year_labels)</span>
<span class="sd">           Otherwise:</span>
<span class="sd">               processed_labels</span>

<span class="sd">       Raises:</span>
<span class="sd">           ValueError: If an invalid wine kind or region is specified.</span>
<span class="sd">       &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">wine_kind</span> <span class="o">==</span> <span class="s2">&quot;bordeaux&quot;</span><span class="p">:</span>
        <span class="n">processed_labels</span> <span class="o">=</span> <span class="n">process_labels</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">vintage</span><span class="o">=</span><span class="n">vintage</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">processed_labels</span><span class="p">,</span> <span class="kc">None</span>

    <span class="k">elif</span> <span class="n">wine_kind</span> <span class="o">==</span> <span class="s2">&quot;pinot_noir&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">region</span> <span class="o">==</span> <span class="s1">&#39;continent&#39;</span><span class="p">:</span>
            <span class="n">processed_labels</span> <span class="o">=</span> <span class="n">assign_continent_to_pinot_noir</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">region</span> <span class="o">==</span> <span class="s1">&#39;country&#39;</span><span class="p">:</span>
            <span class="n">processed_labels</span> <span class="o">=</span> <span class="n">assign_country_to_pinot_noir</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">region</span> <span class="o">==</span> <span class="s1">&#39;origin&#39;</span><span class="p">:</span>
            <span class="n">processed_labels</span> <span class="o">=</span> <span class="n">assign_origin_to_pinot_noir</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">region</span> <span class="o">==</span> <span class="s1">&#39;winery&#39;</span><span class="p">:</span>
            <span class="n">processed_labels</span> <span class="o">=</span> <span class="n">assign_winery_to_pinot_noir</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">region</span> <span class="o">==</span> <span class="s1">&#39;year&#39;</span><span class="p">:</span>
            <span class="n">processed_labels</span> <span class="o">=</span> <span class="n">assign_year_to_pinot_noir</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">region</span> <span class="o">==</span> <span class="s1">&#39;beaume&#39;</span><span class="p">:</span>
            <span class="n">processed_labels</span> <span class="o">=</span> <span class="n">assign_north_south_to_beaune</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid region. Options are &#39;continent&#39;, &#39;country&#39;, &#39;origin&#39;, &#39;winery&#39;, or &#39;year&#39;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">processed_labels</span><span class="p">,</span> <span class="kc">None</span>

    <span class="k">elif</span> <span class="n">wine_kind</span> <span class="o">==</span> <span class="s2">&quot;press&quot;</span><span class="p">:</span>
        <span class="n">year_labels</span> <span class="o">=</span> <span class="n">extract_year_from_samples</span><span class="p">(</span><span class="n">chromatograms</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">if</span> <span class="n">class_by_year</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">assign_composite_label_to_press_wine</span><span class="p">(</span><span class="n">labels</span><span class="p">),</span> <span class="n">year_labels</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid wine kind&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="process_chromatograms">
<a class="viewcode-back" href="../wine_analysis.html#wine_analysis.process_chromatograms">[docs]</a>
<span class="k">def</span> <span class="nf">process_chromatograms</span><span class="p">(</span><span class="n">gcms</span><span class="p">,</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">sync_state</span><span class="p">,</span> <span class="n">chrom_cap</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Process chromatographic data based on the specified data type and synchronization setting.</span>

<span class="sd">    This function extracts TIC (Total Ion Chromatogram), TIS (Total Ion Spectrum), or both,</span>
<span class="sd">    depending on the specified `data_type`. If `sync_state` is True and `data_type` is &quot;TIC-TIS&quot;,</span>
<span class="sd">    retention time alignment is performed before extraction.</span>

<span class="sd">    Args:</span>
<span class="sd">        gcms (GCMSDataProcessor): An instance containing preloaded GC-MS data.</span>
<span class="sd">        cl (ChromatogramAnalysis): An instance of this class.</span>
<span class="sd">        data_type (str): Type of chromatographic signal to process. Must be one of:</span>
<span class="sd">                         &quot;TIC&quot;, &quot;TIS&quot;, or &quot;TIC-TIS&quot;.</span>
<span class="sd">        sync_state (bool): If True and data_type is &quot;TIC-TIS&quot;, perform TIC alignment using cl.align_tics.</span>
<span class="sd">        chrom_cap (int): Chromatogram cap used during TIC alignment.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict or tuple:</span>
<span class="sd">            - If data_type is &quot;TIC&quot; or &quot;TIS&quot;, returns a dictionary of chromatograms.</span>
<span class="sd">            - If data_type is &quot;TIC-TIS&quot;, returns a tuple (tics, tiss) of dictionaries.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If `data_type` is not one of the supported options.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">data_type</span> <span class="o">==</span> <span class="s2">&quot;TIC&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">gcms</span><span class="o">.</span><span class="n">compute_tics</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="s2">&quot;TIS&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">gcms</span><span class="o">.</span><span class="n">compute_tiss</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="s2">&quot;TIC-TIS&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sync_state</span><span class="p">:</span>
            <span class="n">tics</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cl</span><span class="o">.</span><span class="n">align_tics</span><span class="p">(</span><span class="n">gcms</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">gcms</span><span class="p">,</span> <span class="n">chrom_cap</span><span class="o">=</span><span class="n">chrom_cap</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tics</span> <span class="o">=</span> <span class="n">gcms</span><span class="o">.</span><span class="n">compute_tics</span><span class="p">()</span>
        <span class="n">tiss</span> <span class="o">=</span> <span class="n">gcms</span><span class="o">.</span><span class="n">compute_tiss</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">tics</span><span class="p">,</span> <span class="n">tiss</span>  <span class="c1"># Return both TIC and TIS chromatograms</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid data type. Options are &#39;TIC&#39;, &#39;TIS&#39;, or &#39;TIC-TIS&#39;&quot;</span><span class="p">)</span></div>







</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Wine Analysis Library</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2025, Luis Gomez Camara.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>